<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flow</title>
      <link href="/2022/09/29/Flow/"/>
      <url>/2022/09/29/Flow/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>网络流时间复杂度大约为$O(n^2m)$</p><p>不过也比较玄学罢了</p><p>将一张图建完之后直接跑$dinic$即可</p><p>接下来有封装之后的版本</p><p>注意这个封装版本的最大流应该有以下的特征：</p><ul><li><p>首先最大流这个点我们是从$1$开始的，因此我们在设置对应的起点和终点的时候，应该注意设置</p></li><li><p>其次是边的标号，因为是从$0$开始的</p></li><li><p>所以我们每次开始的边其实都是$etot$</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 1210;const int E &#x3D; 121000;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;        etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,m,s,t;FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;g.init(s,t,n);for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;g.addedge(u,v,w);&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方案分配"><a href="#方案分配" class="headerlink" title="方案分配"></a>方案分配</h3><p>方案分配实际上我们可以思考他的<strong>流量</strong>和之前的关系，然后我们判断这个<strong>流量</strong>来输出方案</p><p>题目条件可以是类似于这样子的，给定一些试题类型，其中再给定一些试题，我每个试题是属于不同的试题类型的，求是否可以分配，并且输出方案</p><p>那么其实我们对应的解决方案是把相对应的东西放到一个$vector$中，然后去判断对应的边的流量即可</p><h4 id="P2763"><a href="#P2763" class="headerlink" title="P2763"></a>P2763</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 1210;const int E &#x3D; 121000;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;        etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,k,s,t;FlowGraph&lt;ll&gt; g;struct node&#123;int st,num,id;&#125;;vector&lt;int&gt; prob[100];int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; k &gt;&gt; n;s &#x3D; n + k + 1;t &#x3D; n + k + 2;g.init(s,t,t + 10);int sum &#x3D; 0;for(int i &#x3D; 1,x;i &lt;&#x3D; k;++i)&#123;&#x2F;&#x2F;1 -&gt; typecin &gt;&gt; x;sum +&#x3D; x;g.addedge(s,i,x);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;sum -&gt; &quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;vector&lt;node&gt; used;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;&#x2F;&#x2F;type + 1 -&gt; type + nint num;cin &gt;&gt; num;for(int j &#x3D; 1,bel;j &lt;&#x3D; num;++j)&#123;cin &gt;&gt; bel;used.push_back(&#123;bel,i,g.etot&#125;);g.addedge(bel,k + i,1);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;g.addedge(k + i,t,1);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;??\n&quot;;ll namomo &#x3D; g.dinic();if(namomo !&#x3D; sum)&#123;cout &lt;&lt; &quot;\n&quot;;&#125;else&#123;for(auto now:used)&#123;int idd &#x3D; now.id;if(g.e[idd].f &#x3D;&#x3D; 0)&#123;prob[now.st].push_back(now.num);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;cout &lt;&lt; i &lt;&lt; &quot;:&quot;;for(auto to:prob[i])&#123;cout &lt;&lt; &quot; &quot; &lt;&lt; to;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;&#125;return 0;&#125;&#x2F;*属于是最大流的方案分配问题，首先显而易见我们可以通过这一条边的流量去判断这个边是否被用过来判断是否属于这一个方案当中那么我们可以这样子，因为我们是把试题库和相对应的试题连接在一起ok，那么这样子我们在建边的时候我们可以把相对应的边的号给放到一个vector里面然后后续我们去检查这个边的流量是否为1即可*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="路径模型"><a href="#路径模型" class="headerlink" title="路径模型"></a>路径模型</h3><p>比如说一个序列，如果可以从$a_i$ 到$a_j$有一条路径，实际上我们也可以映射到一张图上面去考虑，因为我们在做最大流的过程中实际上就是在走一些流的路径</p><p>然后对于一些<strong>流量限制</strong>的情况下我们可以采用<strong>拆点</strong>的方法去限制流量</p><h4 id="P2776"><a href="#P2776" class="headerlink" title="P2776"></a>P2776</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 101210;const int E &#x3D; 1210000;const int maxn &#x3D; 5e2 + 10;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,m,s,t;int a[maxn],dp[maxn];FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];dp[i] &#x3D; 1;&#125;int ans &#x3D; 1;for(int i &#x3D; 2;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt; i;++j)&#123;if(a[i] &gt;&#x3D; a[j])&#123;dp[i] &#x3D; max(dp[i],dp[j] + 1);&#125;&#125;ans &#x3D; max(ans,dp[i]);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;s &#x3D; 2 * n + 1;t &#x3D; 2 * n + 2;g.init(s,t,t);for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(dp[i] &#x3D;&#x3D; 1) g.addedge(s,i,n);&#x2F;&#x2F;添加流量为inf的边if(dp[i] &#x3D;&#x3D; ans) g.addedge(i + n,t,n);g.addedge(i,i + n,1);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(a[j] &gt;&#x3D; a[i] &amp;&amp; dp[j] &#x3D;&#x3D; dp[i] + 1)&#123;g.addedge(i + n,j,1);&#125;&#125;&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;g.init(s,t,t);for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(dp[i] &#x3D;&#x3D; 1) g.addedge(s,i,n);&#x2F;&#x2F;添加流量为inf的边if(dp[i] &#x3D;&#x3D; ans) g.addedge(i + n,t,n);if(ans &#x3D;&#x3D; 1) g.addedge(i,i + n,1);else g.addedge(i,i + n,n);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(a[j] &gt;&#x3D; a[i] &amp;&amp; dp[j] &#x3D;&#x3D; dp[i] + 1)&#123;g.addedge(i + n,j,1);&#125;&#125;&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;&#125;&#x2F;*题目大意：给定一个序列，需要解决如下的三个问题1.求这个序列的最长非递减子序列2.每个元素只能使用一次的情况下序列的最长非递减子序列3.每个元素使用多次的情况下序列的最长非递减子序列建图思路:首先对于第一个问题来说我们直接dp即可对于第二个问题，我们需要思考以下我们的建图方向因为只需要求方案数目，那么我们可以进行这样子的建图，我们可以从s-&gt;dp &#x3D; 1的值建一条边我们也可以从dp &#x3D; ans -&gt; t建一条边因为在第一种情况我们只考虑每一个点使用一个那么我们可以使用拆点拆点是为了加一个限制只能流一个1然后因为我们要找第j个数字可能从哪个第i个数字转移过来 那么我们继续找重新建边即可对于第三个问题 实际上我一个点可以使用多次了那么我们先特判考虑最后答案是1的情况 其实实际上下面两个问题的答案就是n然后我们再考虑一个可以使用多次 那么我们拆店的时候对于多个点建n就可以了*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><p>**概念:**给定一张图，删除一些边使得$s$和$t$不连通</p><p>那么其实就是对于每一个点，我去将点划分为两个集合，每一个点要么属于$s$集合，要么属于$t$集合</p><p>那么对于这里割边来说，实际上就是找一条边，对于他的两个端点$u$和$v$，两个点分别属于一个集合</p><p>最小割 $\geq$ 最大流</p><p>接下来我们分析一下建边的过程</p><p>对于无向图建立割边，实际上我们不仅要考虑正向边，我们也要考虑反向边，那么对于无向图的建图方式实际上就是建两条相同边权的边</p><p>具体的建边方式如下图所示可以</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void addedge(int u,int v,T f,T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],f2&#125;; head[v] &#x3D; etot++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么有向图的话实际上还是和之前的类似，我去建一条长度为$c$的边，另外一条是长度为$0$的边</p><p>如何在实际题目中去思考到<strong>最小割</strong>这个东西呢？</p><h3 id="最大权独立集"><a href="#最大权独立集" class="headerlink" title="最大权独立集"></a>最大权独立集</h3><p>首先我们可以考虑引入这样子的一个问题</p><p>假设我们有两个集合(假设为一个黑子集合和一个白子集合)，每个集合都有$n$个点，每个点都有一个点权，如果我们取了一些黑子那么我们就不能取白子，要求我们最后取得的权值<strong>最大</strong>，对于这一个问题我们如何解答呢？</p><p>我们可以考虑这样子的一个解题方向，我们最后的集合一定是分为两个集合，一个集合是取到的棋子，另外一个集合是没有取到的集合。</p><p>那么分为两个集合的操作是不是就是一个求最小割的过程呢？我们只需要把两个集合分别和$S$和$T$集合连边就可以，然后接下来相对应连边的权值就是他们的点权，然后点之间的限制因为无法切割我们可以采用$inf$</p><p>那么其实对应的如果是二维棋盘我们也可以通过这样子的操作</p><h4 id="P2774"><a href="#P2774" class="headerlink" title="P2774"></a>P2774</h4><p>方格取数，每个方格有一定权值，可以取若干个方格，方格之间不能有相互重叠的边</p><p>本质上也就是求一个最大权独立集的问题，行列相对应建边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const ll inf &#x3D; (1ll &lt;&lt; 60);int n,m,s,t,x;FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;s &#x3D; n * m + 1;t &#x3D; n * m + 2;g.init(s,t,t);ll ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;cin &gt;&gt; x;ans +&#x3D; x;int id &#x3D; (i - 1) * m + j;if((i + j) % 2 &#x3D;&#x3D; 1) &#123;g.addedge(s,id,x);if(i - 1 &gt;&#x3D; 1) g.addedge(id,id - m,inf);if(i + 1 &lt;&#x3D; n) g.addedge(id,id + m,inf);if(j + 1 &lt;&#x3D; m) g.addedge(id,id + 1,inf);if(j - 1 &gt;&#x3D; 1) g.addedge(id,id - 1,inf);&#125;else g.addedge(id,t,x);&#125;&#125;cout &lt;&lt; ans - g.dinic() &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h3><p>最大权闭合子图的定义实际上就是我每个点有一定的点权，选定一些点需要使得点权和最大，然后如果我选了一个点我是必须需要选定其他后继点的，然后我们来求这张图最多获得多少的点权</p><p>其实这个也是最小割的一种模型，那么实际上和最大权独立集的本质是一样的，我给$s$和$t$集合一定的意义，然后我去进行相应的连边。</p><p>考虑这样的一件事情，因为我们在求最小割的过程中实际上是求在$S$集合中的最小割，那么实际上也就是我们把一些东西放到了$S$集合上面。</p><p>那么之前我们说了边的方案如何选择，那么如何去进行选择点的方案呢？</p><p>那么我们可以去看$dis$数组里面的东西，因为$dis$刚开始都是$0$的，对于放在$S$集合里面的东西我们都应该选择$dis$不为$0$的点即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n,m,s,t;FlowGraph&lt;ll&gt; g;string str;const ll inf &#x3D; (1ll &lt;&lt; 60);int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; m &gt;&gt; n;s &#x3D; m + n + 1;t &#x3D; m + n + 2;g.init(s,t,t);ll ans &#x3D; 0;getline(cin,str);for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;getline(cin,str);stringstream ss;ss &lt;&lt; str;&#x2F;&#x2F; cout &lt;&lt; &quot;str -&gt; &quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;;int x;ss &gt;&gt; x;g.addedge(s,i,x);&#x2F;&#x2F;第i个实验的费用ans +&#x3D; x;while(!ss.eof())&#123;ss &gt;&gt; x;g.addedge(i,x + m,inf);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int x;cin &gt;&gt; x;g.addedge(i + m,t,x);&#125;ans -&#x3D; g.dinic();vector&lt;int&gt; p1,p2;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;if(g.dis[i] &gt; 0) p1.push_back(i);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(g.dis[i + m] &gt; 0) p2.push_back(i);&#125;for(auto to:p1) cout &lt;&lt; to &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\n&quot;;for(auto to:p2) cout &lt;&lt; to &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\n&quot;;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 20100;const int E &#x3D; 201000;template&lt;typename T&gt;struct MinCostGraph&#123;int s,t,vtot;int head[V],cur[V],etot;T dis[V],flow,cost;int pre[V];bool vis[V];struct edge&#123;int v,nxt;T f,c;&#125;e[E * 2];void addedge(int u,int v, T f, T c, T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v, head[u], f, c&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u, head[v], f2, -c&#125;; head[v] &#x3D; etot++;&#125;bool spfa()&#123;T inf &#x3D; numeric_limits&lt;T&gt;::max() &#x2F; 2;&#x2F;&#x2F;防止溢出for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i)&#123;dis[i] &#x3D; inf;vis[i] &#x3D; false;pre[i] &#x3D; -1; &#x2F;&#x2F;记录一下上一条边,方便增广&#125;dis[s] &#x3D; 0;vis[s] &#x3D; true;queue&lt;int&gt; q;q.push(s);while(!q.empty())&#123;auto u &#x3D; q.front();for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].nxt)&#123;int v &#x3D; e[i].v;if(e[i].f &amp;&amp; dis[v] &gt; dis[u] + e[i].c)&#123;dis[v] &#x3D; dis[u] + e[i].c;pre[v] &#x3D; i;if(!vis[v])&#123;vis[v] &#x3D; 1;q.push(v);&#125;&#125;&#125;q.pop();vis[u] &#x3D; false;&#125;return dis[t] !&#x3D; inf;&#125;&#x2F;&#x2F;增广void augment()&#123;int u &#x3D; t;T f &#x3D; numeric_limits&lt;T&gt;::max();while(~pre[u])&#123;f &#x3D; min(f, e[pre[u]].f);u &#x3D; e[pre[u] ^ 1].v;&#125;flow +&#x3D; f;cost +&#x3D; f * dis[t];u &#x3D; t;while(~pre[u])&#123;e[pre[u]].f -&#x3D; f;e[pre[u] ^ 1].f +&#x3D; f;u &#x3D; e[pre[u] ^ 1].v;&#125;&#125;pair&lt;T, T&gt; solve()&#123;flow &#x3D; 0;cost &#x3D; 0;while(spfa()) augment();return &#123;flow, cost&#125;;&#125;void init(int s_, int t_, int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i) head[i] &#x3D; -1;&#125;&#125;;MinCostGraph&lt;int&gt; g;int n,m,s,t;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;g.init(s,t,n);for(int i &#x3D; 1,u,v,f,c;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; f &gt;&gt; c;g.addedge(u,v,f,c);&#125;auto ans &#x3D; g.solve();cout &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大费用最大流"><a href="#最大费用最大流" class="headerlink" title="最大费用最大流"></a>最大费用最大流</h3><p>因为我们考虑这样子的一件事情，我们在求$MCMF$的时候实际上求的是最小的费用那么我们只需要建负边并且最终答案取反就可以了</p><h4 id="P4015"><a href="#P4015" class="headerlink" title="P4015"></a>P4015</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MinCostGraph&lt;ll&gt; g1,g2;int n,m,s,t;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;s &#x3D; n + m + 1;t &#x3D; n + m + 2;g1.init(s,t,t);g2.init(s,t,t);for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;g1.addedge(s,i,x,0);g2.addedge(s,i,x,0);&#125;for(int i &#x3D; 1,x;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; x;g1.addedge(i + n,t,x,0);g2.addedge(i + n,t,x,0);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;int x;cin &gt;&gt; x;g1.addedge(i,j + n,1 &lt;&lt; 30,x);g2.addedge(i,j + n,1 &lt;&lt; 30,-x);&#125;&#125;auto ans1 &#x3D; g1.solve();auto ans2 &#x3D; g2.solve();cout &lt;&lt; ans1.second &lt;&lt; &quot;\n&quot; &lt;&lt; -ans2.second &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化建图"><a href="#优化建图" class="headerlink" title="优化建图"></a>优化建图</h3><p><a href="https://codeforces.com/problemset/problem/1525/D">Problem - 1525D - Codeforces</a></p><p>**题意:**给定$n$个座位，每个座位刚开始有两个数字$1$和$0$，题目保证初始给定的$1$的数量少于$0$的数量，将一个$1$移动位置需要$abs(i - j)$的贡献，问让刚开始的$1$全部变成$0$最少需要多少贡献</p><p>**解题思路:**其实刚开始看到题目就想着是裸的费用流，将两种点分在两边，中间连接相对应的边权即可，但是后面发现这样子写的话会有问题。但是考虑反正$1$只会往相邻的$0$移动，那么就相邻的两边建边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 20100;const int E &#x3D; 521000;template&lt;typename T&gt;struct MinCostGraph&#123;int s,t,vtot;int head[V],cur[V],etot;T dis[V],flow,cost;int pre[V];bool vis[V];struct edge&#123;int v,nxt;T f,c;&#125;e[E * 2];void addedge(int u,int v, T f, T c, T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v, head[u], f, c&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u, head[v], f2, -c&#125;; head[v] &#x3D; etot++;&#125;bool spfa()&#123;T inf &#x3D; numeric_limits&lt;T&gt;::max() &#x2F; 2;&#x2F;&#x2F;防止溢出for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i)&#123;dis[i] &#x3D; inf;vis[i] &#x3D; false;pre[i] &#x3D; -1; &#x2F;&#x2F;记录一下上一条边,方便增广&#125;dis[s] &#x3D; 0;vis[s] &#x3D; true;queue&lt;int&gt; q;q.push(s);while(!q.empty())&#123;auto u &#x3D; q.front();for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].nxt)&#123;int v &#x3D; e[i].v;if(e[i].f &amp;&amp; dis[v] &gt; dis[u] + e[i].c)&#123;dis[v] &#x3D; dis[u] + e[i].c;pre[v] &#x3D; i;if(!vis[v])&#123;vis[v] &#x3D; 1;q.push(v);&#125;&#125;&#125;q.pop();vis[u] &#x3D; false;&#125;return dis[t] !&#x3D; inf;&#125;&#x2F;&#x2F;增广void augment()&#123;int u &#x3D; t;T f &#x3D; numeric_limits&lt;T&gt;::max();while(~pre[u])&#123;f &#x3D; min(f, e[pre[u]].f);u &#x3D; e[pre[u] ^ 1].v;&#125;flow +&#x3D; f;cost +&#x3D; f * dis[t];u &#x3D; t;while(~pre[u])&#123;e[pre[u]].f -&#x3D; f;e[pre[u] ^ 1].f +&#x3D; f;u &#x3D; e[pre[u] ^ 1].v;&#125;&#125;pair&lt;T, T&gt; solve()&#123;flow &#x3D; 0;cost &#x3D; 0;while(spfa()) augment();return &#123;flow, cost&#125;;&#125;void init(int s_, int t_, int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i) head[i] &#x3D; -1;&#125;&#125;;MinCostGraph&lt;int&gt; g;int n,m,s,t;int a[V];int main()&#123;cin &gt;&gt; n;s &#x3D; n + 1,t &#x3D; n + 2;g.init(s,t,t);vector&lt;int&gt; pos0,pos1;int ct &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];if(a[i])&#123;&#x2F;&#x2F; ct++;g.addedge(s,i,1,0);&#125;else&#123;g.addedge(i,t,1,0);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;g.addedge(i,i + 1,1 &lt;&lt; 30,1);g.addedge(i + 1,i,1 &lt;&lt; 30,1);&#125;auto [f,c] &#x3D; g.solve();cout &lt;&lt; c &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/28/hello-world/"/>
      <url>/2022/09/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
