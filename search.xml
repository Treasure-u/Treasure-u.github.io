<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DailyTraing</title>
      <link href="/2022/10/09/DailyTraing/"/>
      <url>/2022/10/09/DailyTraing/</url>
      
        <content type="html"><![CDATA[<h1 id="每日思维题"><a href="#每日思维题" class="headerlink" title="每日思维题"></a>每日思维题</h1><h2 id="Graph-and-String"><a href="#Graph-and-String" class="headerlink" title="Graph and String"></a>Graph and String</h2><p><a href="https://codeforces.com/contest/623/problem/A">Problem - A - Codeforces</a></p><p>题目大意：</p><p>给出一个由字符串s<em>s</em>建图的过程。</p><ul><li>字符仅有a,b,c<em>a</em>,<em>b</em>,<em>c</em>三种，建出的图中第i<em>i</em>个顶点表示原来的第i<em>i</em>个字符。</li><li>i<em>i</em>与j<em>j</em>有连边，当且仅当s[i]<em>s</em>[<em>i</em>]与s[j]<em>s</em>[<em>j</em>]相同或s[i]<em>s</em>[<em>i</em>]和s[j]<em>s</em>[<em>j</em>]是相邻的字符（a<em>a</em>与b<em>b</em>相邻，b<em>b</em>与c<em>c</em>相邻）</li></ul><p>现给出由某个字符串s<em>s</em>建出的图，构造一个字符串使其符合上面的要求要求，或者回答不存在这样的字符串。</p><p>解题思路：首先分析题目可以发现这样一件事情，对于出现的$b$来说他是需要连接所有点的，$a$只需要连接相邻的$a$以及$b$即可，$c$的话和$a$同理，那么其实这样子的话我们可以在刚开始的时候处理以下所有和其他点连接的点，赋值为$b$，然后我们可以考虑一件事情，对于$a$和$c$来说相对应的边是不相连的，那么对于原图的补图来说一定是一张二分图，然后我们可以判断二分图并且染色之后再去根据颜色判断，如果两个相邻的边是$a$以及$c$那么就是不行的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 5e2 + 10;int mp[maxn][maxn],n,m;int deg[maxn],col[maxn];char ans[maxn];vector&lt;int&gt; edge[maxn];int flag &#x3D; 1;void dfs(int s,int fa)&#123;for(auto to:edge[s])&#123;if(to &#x3D;&#x3D; fa) continue;if(col[to] &#x3D;&#x3D; -1)&#123;col[to] &#x3D; col[s] ^ 1;dfs(to,s);&#125;else if(col[to] &#x3D;&#x3D; col[s]) flag &#x3D; 0;&#125;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) mp[i][i] &#x3D; 1,col[i] &#x3D; -1;for(int i &#x3D; 1,u,v;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v;mp[u][v] &#x3D; mp[v][u] &#x3D; 1;deg[u]++;deg[v]++;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(mp[i][j]) continue;edge[i].emplace_back(j);edge[j].emplace_back(i);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(deg[i] &#x3D;&#x3D; n - 1) ans[i] &#x3D; &#39;b&#39;;else&#123;if(col[i] &#x3D;&#x3D; -1) col[i] &#x3D; 0,dfs(i,0);&#125;&#125;if(!flag)&#123;cout &lt;&lt; &quot;No\n&quot;;return 0;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(mp[i][j] &amp;&amp; col[i] + col[j] &#x3D;&#x3D; 1)&#123;cout &lt;&lt; &quot;No\n&quot;;return 0;&#125;&#125;&#125;cout &lt;&lt; &quot;Yes\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(deg[i] &#x3D;&#x3D; n - 1)&#123;cout &lt;&lt; &quot;b&quot;;&#125;else if(col[i] &#x3D;&#x3D; 0) cout &lt;&lt; &quot;a&quot;;else cout &lt;&lt; &quot;c&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Carousel"><a href="#Carousel" class="headerlink" title="Carousel"></a>Carousel</h2><p><a href="https://www.luogu.com.cn/problem/CF1328D">CF1328D Carousel - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a> </p><p>**题目大意:**有$q$组询问,每组询问如下:</p><p>已知一个有$n(3\le n\le 2<em>10^5)$个点的*<em>环</em></em>,点$i$的类型为$a_i$,现在需要给每个点进行染色,要求<strong>相邻</strong>不同类型的点的颜色不同且所用颜色数最小.输出颜色数及一种染色方案即可.(颜色从1开始)</p><p>注意: $n ≤2∗10^5$</p><p><strong>解题思路:</strong></p><p>其实很容易想到环的颜色种类不多，至多只有$3$</p><p>那么我们可以进行这样子的讨论，首先我们可以把这个环分成奇环和偶环，对于偶环来说他有比较好的性质我们直接赋值$1$ $2$交替即可</p><p>那奇环呢？分析样例我们可以得出对于两两之间不一样的都是$3$种，反之就是$2$种</p><p>同时我们需要特判以下情况，在这个序列中只存在$1$种或者$2$种数字的情况</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 2e5 + 10;int a[maxn],num[maxn],n;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;int cnt &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];num[a[i]]++;if(num[a[i]] &#x3D;&#x3D; 1) cnt++;&#125;if(cnt &#x3D;&#x3D; 1)&#123;cout &lt;&lt; &quot;1\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cout &lt;&lt; &quot;1 &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;else if(cnt &#x3D;&#x3D; 2)&#123;cout &lt;&lt; 2 &lt;&lt; &quot;\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(a[i] &#x3D;&#x3D; a[1]) cout &lt;&lt; &quot;1 &quot;;else cout &lt;&lt; &quot;2 &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;else if(n % 2 &#x3D;&#x3D; 0)&#123;cout &lt;&lt; 2 &lt;&lt; &quot;\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cout &lt;&lt; (i &amp; 1)  + 1&lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;else&#123;int flag &#x3D; -1;for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;if(a[i] &#x3D;&#x3D; a[i + 1]) flag &#x3D; i;&#125;if(a[n] &#x3D;&#x3D; a[1]) flag &#x3D; n;if(flag &#x3D;&#x3D; -1)&#123;cout &lt;&lt; &quot;3\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;cout &lt;&lt; (i &amp; 1) + 1 &lt;&lt; &quot; &quot;; &#125;cout &lt;&lt; &quot;3\n&quot;;&#125;else&#123;cout &lt;&lt; &quot;2\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; flag;++i)&#123;if(i % 2) cout &lt;&lt; 1 &lt;&lt; &quot; &quot;;else cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;&#125;for(int i &#x3D; flag + 1;i &lt;&#x3D; n;++i)&#123;if(i % 2) cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;else cout &lt;&lt; 1 &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) num[a[i]] &#x3D; 0;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="What-a-Colorful-Wall"><a href="#What-a-Colorful-Wall" class="headerlink" title="What a Colorful Wall"></a>What a Colorful Wall</h2><p><a href="https://codeforces.com/group/MKpYqfAQQQ/contest/393177/problem/F">Problem - F - Codeforces</a></p><p>**题目大意:**给定$n$个矩形，每个矩形有一定的颜色，矩形之间可以相互覆盖，问在$n$个矩形覆盖之后整个坐标系中最多存在着多少种颜色</p><p>**解题思路:**首先先思考这样子的一件事情，因为矩形具有覆盖性，因此我们可以从后往前去放置矩形，因为后面的矩形总是不会被前面的矩形所覆盖，首先对于相同的$x$坐标的一个区域来说，如果一个矩形的高度小于另外一个的高度并且它的，那么它在这个$x$轴影响的$y$上面是被覆盖的，那么对于其他的$x$呢？我们可以利用一个类似于扫描线的做法，遍历相对应的$x$轴遍历过去即可，然后用并查集维护相对应的$y$是否已经是在同一条线上面</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 4e3 + 10;int fa[maxn * 2],n,ans[maxn];vector&lt;int&gt; posx,posy;vector&lt;array&lt;int,5&gt;&gt; pos;void init()&#123;for(int i &#x3D; 0;i &lt;&#x3D; 8010;++i) fa[i] &#x3D; i;&#125;int getf(int x)&#123;if(x &#x3D;&#x3D; fa[x]) return x;fa[x] &#x3D; getf(fa[x]);return fa[x];&#125;void merge(int x,int y)&#123;x &#x3D; getf(x);y &#x3D; getf(y);fa[x] &#x3D; y;&#125;int getx(int x)&#123;int px &#x3D; lower_bound(posx.begin(),posx.end(),x) - posx.begin();return px;&#125;int gety(int y)&#123;int py &#x3D; lower_bound(posy.begin(),posy.end(),y) - posy.begin();return py;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1,x1,y1,x2,y2,col;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; col;posx.push_back(x1),posx.push_back(x2);posy.push_back(y1),posy.push_back(y2);pos.push_back(&#123;x1,y1,x2,y2,col&#125;);&#125;sort(posx.begin(),posx.end());sort(posy.begin(),posy.end());posx.erase(unique(posx.begin(),posx.end()),posx.end());posy.erase(unique(posy.begin(),posy.end()),posy.end());for(auto &amp;now:pos)&#123;now[0] &#x3D; getx(now[0]),now[2] &#x3D; getx(now[2]);now[1] &#x3D; gety(now[1]),now[3] &#x3D; gety(now[3]); &#x2F;&#x2F; cout &lt;&lt; now[0] &lt;&lt; &quot; &quot;&#125;int tot &#x3D; posx.size();for(int i &#x3D; 0;i &lt;&#x3D; tot;++i)&#123;init();for(int j &#x3D; n - 1;j &gt;&#x3D; 0;--j)&#123;auto now &#x3D; pos[j];if(now[0] &lt;&#x3D; i &amp;&amp; now[2] &gt; i)&#123;int ny &#x3D; getf(now[1]);while(ny &gt; now[3])&#123;merge(ny,ny - 1);ans[now[4]] &#x3D; 1;ny &#x3D; getf(ny);&#125;&#125;&#125;&#125;int res &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) res +&#x3D; ans[i];cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Chemical-table"><a href="#Chemical-table" class="headerlink" title="Chemical table"></a>Chemical table</h2><p><a href="https://codeforces.com/contest/1013/problem/D">Problem - D - Codeforces</a></p><p>**题意:**给定一个$n * m$的棋盘，给定$q$个元素，这些元素在棋盘的上面，如果对于一个$2 * 2$的矩形来说，这个矩形中的三个值都存在但是还有一个值不存在，那么这个值也会自动生成，问最多要加多少个值才能使得这个棋盘最后是满的</p><p>**解题思路:**首先我们先分析最后的棋盘的状态，最后棋盘的状态是一个满的形式，对于棋盘来说我们可以把它看成一个二分图的形式，左边是列右边是行，然后我们去分析最终态，最终态是行和列的点都在一个连通块中；然后我们分析题目给定的条件，每次对于一个行和列连边，然后对于生成那个新点来说，实际上并不会影响当前连通块的情况，那么我们只需要连接所有的边，然后找出连通块的数量是多少，最后再加上相对应的边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 4e5 + 10;int f[maxn],n,m,q;int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y)&#123;x &#x3D; getf(x);y &#x3D; getf(y);f[x] &#x3D; y;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;for(int i &#x3D; 1;i &lt;&#x3D; n + m;++i)&#123;f[i] &#x3D; i;&#125;for(int i &#x3D; 1,x,y;i &lt;&#x3D; q;++i)&#123;cin &gt;&gt; x &gt;&gt; y;merge(x,y + n);&#125;int ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n + m;++i)&#123;if(getf(i) &#x3D;&#x3D; i)&#123;ans++;&#125;&#125;cout &lt;&lt; ans - 1 &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Cross-Swapping"><a href="#Cross-Swapping" class="headerlink" title="Cross Swapping"></a>Cross Swapping</h2><p><a href="https://codeforces.com/contest/1713/problem/E">Problem - E - Codeforces</a></p><p>**题意:**给定一个$n * n$的矩阵，可以选定一个$k$，交换所有的$mp[i][k]$和$mp[k][i]$，可以进行这样子的操作若干次，问在进行操作<br>之后这个矩阵字典序最小是什么样子的<br>**解题思路:**模拟每一次交换的过程，我们发现实际上$mp[i][j]$只会和$mp[j][i]$交换，既然这样那么实际上我们就很好去操作了<br>如果我们要交换$mp[i][j]$和$mp[j][i]$，我们只需要选定$k &#x3D; i$ $or$ $k &#x3D; j$,如果不交换我们可以两个都不选或者两个都选偶数次<br>然后的话我们可以用并查集来维护相对应的关系，用类似于敌人朋友的并查集来维护这个东西。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 2e3 + 10;int mp[maxn][maxn],n;int f[maxn];int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y)&#123;x &#x3D; getf(x);y &#x3D; getf(y);f[x] &#x3D; y;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;cin &gt;&gt; mp[i][j];&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; 2 * n;++i) f[i] &#x3D; i;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i;j &lt;&#x3D; n;++j)&#123;if(mp[i][j] &lt; mp[j][i])&#123;&#x2F;&#x2F;not changeif(getf(i) &#x3D;&#x3D; getf(j + n)) continue;merge(i,j),merge(i + n,j + n);&#125;else if(mp[i][j] &gt; mp[j][i])&#123;&#x2F;&#x2F;changeif(getf(i) &#x3D;&#x3D; getf(j)) continue;merge(i,j + n),merge(i + n,j);&#125;&#125;&#125;for(int k &#x3D; 1;k &lt;&#x3D; n;++k)&#123;if(getf(k) &gt; n) continue;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;swap(mp[i][k],mp[k][i]);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;cout &lt;&lt; mp[i][j] &lt;&lt; &quot; \n&quot;[j &#x3D;&#x3D; n];&#125;&#125;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Mikasa"><a href="#Mikasa" class="headerlink" title="Mikasa"></a>Mikasa</h2><p><a href="https://codeforces.com/contest/1554/problem/C">Problem - C - Codeforces</a></p><p>**题意:**给定$T$组数据，每组数据有一个$n$和$m$,给定一个序列从$n \bigoplus 0,n \bigoplus 1,…,n \bigoplus m$问这个序列中没有出现过的最小数字是多少</p><p>**解题思路:**考虑再这个序列中出现过的数字$k$,那么存在$x$使得式子$n \bigoplus x &#x3D; k,x ∈ [0,m]$成立,那么对于上面的式子其实可以等价于$n \bigoplus k &#x3D; x, 0 \leq n \bigoplus k \leq m$，那么我们要求的答案也就是去找一个最小的$k$使得$n \bigoplus k \geq m + 1$，那么这样子的话我们就可以进行按位考虑，假设$p &#x3D; m + 1$,我们从高位开始考虑，如果这个位置上面$n_i &#x3D; 1,p_i &#x3D; 0$,那么直接break掉，如果$n_i &#x3D; 0,p_i &#x3D; 1$,则需要加上这一位的贡献</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longint n,m;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;int p &#x3D; m + 1;int ans &#x3D; 0;for(int i &#x3D; 30;i &gt;&#x3D; 0;--i)&#123;int ni &#x3D; (n &gt;&gt; i &amp; 1);int pi &#x3D; (p &gt;&gt; i &amp; 1);if(ni &#x3D;&#x3D; 1 &amp;&amp; pi &#x3D;&#x3D; 0) break;if(ni &#x3D;&#x3D; 0 &amp;&amp; pi &#x3D;&#x3D; 1) ans +&#x3D; (1 &lt;&lt; i);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Count-Triangles"><a href="#Count-Triangles" class="headerlink" title="Count Triangles"></a>Count Triangles</h2><p><a href="https://codeforces.com/problemset/problem/1355/C">Problem - 1355C - Codeforces</a></p><p>**题意:**给定四个数字$A,B,C,D$使得三角形的三个边$a,b,c$分别满足$A \leq a \leq B, B\leq b \leq C,C \leq c \leq D$,问这样子的三元组$a,b,c$有多少</p><p>**解题思路:**其实拿到题目的时候我们可以直接考虑枚举，但是直接分别枚举$a,b$是否在区间里面时间肯定是有点问题的，但是既然是三角形我们其实如果知道$a + b$是多少我们就能找到对应的第三条边是多少，既然这样的话那么我们只需要枚举$a + b$中有多少个就可以了，然后通过差分数组去维护相对应的数量，那么对应的$a + b$在数据范围中对应的第三条边可能是啥呢？其实是在一个范围中，我们在$a + b - C$和$D + C - 1$中取小的就可以了，当然需要特判一下$a + b - C$小于$0$的情况</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longtypedef long long ll;vector&lt;int&gt; pa,pb,pc;int A,B,C,D;const int maxn &#x3D; 2e6 + 10;int sum[maxn];signed  main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;for(int i &#x3D; A;i &lt;&#x3D; B;++i) sum[i + B]++,sum[i + C + 1]--;for(int i &#x3D; 1;i &lt;&#x3D; 3 * D;++i) sum[i] +&#x3D; sum[i - 1];int ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; 3 * D;++i)&#123;ans +&#x3D; sum[i] * max(0ll,min(i - C,D - C + 1));&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Integers-Have-Friends"><a href="#Integers-Have-Friends" class="headerlink" title="Integers Have Friends"></a>Integers Have Friends</h2><p><a href="https://codeforces.com/problemset/problem/1548/B">Problem - 1548B - Codeforces</a></p><p>**题意:**给定一个长度为$n$的序列，序列中每个元素的数值各不相同，找一个最长的子序列使得这个子序列中$mod $ $m$都是相同的数字</p><p>**解题思路:**因为题目中需要找到$a[i]$  $mod$ $m$ $&#x3D;$ $a[j]$ $mod$ $m$,那么对于这样子的式子我们可以先进行一个化简，那么就是$(a[i] - a[j])  $ $ mod $</p><p> $m &#x3D; 0$,然后我们可以对这个序列进行一个处理，处理之后二分找最长的即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longtypedef long long ll;const int maxn &#x3D; 2e5 + 10;int a[maxn],n;int b[maxn],tree[maxn &lt;&lt; 2];inline void build(int k,int l,int r)&#123;if(l &#x3D;&#x3D; r)&#123;tree[k] &#x3D; b[l];return;&#125;int mid &#x3D; (l + r) &gt;&gt; 1;build(k &lt;&lt; 1,l,mid);build(k &lt;&lt; 1 | 1,mid + 1,r);tree[k] &#x3D; __gcd(tree[k &lt;&lt; 1],tree[k &lt;&lt; 1 | 1]);return;&#125;inline int query(int k,int l,int r,int lx,int rx)&#123;if(l &#x3D;&#x3D; lx &amp;&amp; r &#x3D;&#x3D; rx)&#123;return tree[k];&#125;int mid &#x3D; (l + r) &gt;&gt; 1;int ans &#x3D; 0;if(rx &lt;&#x3D; mid) ans &#x3D; __gcd(ans,query(k &lt;&lt; 1,l,mid,lx,rx));else&#123;if(lx &gt; mid) ans &#x3D; __gcd(ans,query(k &lt;&lt; 1 | 1,mid + 1,r,lx,rx));else ans &#x3D;__gcd(ans,__gcd(query(k &lt;&lt; 1,l,mid,lx,mid),query(k &lt;&lt; 1 | 1,mid + 1,r,mid + 1,rx)));&#125;return ans;&#125;int check(int x)&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(i + x - 1 &gt; n) break;if(abs(query(1,1,n,i + 1,i + x - 1)) !&#x3D; 1)&#123;return 1;&#125;&#125;return 0;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;b[i] &#x3D; a[i] - a[i - 1];&#125;build(1,1,n);int ans &#x3D; 1;int L &#x3D; 2;int R &#x3D; n;while(L &lt;&#x3D; R)&#123;int mid &#x3D; (L + R) &gt;&gt; 1;if(check(mid))&#123;L &#x3D; mid + 1;ans &#x3D; max(ans,mid);&#125;else&#123;R &#x3D; mid - 1;&#125;&#125;cout &lt;&lt; ans&lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Distance-in-Tree"><a href="#Distance-in-Tree" class="headerlink" title="Distance in Tree"></a>Distance in Tree</h2><p><a href="https://codeforces.com/contest/161/problem/D">Problem - D - Codeforces</a></p><p>**题意:**给定一棵$n$个结点的树，需要找出这个树上面距离严格为$k$的点对有多少个<br>**解题思路:**拿到题目之后看$k$的范围实际上不大，有$500$左右，那么其实$nk$时间复杂度的算法是可以过的<br>那么接下来去思考如何用$nk$的时间复杂度去求<br>那么我们可以考虑这样子的一件事情，假设我们已经知道当前这里的一个点距离它距离为$x$的点都已知道<br>那么对于答案的贡献实际上可以是$ans +&#x3D; dp[now][i] * dp[to][k - i - 1]$<br>然后我们再更新相对应的数量即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longconst int maxn &#x3D; 5e4 + 10;int dp[maxn][520];int n,ans,k;vector&lt;int&gt; edge[maxn];void dfs(int s,int fa)&#123;dp[s][0] &#x3D; 1;for(auto to:edge[s])&#123;if(to &#x3D;&#x3D; fa) continue;dfs(to,s);for(int i &#x3D; 0;i &lt; k;++i) ans +&#x3D; dp[s][i] * dp[to][k - i - 1];for(int i &#x3D; 0;i &lt; k;++i) dp[s][i + 1] +&#x3D; dp[to][i];&#125;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; k;for(int i &#x3D; 1,u,v;i &lt;&#x3D; n - 1;++i)&#123;cin &gt;&gt; u &gt;&gt; v;edge[u].emplace_back(v);edge[v].emplace_back(u);&#125;dfs(1,0);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="The-Sports-Festival"><a href="#The-Sports-Festival" class="headerlink" title="The Sports Festival"></a>The Sports Festival</h2><p><a href="https://codeforces.com/problemset/problem/1509/C">Problem - 1509C - Codeforces</a></p><h2 id="Three-Bags"><a href="#Three-Bags" class="headerlink" title="Three Bags"></a>Three Bags</h2><p><a href="https://codeforces.com/problemset/problem/1467/C">Problem - 1467C - Codeforces</a></p><p>**题目大意:**给定$3$个集合，可以选定任意两个集合中的元素$a,b$,移走$b$并且让$a$变成$a - b$</p><p>问最后剩下的元素最大值是多少</p><p>**解题思路:**首先考虑如果在没有集合限制的情况下，其实我们进行这样子的操作就会使得一个数字没有取到，那么其实对应到集合来说，就是两个不同集合的数字的最小值没有取到是最优的；还有一种取法，就是另外两个集合全部取完，还有一个集合全部不取</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longconst int maxn &#x3D; 1e6 + 10;int n,m,k;int sum;int a[maxn],b[maxn],c[maxn],sa,sb,sc;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;int ma,mb,mc;ma &#x3D; mb &#x3D; mc &#x3D; 1e9 + 7;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];sum +&#x3D; a[i];sa +&#x3D; a[i];ma &#x3D; min(ma,a[i]);&#125;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; b[i];sum +&#x3D; b[i];sb +&#x3D; b[i];mb &#x3D; min(mb,b[i]);&#125;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;cin &gt;&gt; c[i];sum +&#x3D; c[i];sc +&#x3D; c[i];mc &#x3D; min(mc,c[i]);&#125;int ans &#x3D; max(&#123;sum - 2 * (ma + mb),sum - 2 * (mb + mc),sum - 2 * (mc + ma),sum - 2 * sa,sum - 2 * sb,sum - 2 * sc&#125;);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dr-Evil-Underscores"><a href="#Dr-Evil-Underscores" class="headerlink" title="Dr. Evil Underscores"></a>Dr. Evil Underscores</h2><p><a href="https://codeforces.com/contest/1285/problem/D">Problem - D - Codeforces</a></p><p>**题意:**给定$n$个数字，需要找到一个数字$x$使得这些数字$\bigoplus x$的最大值最小</p><p>**解题思路:**拿到题目之后我们可以想到拆位去思考，首先我们考虑这样子的一件事情，对于高位来说肯定是能消掉尽可能消掉，不能消掉再看接下来这个高位所带来的影响，然后对于一位来说，如果这一位在所有数字上面都是相同的，那么其实它就可以最后消掉；如果有存在不相同的，对于最终答案来说这一位肯定是取$1$的，但是对于后面的位数还是不确定什么是更优的，因此还是需要找下去</p><p>所以我们可以建立一棵$tire$树，在$tire$树上面跑$dfs$即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 2e6 + 10;int tire[maxn][2],cnt,n;void insert(int x)&#123;int root &#x3D; 0;for(int i &#x3D; 30;i &gt;&#x3D; 0;--i)&#123;int id &#x3D; (x &gt;&gt; i &amp; 1);if(!tire[root][id]) tire[root][id] &#x3D; ++cnt;root &#x3D; tire[root][id];&#125;&#125;int dfs(int pos,int now)&#123;if(now &lt; 0) return 0;int ans &#x3D; 0;if(tire[pos][0] &amp;&amp; tire[pos][1])&#123;ans +&#x3D; (1 &lt;&lt; now);ans +&#x3D; min(dfs(tire[pos][0],now - 1),dfs(tire[pos][1],now - 1)); &#125;else if(tire[pos][0])&#123;ans +&#x3D; dfs(tire[pos][0],now - 1);&#125;else if(tire[pos][1])&#123;ans +&#x3D; dfs(tire[pos][1],now - 1);&#125;return ans;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;insert(x);&#125;cout &lt;&lt; dfs(0,30) &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="New-Year’s-Problem"><a href="#New-Year’s-Problem" class="headerlink" title="New Year’s Problem"></a>New Year’s Problem</h2><p><a href="https://codeforces.com/contest/1619/problem/D">Problem - D - Codeforces</a></p><p>**题目大意:**给定$m$个商店，有$n$个人，最多可以在$n - 1$个商店中买东西，第$i$个人收到第$j$个物品的数值是$A{i,j}$</p><p>问如何选择能够让所有人的最小开心值最高</p><p>**解题思路:**其实题目有两个$trick$点，一个是最小的开心值最大，对于这一个点我们可以使用二分来解决，还有一个就是$n - 1$个商店，那么对于$n - 1$来说我们可以思考的一个点也就是鸽巢原理。那么我们在写二分$check$的时候可以这样子，因为我们是选定$n - 1$个，如果对于当前选定的$x$来说，存在对应的人的最大值没有，那么就直接返回$0$，然后对于第二个部分的话我们可以考虑这样子的一个东西，至少要有一个商店带来两个人的贡献，否则就无法使用$n - 1$个</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 1e5 + 10;int n,m;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;int&gt;&gt; mp(n + 1,vector&lt;int&gt;(m + 1));for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;cin &gt;&gt; mp[i][j];&#125;&#125;auto check &#x3D; [](int x,vector&lt;vector&lt;int&gt;&gt; &amp;mp)&#123;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;int f &#x3D; 0;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;if(mp[j][i] &gt;&#x3D; x) f &#x3D; 1;&#125;if(!f) return 0;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int ct &#x3D; 0;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;ct +&#x3D; (mp[i][j] &gt;&#x3D; x);&#125;if(ct &gt;&#x3D; 2) return 1;&#125;return 0;&#125;;int L &#x3D; 0;int R &#x3D; 1000000000;int ans &#x3D; 0;while(L &lt;&#x3D; R)&#123;int mid &#x3D; (L + R) &gt;&gt; 1;if(check(mid,mp))&#123;L &#x3D; mid + 1;ans &#x3D; max(ans,mid);&#125;else R &#x3D; mid - 1;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Left-Right-Operation"><a href="#Left-Right-Operation" class="headerlink" title="Left Right Operation"></a><strong>Left Right Operation</strong></h2><p><a href="https://atcoder.jp/contests/abc263/tasks/abc263_d">D - Left Right Operation (atcoder.jp)</a></p><h2 id="Zuma"><a href="#Zuma" class="headerlink" title="Zuma"></a>Zuma</h2><p><a href="https://codeforces.com/contest/607/problem/B">Problem - B - Codeforces</a></p><p>**题目大意:**给定$n$个东西，每个东西有一个颜色，每次可以消除颜色是回文串的一个字串，消除一个字串之后会自动拼接回去，问最少需要几次可以消除完</p><p>**解题思路:**数据很小只有$500$，考虑区间$dp$</p><p>然后接下来我们来思考转移过程，因为每次消去的都是一个回文串，那么对于我们枚举的$l$和$r$来说可以放到上一个回文串中一起删除掉，如果$l &#x3D;&#x3D; r$</p><p>那么$dp[l][r] &#x3D; dp[l - 1][r + 1]$</p><p>否则我们需要考虑一个断点，在这个断点的两边进行$dp$</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 5e2 + 10;int dp[maxn][maxn];int a[maxn],n;int check(int l,int r)&#123;string s &#x3D; &quot;&quot;;for(int i &#x3D; l;i &lt;&#x3D; r;++i)&#123;char id &#x3D; &#39;0&#39; + a[i];s.push_back(id);&#125;string ss &#x3D; s;reverse(ss.begin(),ss.end());return ss &#x3D;&#x3D; s;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];dp[i][i] &#x3D; 1;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int r &#x3D; i + 2 - 1;if(r &gt; n) break;if(a[i] !&#x3D; a[r])&#123;dp[i][r] &#x3D; 2;&#125;else dp[i][r] &#x3D; 1;&#125;for(int len &#x3D; 3;len &lt;&#x3D; n;++len)&#123;for(int l &#x3D; 1;l &lt;&#x3D; n;++l)&#123;int r &#x3D; l + len - 1;if(r &gt; n) break;if(a[l] &#x3D;&#x3D; a[r]) dp[l][r] &#x3D; dp[l + 1][r - 1];else dp[l][r] &#x3D; min(dp[l + 1][r],dp[l][r - 1]) + 1;for(int mid &#x3D; l;mid &lt;&#x3D; r;++mid)&#123;chkmin(dp[l][r],dp[l][mid] + dp[mid + 1][r]);&#125;&#125;&#125;cout &lt;&lt; dp[1][n] &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Book-of-Evil"><a href="#Book-of-Evil" class="headerlink" title="Book of Evil"></a>Book of Evil</h2><p><a href="https://codeforces.com/problemset/problem/337/D">Problem - 337D - Codeforces</a></p><h2 id="Empty-Graph"><a href="#Empty-Graph" class="headerlink" title="Empty Graph"></a>Empty Graph</h2><p><a href="https://codeforces.com/problemset/problem/1712/D">https://codeforces.com/problemset/problem/1712/D</a></p><p><strong>题目大意:</strong> 给定一个长度为$n(1\leq n \leq 2e5)$的序列,对于任意的$(l,r),1 \leq l &lt; r \leq n$存在一条边连接$l$以及$r$，边权是$min(a_l,a_{l + 1},…,a_r)$</p><p>我们有$k$次操作机会可以将一个位置上的数字变成任意数字$x(1\leq x \leq 1e9)$,问这张图的直径是多少</p><p>一张图的直径定义如下所示: $max_{1 \leq u &lt; v \leq n}d(u,v)$,$d(u,v)$是从$u$到$v$的最短路</p><p><strong>解题思路:</strong>  首先我们先分析一下$d(u,v)$在这种情况下可能由什么组成，要么我是走两条最小的从$u$到$v$，如果是两个相邻的情况，那么我实际上$u$到$v$是只需要取$min(a_u,a_v)$</p><p>然后考虑这$k$次操作我们怎么使用，因为次数肯定是使用越多我最后的答案趋向于越大，具有一定的单调性，因此我们可以使用二分来写</p><p>我们去遍历整个序列，对于我们当前$check$的$x$来说，如果当前的数字小于$\frac{x}{2}$，那么我们需要一次机会将其变大</p><p>如果当前所需要的次数大于$k$的话，那么是不行的，我们就不要这一种情况</p><p>如果相同的话，我们看一下整个序列最大的$d$是多少，看看是否大于等于$x$即可</p><p>如果小于$k$次的话，找序列中最大的数字即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 2e5 + 10;int a[maxn],n,k,use[maxn];int cal()&#123;int now1 &#x3D; min(use[1],use[2]);for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;now1 &#x3D; max(now1,min(use[i],use[i + 1]));&#125;int mi &#x3D; use[1];for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;chkmin(mi,use[i]);&#125;return min(2 * mi,now1);&#125;int check(int x)&#123;int cs &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) use[i] &#x3D; a[i];for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(use[i] * 2 &lt; x)&#123;cs++;use[i] &#x3D; 1e9;&#125;&#125;if(cs &gt; k) return 0;else if(cs &#x3D;&#x3D; k)&#123;int now &#x3D; cal();&#x2F;&#x2F; cout &lt;&lt; &quot;??? &quot; &lt;&lt; now &lt;&lt; &quot;\n&quot;;if(now &gt;&#x3D; x) return 1;return 0;&#125;else&#123;&#x2F;&#x2F; cout &lt;&lt; 33 &lt;&lt; &quot;\n&quot;;if(k &#x3D;&#x3D; 1)&#123;int now &#x3D; use[1];for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;chkmax(now,use[i]);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;now -&gt; &quot; &lt;&lt; now &lt;&lt; &quot; x -&gt; &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;if(now &gt;&#x3D; x) return 1;return 0;&#125;return 1;&#125;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; k;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];int L &#x3D; 1,R &#x3D; 1e9;int ans &#x3D; 0;&#x2F;&#x2F; cout &lt;&lt; &quot;?? &quot; &lt;&lt; check(4) &lt;&lt; &quot;\n&quot;;while(L &lt;&#x3D; R)&#123;int mid &#x3D; (L + R) &gt;&gt; 1;if(check(mid))&#123;L &#x3D; mid + 1;ans &#x3D; mid;&#125;else R &#x3D; mid - 1;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在异或运算中，若$x \bigoplus y &#x3D; z$则有$x \bigoplus z &#x3D; y$</li><li>在两个数字取余需要相等的时候，可以转移一下位置变成一个等式</li><li>注意模拟样例的时候样例给定的特殊性质</li><li>对于$n - 1$这个数字我们要特殊考虑一下$trick$点</li><li>边着色考虑特殊情况比如有一些情况只需要两种颜色即可$(CF1217D)$</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dytechlab Cup 2022</title>
      <link href="/2022/10/09/Dytechlab-Cup-2022/"/>
      <url>/2022/10/09/Dytechlab-Cup-2022/</url>
      
        <content type="html"><![CDATA[<h1 id="Dytechlab-Cup-2022"><a href="#Dytechlab-Cup-2022" class="headerlink" title="Dytechlab Cup 2022"></a>Dytechlab Cup 2022</h1><h2 id="A-Ela-Sorting-Books"><a href="#A-Ela-Sorting-Books" class="headerlink" title="A. Ela Sorting Books"></a>A. Ela Sorting Books</h2><p><strong>题目大意:</strong>  给定$n(1 \leq n \leq 200)$本书,每本书有一个首字符，要把这$n$本书放到$k$个书架上，每个书架上面按照字典序第一个没有出现过的字符加入集合中，问这个集合最大能够构成的字符是什么</p><p><strong>解题思路:</strong> 模拟样例可以发现一件事情，假设我们当前还有若干个字符，那么从第一个字符按顺序放到最后一个可以连续放置的字符肯定是最优秀的放置方法。那么我们怎么写呢？我们可以枚举每个书架可以最终放入集合的字符是多少，然后$check$即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn &#x3D; 1e6 + 10;int a[maxn],n,k;string str;map&lt;int,int&gt; mp;int check(int x)&#123;if(x &gt; n &#x2F; k) return 0;for(int i &#x3D; 0;i &lt;&#x3D; x - 1;++i)&#123;if(mp[i] &lt;&#x3D; 0) return 0; &#125;for(int i &#x3D; 0;i &lt;&#x3D; x - 1;++i)&#123;mp[i]--;&#125;return 1;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; k;cin &gt;&gt; str;mp.clear();for(auto to:str)&#123;int id &#x3D; to - &#39;a&#39;;mp[id]++;&#125;vector&lt;char&gt; ans;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;for(int j &#x3D; 25;j &gt;&#x3D; 0;--j)&#123;if(check(j))&#123;ans.push_back(&#39;a&#39; + j);break;&#125;&#125;&#125;sort(ans.begin(),ans.end());reverse(ans.begin(),ans.end());for(auto to:ans)&#123;cout &lt;&lt; to;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Ela’s-Fitness-and-the-Luxury-Number"><a href="#B-Ela’s-Fitness-and-the-Luxury-Number" class="headerlink" title="B. Ela’s Fitness and the Luxury Number"></a>B. Ela’s Fitness and the Luxury Number</h2><p><strong>题目大意:</strong> 给定$T (1 \leq T \leq 2e5)$组样例，每组两个数字分别是$l$ 以及$r(1 \leq l,r \leq 1e18)$ ，问在这个区间中美丽数字的个数是多少。美丽数字的定义是$x$可以被$x $  $mod$ $\lfloor\sqrt{x}\rfloor$ $ &#x3D; 0$</p><p><strong>解题思路:</strong> 发现数据范围实际上很大，然后我打了一下表发现了一个规律，就是根据每一个平方数去划分，可以以每个平方数划分成一个块，假设当前的平方数是$x$，当前的平方根是$y$，那么在这一个块中存在的数字分别是$x,x + y,x + 2 * y$</p><p>特别需要注意的是，$floor$存在的一定精度误差，因此在取的时候可以采取一些操作比如$–$来优化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn &#x3D; 1e6 + 10;int a[maxn],n,k;string str;void get()&#123;for(int i &#x3D; 1;i &lt;&#x3D; 20;++i)&#123;int div &#x3D; floor(sqrt(1.0 * i));if(i % div &#x3D;&#x3D; 0)&#123;cout &lt;&lt; &quot;i -&gt; &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;&#125;&#125;&#125;int getans(int x)&#123;if(x &#x3D;&#x3D; 0) return 0;int rd &#x3D; (sqrt(1.0 * x));if(rd * rd &gt; x) rd--;int haha &#x3D; rd * rd;int ans &#x3D; (rd - 1) * 3;if(x &gt;&#x3D; haha)&#123;ans++;&#125;if(x &gt;&#x3D; haha + rd)&#123;ans++;&#125;if(x &gt;&#x3D; haha + rd * 2)&#123;ans++;&#125;return ans;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;int l,r;cin &gt;&gt; l &gt;&gt; r;&#x2F;&#x2F; cout &lt;&lt; getans(l - 1) &lt;&lt; &quot;\n&quot;;&#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; getans(l - 1) &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; getans(r) &lt;&lt; &quot;\n&quot;;cout &lt;&lt; getans(r) - getans(l - 1) &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Ela-and-Crickets"><a href="#C-Ela-and-Crickets" class="headerlink" title="C. Ela and Crickets"></a>C. Ela and Crickets</h2><p><strong>题目大意:</strong> 给定一个无限大的棋盘，给定一个$L$形状的棋子以及这个棋子刚开始的坐标，给定一个目标坐标，问这个棋子通过跳跃的方式能否到达这个目标点</p><p><strong>解题思路:</strong> 既然在一个棋盘上面，我们可以先考虑本身这个棋盘所带来的性质，也就是考虑存在的$L$形状的奇偶性带来的影响。我们可以模拟样例，发现对于一个$L$形状来说，和那个空着的格子的横纵坐标奇偶性都一样的那么我们是不可达的；然后我们考虑特殊情况，如果那个小角在边缘的话，那么不管怎么样子也只能再这个边缘移动，然后这样子判断即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn &#x3D; 1e2 + 10;int r[maxn],n,k,c[maxn],x,y,sx,sy;string str;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;map&lt;int,int&gt; mpx,mpy;for(int i &#x3D; 1;i &lt;&#x3D; 3;++i)&#123;cin &gt;&gt; r[i] &gt;&gt; c[i];mpx[r[i]]++;mpy[c[i]]++;&#125;cin &gt;&gt; x &gt;&gt; y;sx &#x3D; sy &#x3D; 0;for(auto [to,cs]:mpx)&#123;if(cs &#x3D;&#x3D; 2) sx &#x3D; to;&#125;for(auto [to,cs]:mpy)&#123;if(cs &#x3D;&#x3D; 2) sy &#x3D; to;&#125;&#x2F;&#x2F;边缘if((sx &#x3D;&#x3D; 1 || sx &#x3D;&#x3D; n) &amp;&amp; (sy &#x3D;&#x3D; 1 || sy &#x3D;&#x3D; n))&#123;if(sx &#x3D;&#x3D; x || sy &#x3D;&#x3D; y) cout &lt;&lt; &quot;YES\n&quot;;else cout &lt;&lt; &quot;NO\n&quot;;continue;&#125;if((sx - x + sy - y) % 2 &#x3D;&#x3D; 1)&#123;cout &lt;&lt; &quot;YES\n&quot;;continue;&#125;if((sx - x) % 2 &#x3D;&#x3D; 0) cout &lt;&lt; &quot;YES\n&quot;;else if((sy - y) % 2 &#x3D;&#x3D; 0) cout &lt;&lt; &quot;YES\n&quot;;else cout &lt;&lt; &quot;NO\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Ela-and-the-Wiring-Wizard"><a href="#D-Ela-and-the-Wiring-Wizard" class="headerlink" title="D. Ela and the Wiring Wizard"></a>D. Ela and the Wiring Wizard</h2><p><strong>题目大意:</strong> 给定一张图，图有$n$个点$m$条边$(2 \leq n \leq 500,n - 1\leq m \leq 100000)$每次可以进行若干次操作，操作如下所示</p><p>选择两条边$(u,v)$和$(v,w)$删除$(u,v)$然后连接$(u,w)$，代价是$(u,v)$的边权</p><p>问从节点$1$到节点$n$最少需要多少次</p><p><strong>解题思路:</strong> 刚开始拿到题目的时候发现没有任何思路，模拟样例可以发现一个性质，就是无论最后怎么样，最后只有一条从$1$到$n$的边使用</p><p>那么我们可以提出猜想，是否从$1$到$n$只需要连接一条路呢？</p><p>接下来的部分参考了$pzr$佬的</p><p>我们可以做出反证感性理解一下，假设我们有多条路到$n$，其中分别是$1 -&gt; u_1 -&gt; u_2 -&gt; n$,设$u_1 -&gt;u_2$的距离是$w_1$，另外一条从$1 -&gt; u_1$权值是$w_2$</p><p>首先就放着这两条边，边权是$w_1 + w_2$</p><p>如果让我们把所有的边都变成$w_1$,那么就是$2w_1$</p><p>或者我们把所有边变成$w_2$，那么就是$2w_2$</p><p>那么进行修改后我们总能贪心取到最小的</p><p>分析样例之后，我们发现建边有成自环和非自环的情况</p><p>分析非自环的情况，那么对于一条边来说，就是去修改$dis(1,u) + dis(v,n)$的次数然后再加上$1$次走到的贡献</p><p>那么接下来考虑自环的情况，如果有自环的话最多可能存在几个自环呢？</p><p>我们可以把自环看成是一个点，设自环点是$x$,那么我们额外花费一个贡献连接$x$,从$1$到$x$再从$x$到$n$的距离相加然后乘贡献，这个$x$相当于中间的一个断点去更新整张图，因此实际上最多也就只有一个</p><p>那么对于这一种题目来说，分析完整道题目我们发现都是对<strong>边</strong> 这一个元素进行考虑</p><p>因为从一开始我们就在思考，从得出结论开始，再到实际上我去取哪条边最优</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define int long longtypedef long long ll;const int maxn &#x3D; 1e3 + 10;const int inf &#x3D; 1e9;int dis[maxn][maxn],n,m;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;int,3&gt;&gt; edge;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;dis[i][j] &#x3D; inf;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) dis[i][i] &#x3D; 0;for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge.push_back(&#123;u,v,w&#125;);dis[u][v] &#x3D; dis[v][u] &#x3D; 1;&#125;for(int k &#x3D; 1;k &lt;&#x3D; n;++k)&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;chkmin(dis[i][j],dis[i][k] + dis[k][j]);&#125;&#125;&#125;int ans &#x3D; 1e18;for(auto [u,v,w]:edge)&#123;chkmin(ans,(dis[1][u] + 1 + dis[v][n]) * w);chkmin(ans,(dis[1][v] + dis[u][n] + 1) * w);for(int x &#x3D; 1;x &lt;&#x3D; n;++x)&#123;chkmin(ans,(min(dis[u][x],dis[v][x]) + dis[1][x] + dis[x][n] + 2) * w);&#125;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/09/hello-world/"/>
      <url>/2022/10/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 272</title>
      <link href="/2022/10/08/Atcoder-Beginner-Contest-272/"/>
      <url>/2022/10/08/Atcoder-Beginner-Contest-272/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-Beginner-Contest-272"><a href="#Atcoder-Beginner-Contest-272" class="headerlink" title="Atcoder Beginner Contest 272"></a>Atcoder Beginner Contest 272</h1><h2 id="A-Integer-Sum"><a href="#A-Integer-Sum" class="headerlink" title="A - Integer Sum"></a>A - Integer Sum</h2><p><strong>题目大意:</strong> 给定$n$个数字，求$n$个数字的和</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;int n,sum;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;sum +&#x3D; x;&#125;cout &lt;&lt; sum &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Everyone-is-Friends"><a href="#B-Everyone-is-Friends" class="headerlink" title="B - Everyone is Friends"></a>B - Everyone is Friends</h2><p><strong>题目大意:</strong> 给定$n$个人以及$m$个分组，问是否每两个人都曾经出现在同一组过</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;int n,sum,m;set&lt;int&gt; a[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;for(int i &#x3D; 1,num;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; num;for(int j &#x3D; 1,x;j &lt;&#x3D; num;++j)&#123;cin &gt;&gt; x;a[x].insert(i);&#125;&#125;int f &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;int nm &#x3D; 0;for(auto to:a[i])&#123;auto it &#x3D; a[j].find(to);if(it !&#x3D; a[j].end()) &#123;nm++;&#125;&#125;if(nm &gt;&#x3D; 1) f++;&#125;&#125;if(f &#x3D;&#x3D; n * (n - 1) &#x2F; 2) cout &lt;&lt; &quot;Yes\n&quot;;else cout &lt;&lt; &quot;No\n&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Max-Even"><a href="#C-Max-Even" class="headerlink" title="C - Max Even"></a>C - Max Even</h2><p><strong>题目大意:</strong> 给定$n(1 \leq n \leq 2e5)$个数字，问两个不相同的数字加起来的最大偶数是多少</p><p><strong>解题思路:</strong> 分析题目我们可以发现一个关键问题就是两个数字加起来是偶数，那么要么是奇数和奇数相加要么是偶数和偶数相加，我们分类一下数字的奇偶性即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;int n,sum,m;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);set&lt;int&gt; odd,even;cin &gt;&gt; n;for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;if(x &amp; 1) odd.insert(x);else even.insert(x);&#125;int ans &#x3D; -1;if(odd.size() &gt;&#x3D; 2)&#123;int res &#x3D; 0;res +&#x3D; *odd.rbegin();odd.erase(prev(odd.end()));res +&#x3D; *odd.rbegin();ans &#x3D; max(ans,res);&#125;if(even.size() &gt;&#x3D; 2)&#123;int res &#x3D; 0;res +&#x3D; *even.rbegin();even.erase(prev(even.end()));res +&#x3D; *even.rbegin();ans &#x3D; max(ans,res);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Root-M-Leaper"><a href="#D-Root-M-Leaper" class="headerlink" title="D - Root M Leaper"></a>D - Root M Leaper</h2><p><strong>题目大意:</strong> 给定一个$n * n(1\leq n \leq 400)$的棋盘，初始点在$(1,1)$，一个点如果在$(i,j)$当且仅当它可以到$(k,l)$存在他们的$\sqrt{(i - k) ^ 2 + (j - l) ^ 2} &#x3D; \sqrt{m} (1 \leq m \leq 1e5)$</p><p>求这个矩阵中的所有点最少需要几步能被走到</p><p><strong>解题思路:</strong> 发现无论怎么走实际上我们是走不出这个棋盘的，那么实际上$m$最多不会超过$n$，那么我们就可以预处理出所有可以走的步数然后进行$BFS$即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 5e2 + 10;const int inf &#x3D; 1e9;int n,m;int tx[] &#x3D; &#123;1,-1,1,-1&#125;;int ty[] &#x3D; &#123;1,1,-1,-1&#125;;int dis[maxn][maxn];int vis[maxn][maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;vector&lt;pair&lt;int,int&gt;&gt; stp;int lmt &#x3D; min(n,m) + 100;for(int i &#x3D; 0;i &lt;&#x3D; lmt;++i)&#123;for(int j &#x3D; 0;j &lt;&#x3D; lmt;++j)&#123;if(i * i + j * j &#x3D;&#x3D; m)&#123;stp.push_back(&#123;i,j&#125;);stp.push_back(&#123;j,i&#125;);&#125;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j) dis[i][j] &#x3D; inf;&#125;queue&lt;array&lt;int,2&gt;&gt; que;que.push(&#123;1,1&#125;);vis[1][1] &#x3D; 1;dis[1][1] &#x3D; 0;while(!que.empty())&#123;auto [x,y] &#x3D; que.front();que.pop();for(auto [spx,spy]:stp)&#123;for(int k &#x3D; 0;k &lt;&#x3D; 3;++k)&#123;auto fx &#x3D; x + spx * tx[k];auto fy &#x3D; y + spy * ty[k];if(fx &gt;&#x3D; 1 &amp;&amp; fx &lt;&#x3D; n &amp;&amp; fy &gt;&#x3D; 1 &amp;&amp; fy &lt;&#x3D; n &amp;&amp; dis[fx][fy] &#x3D;&#x3D; inf &amp;&amp; vis[fx][fy] &#x3D;&#x3D; 0)&#123;dis[fx][fy] &#x3D; dis[x][y] + 1;vis[fx][fy] &#x3D; 1;que.push(&#123;fx,fy&#125;);&#125;&#125;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;if(dis[i][j] &#x3D;&#x3D; inf) dis[i][j] &#x3D; -1;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;cout &lt;&lt; dis[i][j] &lt;&lt; &quot; \n&quot;[j &#x3D;&#x3D; n];&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Add-and-Mex"><a href="#E-Add-and-Mex" class="headerlink" title="E - Add and Mex"></a>E - Add and Mex</h2><p><strong>题目大意:</strong> 给定一个长度为$n (1 \leq n \leq 2e5)$的数组，数组是$int$范围，给定$m$次操作，每次操作第$i$个位置上面的数字都会加上$i$，问这个数组的$mex$是多少</p><p><strong>解题思路:</strong> 首先我们通过模拟样例可以发现一件事情，就是如果这个序列中的数字是负数，那么它实际上是没有用的，其次是考虑$mex$的性质，因为对于长度为$n$的数组来说，$mex$最大就是$n + 1$，那么对于每一个数字来说最多也不会超过$n + 1$，既然这样，因为对于一个下标为$i$的数字来说，最多加$n &#x2F; i$次，那么对于整个序列来说就是一个调和级数，模拟即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;const int inf &#x3D; 1e9;int n,m;int ans[maxn],a[maxn];vector&lt;int&gt; pos[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];int st &#x3D; 0;if(a[i] &lt; 0)&#123;int rd &#x3D; abs(a[i]) &#x2F; i;if(abs(a[i]) % i) rd++;a[i] +&#x3D; i * rd;st &#x3D; rd;if(st &lt;&#x3D; m)&#123;pos[st].push_back(a[i]);&#125;&#125;while(a[i] + i &lt;&#x3D; n &amp;&amp; st &lt;&#x3D; m)&#123;st++;a[i] +&#x3D; i;if(a[i] &gt;&#x3D; 0)&#123;pos[st].push_back(a[i]);&#125;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;sort(pos[i].begin(),pos[i].end());pos[i].erase(unique(pos[i].begin(),pos[i].end()),pos[i].end());int now &#x3D; 0;for(auto to:pos[i])&#123;if(to !&#x3D; now) break;now++;&#125;cout &lt;&lt; now &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="G-Yet-Another-mod-M"><a href="#G-Yet-Another-mod-M" class="headerlink" title="G - Yet Another mod M"></a>G - Yet Another mod M</h2><p><strong>题目大意:</strong> 给定一个长度为$n(1 \leq n \leq 5000)$，然后找到一个数字$M$，使得这个序列中每一个数字$mod$ $M$后存在唯一的众数</p><p><strong>解题思路:</strong> 在赛时就在想随机是否可行但是没有一个好的$check$方案，然后参考了一下严格鸽的题解</p><p>首先因为是唯一的众数，那么假设我们在序列中取两个数字，这两个数字$mod$ $M$ 都是$0$的，那么就存在$(x - y) $  $mod$  $m &#x3D;&#x3D; 0$</p><p>那接下来我们去找$(x - y)$的因子就可以了</p><p>这样子做的正确概率是：因为$x,y$都有$\frac{1}{2}$的概率取到，那么总的取到的概率就是$\frac{1}{4}$，那我们选择多次选择不到的概率实际上很小，对赌就可以了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;&#x2F;&#x2F; #define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;const int inf &#x3D; 1e9;int n,m;int ans[maxn],a[maxn];vector&lt;int&gt; pos[maxn];int check(int x)&#123;if(x &lt; 3) return 0;map&lt;int,int&gt; mp;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;mp[a[i] % x]++;if(mp[a[i] % x] * 2 &gt; n) return 1;&#125;return 0;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);srand(time(NULL));cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];&#125;int cnt &#x3D; 200;while(cnt--)&#123;int x &#x3D; a[rand() % n + 1];int y &#x3D; a[rand() % n + 1];int d &#x3D; x - y;if(d &#x3D;&#x3D; 0) continue;for(int i &#x3D; 1;i * i &lt;&#x3D; d;++i)&#123;if(d % i !&#x3D; 0) continue;if(check(i))&#123;cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;return 0;&#125;if(check(d &#x2F; i))&#123;cout &lt;&lt; d &#x2F; i &lt;&lt; &quot;\n&quot;;return 0;&#125;&#125;&#125;cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> abc </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 271 C-F</title>
      <link href="/2022/10/02/abc271/"/>
      <url>/2022/10/02/abc271/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-Beginner-Contest-271-C-F"><a href="#Atcoder-Beginner-Contest-271-C-F" class="headerlink" title="Atcoder Beginner Contest 271 C-F"></a>Atcoder Beginner Contest 271 C-F</h1><h2 id="C-Manga"><a href="#C-Manga" class="headerlink" title="C - Manga"></a>C - Manga</h2><p><strong>题意:</strong> 给定一个长度为$n(1 \leq n \leq 3e5)$的序列,每个位置有一个值$x(1 \leq x \leq 1e9)$，我们可以进行任意多次操作，操作的话是如果序列的长度还大于等于$2$，那么我们可以任意选择$2$个数字去删除，然后加进去任意一个数字进去，问我们最后能够得到一个形似$1,2,3…$的最长序列</p><p><strong>解题思路:</strong> 首先我们分析一下题意，我们可以知道最后的答案最多不会超过$n$，那么我们在读入的时候可以将大于$n$的部分放进一个$vector$里面，然后对于小于$n$的一部分我们可以先给他标记然后放到一个双端队列里面，如果其中的数字有重复的部分我们也需要放进上面的$vector$之中。接着我们模拟这个过程即可。在模拟的时候注意我们优先取$vector$当中的，然后我们取队列后面的即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 3e5 + 10;int vis[maxn],n;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;vector&lt;int&gt; a;for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;if(x &lt;&#x3D; n)&#123;if(vis[x]) a.push_back(x);else vis[x] &#x3D; 1;&#125;else a.push_back(x);&#125;deque&lt;int&gt; q;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(vis[i]) q.push_back(i);&#125;int ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(vis[i] &amp;&amp; q.size())&#123;ans++;q.pop_front();continue;&#125;if(a.size() &gt;&#x3D; 2)&#123;a.pop_back();a.pop_back();&#125;else if(a.size() &#x3D;&#x3D; 1)&#123;a.pop_back();if(!q.empty()) q.pop_back(); else break;&#125;else&#123;if(q.size() &gt;&#x3D; 2)&#123;q.pop_back();q.pop_back();&#125;else break;&#125;ans++;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Flip-and-Adjust"><a href="#D-Flip-and-Adjust" class="headerlink" title="D - Flip and Adjust"></a>D - Flip and Adjust</h2><p><strong>题意:</strong> 给定$n(1 \leq n \leq 100)$张卡片，每张卡片背面和正面有一个数字，现在让我们选择每张卡片的正面或者反面，问是否能够组成$s(1\leq s \leq 10000)$</p><p><strong>解题思路:</strong> 首先我们可以观察数据范围，可能是$O(n ^ 3)$或者$O(ns)$的$dp$</p><p>接下来我们考虑这样的一个过程，首先无论如何每张牌都是要取的，那么假定我现在取到第$i - 1$张牌的值有$s_{i - 1}$，那么我取第$i$张牌的时候的值肯定有$s_{i - 1} + mp[i][0]$和$s_{i - 1} + mp[i][1]$$(mp[i][0&#x2F;1]表示第i张牌的正反面的值)$</p><p>那么我们就可以用$dp[i][s]$来表示前$i$张牌可能组成的值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 2e2 + 10;int mp[maxn][2],n,s;int dp[maxn][40010];int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; s;dp[0][0] &#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; mp[i][0] &gt;&gt; mp[i][1];if(i &#x3D;&#x3D; 1)&#123;dp[1][mp[i][0]] &#x3D; 1;dp[1][mp[i][1]] &#x3D; 1;continue;&#125;for(int j &#x3D; 0;j &lt;&#x3D; s;++j)&#123;if(!dp[i - 1][j]) continue;if(j + mp[i][0] &lt;&#x3D; s) dp[i][j + mp[i][0]] &#x3D; 1;if(j + mp[i][1] &lt;&#x3D; s) dp[i][j + mp[i][1]] &#x3D; 1;&#125;&#125;if(dp[n][s])&#123;cout &lt;&lt; &quot;Yes\n&quot;;string ans &#x3D; &quot;&quot;;for(int i &#x3D; n;i &gt;&#x3D; 1;--i)&#123;if(s - mp[i][0] &gt;&#x3D; 0 &amp;&amp; dp[i - 1][s - mp[i][0]])&#123;s -&#x3D; mp[i][0];ans.push_back(&#39;H&#39;);&#125;else&#123;s -&#x3D; mp[i][1];ans.push_back(&#39;T&#39;);&#125;&#125;assert(ans.length() &#x3D;&#x3D; n);reverse(ans.begin(),ans.end());cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;else&#123;cout &lt;&lt; &quot;No\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Subsequence-Path"><a href="#E-Subsequence-Path" class="headerlink" title="E - Subsequence Path"></a>E - Subsequence Path</h2><p><strong>题目大意:</strong> 给定$n$个点$m$条单向边$(1 \leq n,m \leq 2e5)$，没有重边和自环，每个边有一条权值，接下来给定一个序列$E$，我们走的路径的标号形成的序列必须是这个序列$E$的子序列，问从点$1$到点$n$的最短路径</p><p><strong>解题思路:</strong> 分析题目发现我们的突破口应该在这个给定我们的序列$E$这里，因为考虑我们取到的序列是这个序列的子序列，这里给我们透露到一些信息，就是假设我们当前已经遍历到第$i$条边，那么我们是可以用前面$i - 1$条边来更新这一张图的，那么我们知道这个点之后就可以写啦</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longconst int maxn &#x3D; 2e5 + 10;const int inf &#x3D; 1e18;struct node&#123;int u,v,w;&#125;edge[maxn];int n,m,k;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;vector&lt;int&gt; dis(n + 1,inf);for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge[i] &#x3D; &#123;u,v,w&#125;;&#125;dis[1] &#x3D; 0;for(int i &#x3D; 1,x;i &lt;&#x3D; k;++i)&#123;cin &gt;&gt; x;int u &#x3D; edge[x].u;int v &#x3D; edge[x].v;int w &#x3D; edge[x].w;dis[v] &#x3D; min(dis[v],dis[u] + w);&#125;if(dis[n] !&#x3D; inf) cout &lt;&lt; dis[n] &lt;&lt; &quot;\n&quot;;else cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="F-XOR-on-Grid-Path"><a href="#F-XOR-on-Grid-Path" class="headerlink" title="F - XOR on Grid Path"></a>F - XOR on Grid Path</h2><p><strong>题目大意:</strong> 给定一个$n * n(1\leq n \leq 20)$的矩阵，我们从点$(1,1)$开始，每次移动可以向$(x + 1,y)$或者$(x,y + 1)$移动，问我们到达$(n,n)$使得异或和为$0$的路径有多少条</p><p><strong>解题思路:</strong> 首先对于这种矩阵的题目我们肯定先去考虑$dp$的，但是如果暴力去枚举所有方案的话方案数实际会非常的大</p><p>根据官方题解的思路，建议我们使用$meet$  $in$ $middle$来做</p><p>那$meet$  $in$ $middle$是个什么东西呢？大概就是我从两个点来搜索，搜索到一些具有共同性质的点从而结束，因为这样子会大大减少我们所需要的时间复杂度</p><p>那么对于矩阵来说，我们可以从$(1,1)$点和$(n,n)$点来搜索，对于这两个点来说我们都搜索到对角线上面的点来结束,因为对角线刚好分割两个矩阵</p><p>那么我们对于$(1,1)$点来说，我们可以直接搜索下去到对角线来记录当前异或和的数值，那么对于$(n,n)$点来说，我们可以往上面搜索，搜到对角线的话就加上之前前面遍历到这一点的值，因为我们需要异或和是$0$嘛</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longint mp[30][30],n;unordered_map&lt;int,int&gt; dp[30][30];int ans;void dfs1(int x,int y,int now)&#123;if(x + y &#x3D;&#x3D; n)&#123;dp[x][y][now]++;return;&#125;if(x + y &gt; n) return;dfs1(x + 1,y,now ^ mp[x + 1][y]);dfs1(x,y + 1,now ^ mp[x][y + 1]);&#125;void dfs2(int x,int y,int now)&#123;if(x + y &#x3D;&#x3D; n)&#123;ans +&#x3D; dp[x][y][now ^ mp[x][y]];return;&#125;if(x + y &lt; n) return;dfs2(x - 1,y,now ^ mp[x - 1][y]);dfs2(x,y - 1,now ^ mp[x][y - 1]);&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j) cin &gt;&gt; mp[i][j];&#125;dfs1(1,1,mp[1][1]);dfs2(n,n,mp[n][n]);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> abc </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph Traing</title>
      <link href="/2022/09/29/Graph-Traing/"/>
      <url>/2022/09/29/Graph-Traing/</url>
      
        <content type="html"><![CDATA[<h1 id="Graph-Traing"><a href="#Graph-Traing" class="headerlink" title="Graph Traing"></a>Graph Traing</h1><h2 id="Boboniu-Walks-on-Graph"><a href="#Boboniu-Walks-on-Graph" class="headerlink" title="Boboniu Walks on Graph"></a>Boboniu Walks on Graph</h2><p><a href="https://codeforces.com/problemset/problem/1394/B">https://codeforces.com/problemset/problem/1394/B</a></p><p><strong>题目大意:</strong> 给定一张图有$n$个点$m$条边，每条边的权值从$1$ ~ $m$并且每条边的权值互相不相同，这张图中一个点的最大的出度是$k$,然后求$k$元组，这个$k$元组的第$i$个位置代表着出度数为$i$的点走他的边权从小到大为第$c_i$的边，问多元组最多有多少种</p><p><strong>解题思路:</strong> 首先我们可以发现这样子一件事情，因为$k$的范围并不大，因此如果我们暴力去枚举多元组的样子最多也只有$9!$种，那么我们是否可以有一种很快速的$check$方法来检查一种多元组是否合法呢？首先我们可以想这样一件事情，因为对于每一个点最后都能跳回到自己，所以最后的结果必定是一个环，那么对于一个环来说我们可以粗略的将其看成一个集合，然后我们给每个点刚开始随机一个数值。然后我们分析多元组的性质，对于任意一种多元组，第$i$位的跳跃到第$c_i$个，那么我们可以刚开始预处理这个东西，对于当前点的出度和当前去往点的序号记录一个数组然后加起来就可以了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn &#x3D; 1e6 + 10;int n,m,k;int sum[15][15];int a[maxn],ansha,ans;int res;vector&lt;pair&lt;int,int&gt;&gt; edge[maxn];void dfs(int now)&#123;if(now &#x3D;&#x3D; k + 1)&#123;if(res &#x3D;&#x3D; ansha) ans++;return;&#125;for(int i &#x3D; 1;i &lt;&#x3D; now;++i)&#123;res +&#x3D; sum[now][i];dfs(now + 1);res -&#x3D; sum[now][i];&#125;return;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);srand(time(NULL));cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) a[i] &#x3D; rand() * rand(),ansha +&#x3D; a[i];for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge[u].push_back(&#123;w,v&#125;);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) sort(edge[i].begin(),edge[i].end());for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int sz &#x3D; edge[i].size();for(int j &#x3D; 0;j &lt; sz;++j)&#123;auto to &#x3D; edge[i][j].second;sum[sz][j + 1] +&#x3D; a[to];&#125;&#125;dfs(1);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Slipper"><a href="#Slipper" class="headerlink" title="Slipper"></a>Slipper</h2><p>(<a href="https://vjudge.net/contest/517945#problem/C">https://vjudge.net/contest/517945#problem/C</a>)</p><p><strong>题目大意:</strong> 给定一棵树，结点个数为$n (1 \leq n \leq 1e5)$,给定每条树边连接的两个结点和对应的边权，除此之外可以进行若干次魔法，若$|dep_u - dep_v| &#x3D; k$，那么从$u$到$v$只需要$d$点边权，给定两个点$s$和$t$，求从$s$到$t$最少需要多少边权</p><p><strong>解题思路:</strong> 我们可以刚开始这么思考，如果不考虑任何优化，我们可以将每个点放到对应的一个存储容器中，这个容易用$dep$ 来标记，如果两个容器相差$k$，那么我们对于两个集合中的点进行一一连边即可。但是这样子实际的时间复杂度很大，那么我们考虑优化建边。根据上面的思考，我们可以发现一个性质只有层与层之间才会连接一条边，其实很多边是重复的，那么我们对于每一个层来说我们可以建一个点，表示层，那么我们对于每一个点来说，连向这个层，那么对于层与层之间的，我们可以从$u$往$u + k$建一条边，同时也可以从$u + k$往$u$建边，但是只有一层层点是不够的，因为原来的树点连过来的边权是$0$，那么我们再建一层层点来跑最短路即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F; #define int long longtypedef long long ll;const int maxn &#x3D; 6e6 + 10;const int maxm &#x3D; 1e6 + 10;const ll inf &#x3D; 1e18;int tot;struct node&#123;    int u,v,w,nxt;&#125;edge[maxn &lt;&lt; 1];int head[maxn];inline void add(int u,int v,int w)&#123;    edge[++tot].u &#x3D; u,edge[tot].v &#x3D; v,edge[tot].w &#x3D; w,edge[tot].nxt &#x3D; head[u],head[u] &#x3D; tot;&#125;int n,dep[maxm],k,p,s,t,mxdep;void dfs(int s,int fa)&#123;    dep[s] &#x3D; dep[fa] + 1;    mxdep &#x3D; max(mxdep, dep[s]);    for(int i &#x3D; head[s];i;i &#x3D; edge[i].nxt)    &#123;        int to &#x3D; edge[i].v;        if(to &#x3D;&#x3D; fa) continue;        dfs(to,s);    &#125;&#125;void dij()&#123;    vector&lt;int&gt; vis(3 * n + 10, 0);    vector&lt;ll&gt; dis(3 * n + 10, inf);    dis[s] &#x3D; 0;    priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt;&gt;, greater&lt;pair&lt;ll, int&gt;&gt;&gt; que;    que.push(&#123;0, s&#125;);    while(!que.empty())    &#123;        auto now &#x3D; que.top().second;        que.pop();        if(vis[now])            continue;        vis[now] &#x3D; 1;        for(int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)        &#123;            int to &#x3D; edge[i].v;            ll ww &#x3D; edge[i].w * 1ll;            if(dis[to] &gt; dis[now] + ww)            &#123;                dis[to] &#x3D; dis[now] + ww;                que.push(&#123;dis[to], to&#125;);            &#125;        &#125;    &#125;    printf(&quot;%lld\n&quot;,dis[t]);&#125;void solve()&#123;    tot &#x3D; 0;    scanf(&quot;%d&quot;,&amp;n);    &#x2F;&#x2F; cin &gt;&gt; n;    mxdep &#x3D; 0;    for(int i &#x3D; 1;i &lt;&#x3D; n + n + n + 10;++i) head[i] &#x3D; 0;    for (int i &#x3D; 1, u, v, w; i &lt;&#x3D; n - 1;++i)    &#123;        scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);        &#x2F;&#x2F; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        add(u,v,w);        add(v,u,w);    &#125;    dfs(1, 0);    scanf(&quot;%d %d&quot;,&amp;k,&amp;p);    scanf(&quot;%d %d&quot;,&amp;s,&amp;t);    for (int i &#x3D; 1; i &lt;&#x3D; n;++i)    &#123;        add(i,dep[i] + n,0);        add(dep[i] + n + n,i,0);    &#125;    for (int l &#x3D; 1; l &lt;&#x3D; n;++l)    &#123;        int r &#x3D; l + k;        if(r &gt; mxdep)            break;        add(l + n,r + n + n,p);        add(r + n + n,l + n,p);    &#125;    dij();&#125;signed main()&#123;    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);    int T;    scanf(&quot;%d&quot;, &amp;T);    &#x2F;&#x2F; cin &gt;&gt; T;    while(T--)    &#123;        solve();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ela-and-the-Wiring-Wizard"><a href="#Ela-and-the-Wiring-Wizard" class="headerlink" title="Ela and the Wiring Wizard"></a>Ela and the Wiring Wizard</h2><p><a href="https://codeforces.com/contest/1737/problem/D">https://codeforces.com/contest/1737/problem/D</a></p><p><strong>题目大意:</strong> 给定一张图，图有$n$个点$m$条边$(2 \leq n \leq 500,n - 1\leq m \leq 100000)$每次可以进行若干次操作，操作如下所示</p><p>选择两条边$(u,v)$和$(v,w)$删除$(u,v)$然后连接$(u,w)$，代价是$(u,v)$的边权</p><p>问从节点$1$到节点$n$最少需要多少次</p><p><strong>解题思路:</strong> 刚开始拿到题目的时候发现没有任何思路，模拟样例可以发现一个性质，就是无论最后怎么样，最后只有一条从$1$到$n$的边使用</p><p>那么我们可以提出猜想，是否从$1$到$n$只需要连接一条路呢？</p><p>接下来的部分参考了$pzr$佬的</p><p>我们可以做出反证感性理解一下，假设我们有多条路到$n$，其中分别是$1 -&gt; u_1 -&gt; u_2 -&gt; n$,设$u_1 -&gt;u_2$的距离是$w_1$，另外一条从$1 -&gt; u_1$权值是$w_2$</p><p>首先就放着这两条边，边权是$w_1 + w_2$</p><p>如果让我们把所有的边都变成$w_1$,那么就是$2w_1$</p><p>或者我们把所有边变成$w_2$，那么就是$2w_2$</p><p>那么进行修改后我们总能贪心取到最小的</p><p>分析样例之后，我们发现建边有成自环和非自环的情况</p><p>分析非自环的情况，那么对于一条边来说，就是去修改$dis(1,u) + dis(v,n)$的次数然后再加上$1$次走到的贡献</p><p>那么接下来考虑自环的情况，如果有自环的话最多可能存在几个自环呢？</p><p>我们可以把自环看成是一个点，设自环点是$x$,那么我们额外花费一个贡献连接$x$,从$1$到$x$再从$x$到$n$的距离相加然后乘贡献，这个$x$相当于中间的一个断点去更新整张图，因此实际上最多也就只有一个</p><p>那么对于这一种题目来说，分析完整道题目我们发现都是对<strong>边</strong> 这一个元素进行考虑</p><p>因为从一开始我们就在思考，从得出结论开始，再到实际上我去取哪条边最优</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define int long longtypedef long long ll;const int maxn &#x3D; 1e3 + 10;const int inf &#x3D; 1e9;int dis[maxn][maxn],n,m;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;int,3&gt;&gt; edge;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;dis[i][j] &#x3D; inf;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) dis[i][i] &#x3D; 0;for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge.push_back(&#123;u,v,w&#125;);dis[u][v] &#x3D; dis[v][u] &#x3D; 1;&#125;for(int k &#x3D; 1;k &lt;&#x3D; n;++k)&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;chkmin(dis[i][j],dis[i][k] + dis[k][j]);&#125;&#125;&#125;int ans &#x3D; 1e18;for(auto [u,v,w]:edge)&#123;chkmin(ans,(dis[1][u] + 1 + dis[v][n]) * w);chkmin(ans,(dis[1][v] + dis[u][n] + 1) * w);for(int x &#x3D; 1;x &lt;&#x3D; n;++x)&#123;chkmin(ans,(min(dis[u][x],dis[v][x]) + dis[1][x] + dis[x][n] + 2) * w);&#125;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flow</title>
      <link href="/2022/09/29/Flow/"/>
      <url>/2022/09/29/Flow/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>网络流时间复杂度大约为$O(n^2m)$</p><p>不过也比较玄学罢了</p><p>将一张图建完之后直接跑$dinic$即可</p><p>接下来有封装之后的版本</p><p>注意这个封装版本的最大流应该有以下的特征：</p><ul><li><p>首先最大流这个点我们是从$1$开始的，因此我们在设置对应的起点和终点的时候，应该注意设置</p></li><li><p>其次是边的标号，因为是从$0$开始的</p></li><li><p>所以我们每次开始的边其实都是$etot$</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 1210;const int E &#x3D; 121000;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;        etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,m,s,t;FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;g.init(s,t,n);for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;g.addedge(u,v,w);&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方案分配"><a href="#方案分配" class="headerlink" title="方案分配"></a>方案分配</h3><p>方案分配实际上我们可以思考他的<strong>流量</strong>和之前的关系，然后我们判断这个<strong>流量</strong>来输出方案</p><p>题目条件可以是类似于这样子的，给定一些试题类型，其中再给定一些试题，我每个试题是属于不同的试题类型的，求是否可以分配，并且输出方案</p><p>那么其实我们对应的解决方案是把相对应的东西放到一个$vector$中，然后去判断对应的边的流量即可</p><h4 id="P2763"><a href="#P2763" class="headerlink" title="P2763"></a>P2763</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 1210;const int E &#x3D; 121000;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;        etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,k,s,t;FlowGraph&lt;ll&gt; g;struct node&#123;int st,num,id;&#125;;vector&lt;int&gt; prob[100];int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; k &gt;&gt; n;s &#x3D; n + k + 1;t &#x3D; n + k + 2;g.init(s,t,t + 10);int sum &#x3D; 0;for(int i &#x3D; 1,x;i &lt;&#x3D; k;++i)&#123;&#x2F;&#x2F;1 -&gt; typecin &gt;&gt; x;sum +&#x3D; x;g.addedge(s,i,x);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;sum -&gt; &quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;vector&lt;node&gt; used;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;&#x2F;&#x2F;type + 1 -&gt; type + nint num;cin &gt;&gt; num;for(int j &#x3D; 1,bel;j &lt;&#x3D; num;++j)&#123;cin &gt;&gt; bel;used.push_back(&#123;bel,i,g.etot&#125;);g.addedge(bel,k + i,1);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;g.addedge(k + i,t,1);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;??\n&quot;;ll namomo &#x3D; g.dinic();if(namomo !&#x3D; sum)&#123;cout &lt;&lt; &quot;\n&quot;;&#125;else&#123;for(auto now:used)&#123;int idd &#x3D; now.id;if(g.e[idd].f &#x3D;&#x3D; 0)&#123;prob[now.st].push_back(now.num);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;cout &lt;&lt; i &lt;&lt; &quot;:&quot;;for(auto to:prob[i])&#123;cout &lt;&lt; &quot; &quot; &lt;&lt; to;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;&#125;return 0;&#125;&#x2F;*属于是最大流的方案分配问题，首先显而易见我们可以通过这一条边的流量去判断这个边是否被用过来判断是否属于这一个方案当中那么我们可以这样子，因为我们是把试题库和相对应的试题连接在一起ok，那么这样子我们在建边的时候我们可以把相对应的边的号给放到一个vector里面然后后续我们去检查这个边的流量是否为1即可*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="路径模型"><a href="#路径模型" class="headerlink" title="路径模型"></a>路径模型</h3><p>比如说一个序列，如果可以从$a_i$ 到$a_j$有一条路径，实际上我们也可以映射到一张图上面去考虑，因为我们在做最大流的过程中实际上就是在走一些流的路径</p><p>然后对于一些<strong>流量限制</strong>的情况下我们可以采用<strong>拆点</strong>的方法去限制流量</p><h4 id="P2776"><a href="#P2776" class="headerlink" title="P2776"></a>P2776</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 101210;const int E &#x3D; 1210000;const int maxn &#x3D; 5e2 + 10;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,m,s,t;int a[maxn],dp[maxn];FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];dp[i] &#x3D; 1;&#125;int ans &#x3D; 1;for(int i &#x3D; 2;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt; i;++j)&#123;if(a[i] &gt;&#x3D; a[j])&#123;dp[i] &#x3D; max(dp[i],dp[j] + 1);&#125;&#125;ans &#x3D; max(ans,dp[i]);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;s &#x3D; 2 * n + 1;t &#x3D; 2 * n + 2;g.init(s,t,t);for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(dp[i] &#x3D;&#x3D; 1) g.addedge(s,i,n);&#x2F;&#x2F;添加流量为inf的边if(dp[i] &#x3D;&#x3D; ans) g.addedge(i + n,t,n);g.addedge(i,i + n,1);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(a[j] &gt;&#x3D; a[i] &amp;&amp; dp[j] &#x3D;&#x3D; dp[i] + 1)&#123;g.addedge(i + n,j,1);&#125;&#125;&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;g.init(s,t,t);for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(dp[i] &#x3D;&#x3D; 1) g.addedge(s,i,n);&#x2F;&#x2F;添加流量为inf的边if(dp[i] &#x3D;&#x3D; ans) g.addedge(i + n,t,n);if(ans &#x3D;&#x3D; 1) g.addedge(i,i + n,1);else g.addedge(i,i + n,n);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(a[j] &gt;&#x3D; a[i] &amp;&amp; dp[j] &#x3D;&#x3D; dp[i] + 1)&#123;g.addedge(i + n,j,1);&#125;&#125;&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;&#125;&#x2F;*题目大意：给定一个序列，需要解决如下的三个问题1.求这个序列的最长非递减子序列2.每个元素只能使用一次的情况下序列的最长非递减子序列3.每个元素使用多次的情况下序列的最长非递减子序列建图思路:首先对于第一个问题来说我们直接dp即可对于第二个问题，我们需要思考以下我们的建图方向因为只需要求方案数目，那么我们可以进行这样子的建图，我们可以从s-&gt;dp &#x3D; 1的值建一条边我们也可以从dp &#x3D; ans -&gt; t建一条边因为在第一种情况我们只考虑每一个点使用一个那么我们可以使用拆点拆点是为了加一个限制只能流一个1然后因为我们要找第j个数字可能从哪个第i个数字转移过来 那么我们继续找重新建边即可对于第三个问题 实际上我一个点可以使用多次了那么我们先特判考虑最后答案是1的情况 其实实际上下面两个问题的答案就是n然后我们再考虑一个可以使用多次 那么我们拆店的时候对于多个点建n就可以了*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><p><strong>概念:</strong> 给定一张图，删除一些边使得$s$和$t$不连通</p><p>那么其实就是对于每一个点，我去将点划分为两个集合，每一个点要么属于$s$集合，要么属于$t$集合</p><p>那么对于这里割边来说，实际上就是找一条边，对于他的两个端点$u$和$v$，两个点分别属于一个集合</p><p>最小割 $\geq$ 最大流</p><p>接下来我们分析一下建边的过程</p><p>对于无向图建立割边，实际上我们不仅要考虑正向边，我们也要考虑反向边，那么对于无向图的建图方式实际上就是建两条相同边权的边</p><p>具体的建边方式如下图所示可以</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void addedge(int u,int v,T f,T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],f2&#125;; head[v] &#x3D; etot++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么有向图的话实际上还是和之前的类似，我去建一条长度为$c$的边，另外一条是长度为$0$的边</p><p>如何在实际题目中去思考到 <strong>最小割</strong> 这个东西呢？</p><h3 id="最大权独立集"><a href="#最大权独立集" class="headerlink" title="最大权独立集"></a>最大权独立集</h3><p>首先我们可以考虑引入这样子的一个问题</p><p>假设我们有两个集合(假设为一个黑子集合和一个白子集合)，每个集合都有$n$个点，每个点都有一个点权，如果我们取了一些黑子那么我们就不能取白子，要求我们最后取得的权值<strong>最大</strong> ，对于这一个问题我们如何解答呢？</p><p>我们可以考虑这样子的一个解题方向，我们最后的集合一定是分为两个集合，一个集合是取到的棋子，另外一个集合是没有取到的集合。</p><p>那么分为两个集合的操作是不是就是一个求最小割的过程呢？我们只需要把两个集合分别和$S$和$T$集合连边就可以，然后接下来相对应连边的权值就是他们的点权，然后点之间的限制因为无法切割我们可以采用$inf$</p><p>那么其实对应的如果是二维棋盘我们也可以通过这样子的操作</p><h4 id="P2774"><a href="#P2774" class="headerlink" title="P2774"></a>P2774</h4><p>方格取数，每个方格有一定权值，可以取若干个方格，方格之间不能有相互重叠的边</p><p>本质上也就是求一个最大权独立集的问题，行列相对应建边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const ll inf &#x3D; (1ll &lt;&lt; 60);int n,m,s,t,x;FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;s &#x3D; n * m + 1;t &#x3D; n * m + 2;g.init(s,t,t);ll ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;cin &gt;&gt; x;ans +&#x3D; x;int id &#x3D; (i - 1) * m + j;if((i + j) % 2 &#x3D;&#x3D; 1) &#123;g.addedge(s,id,x);if(i - 1 &gt;&#x3D; 1) g.addedge(id,id - m,inf);if(i + 1 &lt;&#x3D; n) g.addedge(id,id + m,inf);if(j + 1 &lt;&#x3D; m) g.addedge(id,id + 1,inf);if(j - 1 &gt;&#x3D; 1) g.addedge(id,id - 1,inf);&#125;else g.addedge(id,t,x);&#125;&#125;cout &lt;&lt; ans - g.dinic() &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h3><p>最大权闭合子图的定义实际上就是我每个点有一定的点权，选定一些点需要使得点权和最大，然后如果我选了一个点我是必须需要选定其他后继点的，然后我们来求这张图最多获得多少的点权</p><p>其实这个也是最小割的一种模型，那么实际上和最大权独立集的本质是一样的，我给$s$和$t$集合一定的意义，然后我去进行相应的连边。</p><p>考虑这样的一件事情，因为我们在求最小割的过程中实际上是求在$S$集合中的最小割，那么实际上也就是我们把一些东西放到了$S$集合上面。</p><p>那么之前我们说了边的方案如何选择，那么如何去进行选择点的方案呢？</p><p>那么我们可以去看$dis$数组里面的东西，因为$dis$刚开始都是$0$的，对于放在$S$集合里面的东西我们都应该选择$dis$不为$0$的点即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n,m,s,t;FlowGraph&lt;ll&gt; g;string str;const ll inf &#x3D; (1ll &lt;&lt; 60);int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; m &gt;&gt; n;s &#x3D; m + n + 1;t &#x3D; m + n + 2;g.init(s,t,t);ll ans &#x3D; 0;getline(cin,str);for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;getline(cin,str);stringstream ss;ss &lt;&lt; str;&#x2F;&#x2F; cout &lt;&lt; &quot;str -&gt; &quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;;int x;ss &gt;&gt; x;g.addedge(s,i,x);&#x2F;&#x2F;第i个实验的费用ans +&#x3D; x;while(!ss.eof())&#123;ss &gt;&gt; x;g.addedge(i,x + m,inf);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int x;cin &gt;&gt; x;g.addedge(i + m,t,x);&#125;ans -&#x3D; g.dinic();vector&lt;int&gt; p1,p2;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;if(g.dis[i] &gt; 0) p1.push_back(i);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(g.dis[i + m] &gt; 0) p2.push_back(i);&#125;for(auto to:p1) cout &lt;&lt; to &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\n&quot;;for(auto to:p2) cout &lt;&lt; to &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\n&quot;;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 20100;const int E &#x3D; 201000;template&lt;typename T&gt;struct MinCostGraph&#123;int s,t,vtot;int head[V],cur[V],etot;T dis[V],flow,cost;int pre[V];bool vis[V];struct edge&#123;int v,nxt;T f,c;&#125;e[E * 2];void addedge(int u,int v, T f, T c, T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v, head[u], f, c&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u, head[v], f2, -c&#125;; head[v] &#x3D; etot++;&#125;bool spfa()&#123;T inf &#x3D; numeric_limits&lt;T&gt;::max() &#x2F; 2;&#x2F;&#x2F;防止溢出for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i)&#123;dis[i] &#x3D; inf;vis[i] &#x3D; false;pre[i] &#x3D; -1; &#x2F;&#x2F;记录一下上一条边,方便增广&#125;dis[s] &#x3D; 0;vis[s] &#x3D; true;queue&lt;int&gt; q;q.push(s);while(!q.empty())&#123;auto u &#x3D; q.front();for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].nxt)&#123;int v &#x3D; e[i].v;if(e[i].f &amp;&amp; dis[v] &gt; dis[u] + e[i].c)&#123;dis[v] &#x3D; dis[u] + e[i].c;pre[v] &#x3D; i;if(!vis[v])&#123;vis[v] &#x3D; 1;q.push(v);&#125;&#125;&#125;q.pop();vis[u] &#x3D; false;&#125;return dis[t] !&#x3D; inf;&#125;&#x2F;&#x2F;增广void augment()&#123;int u &#x3D; t;T f &#x3D; numeric_limits&lt;T&gt;::max();while(~pre[u])&#123;f &#x3D; min(f, e[pre[u]].f);u &#x3D; e[pre[u] ^ 1].v;&#125;flow +&#x3D; f;cost +&#x3D; f * dis[t];u &#x3D; t;while(~pre[u])&#123;e[pre[u]].f -&#x3D; f;e[pre[u] ^ 1].f +&#x3D; f;u &#x3D; e[pre[u] ^ 1].v;&#125;&#125;pair&lt;T, T&gt; solve()&#123;flow &#x3D; 0;cost &#x3D; 0;while(spfa()) augment();return &#123;flow, cost&#125;;&#125;void init(int s_, int t_, int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i) head[i] &#x3D; -1;&#125;&#125;;MinCostGraph&lt;int&gt; g;int n,m,s,t;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;g.init(s,t,n);for(int i &#x3D; 1,u,v,f,c;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; f &gt;&gt; c;g.addedge(u,v,f,c);&#125;auto ans &#x3D; g.solve();cout &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大费用最大流"><a href="#最大费用最大流" class="headerlink" title="最大费用最大流"></a>最大费用最大流</h3><p>因为我们考虑这样子的一件事情，我们在求$MCMF$的时候实际上求的是最小的费用那么我们只需要建负边并且最终答案取反就可以了</p><h4 id="P4015"><a href="#P4015" class="headerlink" title="P4015"></a>P4015</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MinCostGraph&lt;ll&gt; g1,g2;int n,m,s,t;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;s &#x3D; n + m + 1;t &#x3D; n + m + 2;g1.init(s,t,t);g2.init(s,t,t);for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;g1.addedge(s,i,x,0);g2.addedge(s,i,x,0);&#125;for(int i &#x3D; 1,x;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; x;g1.addedge(i + n,t,x,0);g2.addedge(i + n,t,x,0);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;int x;cin &gt;&gt; x;g1.addedge(i,j + n,1 &lt;&lt; 30,x);g2.addedge(i,j + n,1 &lt;&lt; 30,-x);&#125;&#125;auto ans1 &#x3D; g1.solve();auto ans2 &#x3D; g2.solve();cout &lt;&lt; ans1.second &lt;&lt; &quot;\n&quot; &lt;&lt; -ans2.second &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化建图"><a href="#优化建图" class="headerlink" title="优化建图"></a>优化建图</h3><p><a href="https://codeforces.com/problemset/problem/1525/D">Problem - 1525D - Codeforces</a></p><p><strong>题意:</strong> 给定$n$个座位，每个座位刚开始有两个数字$1$和$0$，题目保证初始给定的$1$的数量少于$0$的数量，将一个$1$移动位置需要$abs(i - j)$的贡献，问让刚开始的$1$全部变成$0$最少需要多少贡献</p><p><strong>解题思路:</strong> 其实刚开始看到题目就想着是裸的费用流，将两种点分在两边，中间连接相对应的边权即可，但是后面发现这样子写的话会有问题。但是考虑反正$1$只会往相邻的$0$移动，那么就相邻的两边建边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 20100;const int E &#x3D; 521000;template&lt;typename T&gt;struct MinCostGraph&#123;int s,t,vtot;int head[V],cur[V],etot;T dis[V],flow,cost;int pre[V];bool vis[V];struct edge&#123;int v,nxt;T f,c;&#125;e[E * 2];void addedge(int u,int v, T f, T c, T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v, head[u], f, c&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u, head[v], f2, -c&#125;; head[v] &#x3D; etot++;&#125;bool spfa()&#123;T inf &#x3D; numeric_limits&lt;T&gt;::max() &#x2F; 2;&#x2F;&#x2F;防止溢出for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i)&#123;dis[i] &#x3D; inf;vis[i] &#x3D; false;pre[i] &#x3D; -1; &#x2F;&#x2F;记录一下上一条边,方便增广&#125;dis[s] &#x3D; 0;vis[s] &#x3D; true;queue&lt;int&gt; q;q.push(s);while(!q.empty())&#123;auto u &#x3D; q.front();for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].nxt)&#123;int v &#x3D; e[i].v;if(e[i].f &amp;&amp; dis[v] &gt; dis[u] + e[i].c)&#123;dis[v] &#x3D; dis[u] + e[i].c;pre[v] &#x3D; i;if(!vis[v])&#123;vis[v] &#x3D; 1;q.push(v);&#125;&#125;&#125;q.pop();vis[u] &#x3D; false;&#125;return dis[t] !&#x3D; inf;&#125;&#x2F;&#x2F;增广void augment()&#123;int u &#x3D; t;T f &#x3D; numeric_limits&lt;T&gt;::max();while(~pre[u])&#123;f &#x3D; min(f, e[pre[u]].f);u &#x3D; e[pre[u] ^ 1].v;&#125;flow +&#x3D; f;cost +&#x3D; f * dis[t];u &#x3D; t;while(~pre[u])&#123;e[pre[u]].f -&#x3D; f;e[pre[u] ^ 1].f +&#x3D; f;u &#x3D; e[pre[u] ^ 1].v;&#125;&#125;pair&lt;T, T&gt; solve()&#123;flow &#x3D; 0;cost &#x3D; 0;while(spfa()) augment();return &#123;flow, cost&#125;;&#125;void init(int s_, int t_, int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i) head[i] &#x3D; -1;&#125;&#125;;MinCostGraph&lt;int&gt; g;int n,m,s,t;int a[V];int main()&#123;cin &gt;&gt; n;s &#x3D; n + 1,t &#x3D; n + 2;g.init(s,t,t);vector&lt;int&gt; pos0,pos1;int ct &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];if(a[i])&#123;&#x2F;&#x2F; ct++;g.addedge(s,i,1,0);&#125;else&#123;g.addedge(i,t,1,0);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;g.addedge(i,i + 1,1 &lt;&lt; 30,1);g.addedge(i + 1,i,1 &lt;&lt; 30,1);&#125;auto [f,c] &#x3D; g.solve();cout &lt;&lt; c &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 建图 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
