<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Atcoder Beginner Contest 271 C-F</title>
      <link href="/2022/10/02/abc271/"/>
      <url>/2022/10/02/abc271/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-Beginner-Contest-271-C-F"><a href="#Atcoder-Beginner-Contest-271-C-F" class="headerlink" title="Atcoder Beginner Contest 271 C-F"></a>Atcoder Beginner Contest 271 C-F</h1><h2 id="C-Manga"><a href="#C-Manga" class="headerlink" title="C - Manga"></a>C - Manga</h2><p>**题意:**给定一个长度为$n(1 \leq n \leq 3e5)$的序列,每个位置有一个值$x(1 \leq x \leq 1e9)$，我们可以进行任意多次操作，操作的话是如果序列的长度还大于等于$2$，那么我们可以任意选择$2$个数字去删除，然后加进去任意一个数字进去，问我们最后能够得到一个形似$1,2,3…$的最长序列</p><p>**解题思路:**首先我们分析一下题意，我们可以知道最后的答案最多不会超过$n$，那么我们在读入的时候可以将大于$n$的部分放进一个$vector$里面，然后对于小于$n$的一部分我们可以先给他标记然后放到一个双端队列里面，如果其中的数字有重复的部分我们也需要放进上面的$vector$之中。接着我们模拟这个过程即可。在模拟的时候注意我们优先取$vector$当中的，然后我们取队列后面的即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 3e5 + 10;int vis[maxn],n;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;vector&lt;int&gt; a;for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;if(x &lt;&#x3D; n)&#123;if(vis[x]) a.push_back(x);else vis[x] &#x3D; 1;&#125;else a.push_back(x);&#125;deque&lt;int&gt; q;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(vis[i]) q.push_back(i);&#125;int ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(vis[i] &amp;&amp; q.size())&#123;ans++;q.pop_front();continue;&#125;if(a.size() &gt;&#x3D; 2)&#123;a.pop_back();a.pop_back();&#125;else if(a.size() &#x3D;&#x3D; 1)&#123;a.pop_back();if(!q.empty()) q.pop_back(); else break;&#125;else&#123;if(q.size() &gt;&#x3D; 2)&#123;q.pop_back();q.pop_back();&#125;else break;&#125;ans++;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Flip-and-Adjust"><a href="#D-Flip-and-Adjust" class="headerlink" title="D - Flip and Adjust"></a>D - Flip and Adjust</h2><p>**题意:**给定$n(1 \leq n \leq 100)$张卡片，每张卡片背面和正面有一个数字，现在让我们选择每张卡片的正面或者反面，问是否能够组成$s(1\leq s \leq 10000)$</p><p>**解题思路:**首先我们可以观察数据范围，可能是$O(n ^ 3)$或者$O(ns)$的$dp$</p><p>接下来我们考虑这样的一个过程，首先无论如何每张牌都是要取的，那么假定我现在取到第$i - 1$张牌的值有$s_{i - 1}$，那么我取第$i$张牌的时候的值肯定有$s_{i - 1} + mp[i][0]$和$s_{i - 1} + mp[i][1]$$(mp[i][0&#x2F;1]表示第i张牌的正反面的值)$</p><p>那么我们就可以用$dp[i][s]$来表示前$i$张牌可能组成的值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 2e2 + 10;int mp[maxn][2],n,s;int dp[maxn][40010];int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; s;dp[0][0] &#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; mp[i][0] &gt;&gt; mp[i][1];if(i &#x3D;&#x3D; 1)&#123;dp[1][mp[i][0]] &#x3D; 1;dp[1][mp[i][1]] &#x3D; 1;continue;&#125;for(int j &#x3D; 0;j &lt;&#x3D; s;++j)&#123;if(!dp[i - 1][j]) continue;if(j + mp[i][0] &lt;&#x3D; s) dp[i][j + mp[i][0]] &#x3D; 1;if(j + mp[i][1] &lt;&#x3D; s) dp[i][j + mp[i][1]] &#x3D; 1;&#125;&#125;if(dp[n][s])&#123;cout &lt;&lt; &quot;Yes\n&quot;;string ans &#x3D; &quot;&quot;;for(int i &#x3D; n;i &gt;&#x3D; 1;--i)&#123;if(s - mp[i][0] &gt;&#x3D; 0 &amp;&amp; dp[i - 1][s - mp[i][0]])&#123;s -&#x3D; mp[i][0];ans.push_back(&#39;H&#39;);&#125;else&#123;s -&#x3D; mp[i][1];ans.push_back(&#39;T&#39;);&#125;&#125;assert(ans.length() &#x3D;&#x3D; n);reverse(ans.begin(),ans.end());cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;else&#123;cout &lt;&lt; &quot;No\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Subsequence-Path"><a href="#E-Subsequence-Path" class="headerlink" title="E - Subsequence Path"></a>E - Subsequence Path</h2><p>**题目大意:**给定$n$个点$m$条单向边$(1 \leq n,m \leq 2e5)$，没有重边和自环，每个边有一条权值，接下来给定一个序列$E$，我们走的路径的标号形成的序列必须是这个序列$E$的子序列，问从点$1$到点$n$的最短路径</p><p>**解题思路:**分析题目发现我们的突破口应该在这个给定我们的序列$E$这里，因为考虑我们取到的序列是这个序列的子序列，这里给我们透露到一些信息，就是假设我们当前已经遍历到第$i$条边，那么我们是可以用前面$i - 1$条边来更新这一张图的，那么我们知道这个点之后就可以写啦</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longconst int maxn &#x3D; 2e5 + 10;const int inf &#x3D; 1e18;struct node&#123;int u,v,w;&#125;edge[maxn];int n,m,k;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;vector&lt;int&gt; dis(n + 1,inf);for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge[i] &#x3D; &#123;u,v,w&#125;;&#125;dis[1] &#x3D; 0;for(int i &#x3D; 1,x;i &lt;&#x3D; k;++i)&#123;cin &gt;&gt; x;int u &#x3D; edge[x].u;int v &#x3D; edge[x].v;int w &#x3D; edge[x].w;dis[v] &#x3D; min(dis[v],dis[u] + w);&#125;if(dis[n] !&#x3D; inf) cout &lt;&lt; dis[n] &lt;&lt; &quot;\n&quot;;else cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="F-XOR-on-Grid-Path"><a href="#F-XOR-on-Grid-Path" class="headerlink" title="F - XOR on Grid Path"></a>F - XOR on Grid Path</h2><p>**题目大意:**给定一个$n * n(1\leq n \leq 20)$的矩阵，我们从点$(1,1)$开始，每次移动可以向$(x + 1,y)$或者$(x,y + 1)$移动，问我们到达$(n,n)$使得异或和为$0$的路径有多少条</p><p>**解题思路:**首先对于这种矩阵的题目我们肯定先去考虑$dp$的，但是如果暴力去枚举所有方案的话方案数实际会非常的大</p><p>根据官方题解的思路，建议我们使用$meet$  $in$ $middle$来做</p><p>那$meet$  $in$ $middle$是个什么东西呢？大概就是我从两个点来搜索，搜索到一些具有共同性质的点从而结束，因为这样子会大大减少我们所需要的时间复杂度</p><p>那么对于矩阵来说，我们可以从$(1,1)$点和$(n,n)$点来搜索，对于这两个点来说我们都搜索到对角线上面的点来结束,因为对角线刚好分割两个矩阵</p><p>那么我们对于$(1,1)$点来说，我们可以直接搜索下去到对角线来记录当前异或和的数值，那么对于$(n,n)$点来说，我们可以往上面搜索，搜到对角线的话就加上之前前面遍历到这一点的值，因为我们需要异或和是$0$嘛</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longint mp[30][30],n;unordered_map&lt;int,int&gt; dp[30][30];int ans;void dfs1(int x,int y,int now)&#123;if(x + y &#x3D;&#x3D; n)&#123;dp[x][y][now]++;return;&#125;if(x + y &gt; n) return;dfs1(x + 1,y,now ^ mp[x + 1][y]);dfs1(x,y + 1,now ^ mp[x][y + 1]);&#125;void dfs2(int x,int y,int now)&#123;if(x + y &#x3D;&#x3D; n)&#123;ans +&#x3D; dp[x][y][now ^ mp[x][y]];return;&#125;if(x + y &lt; n) return;dfs2(x - 1,y,now ^ mp[x - 1][y]);dfs2(x,y - 1,now ^ mp[x][y - 1]);&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j) cin &gt;&gt; mp[i][j];&#125;dfs1(1,1,mp[1][1]);dfs2(n,n,mp[n][n]);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Graph Traing</title>
      <link href="/2022/09/29/Graph-Traing/"/>
      <url>/2022/09/29/Graph-Traing/</url>
      
        <content type="html"><![CDATA[<h1 id="Graph-Traing"><a href="#Graph-Traing" class="headerlink" title="Graph Traing"></a>Graph Traing</h1><h2 id="Boboniu-Walks-on-Graph"><a href="#Boboniu-Walks-on-Graph" class="headerlink" title="Boboniu Walks on Graph"></a>Boboniu Walks on Graph</h2><p><a href="https://codeforces.com/problemset/problem/1394/B">https://codeforces.com/problemset/problem/1394/B</a></p><p><strong>题目大意:</strong> 给定一张图有$n$个点$m$条边，每条边的权值从$1$ ~ $m$并且每条边的权值互相不相同，这张图中一个点的最大的出度是$k$,然后求$k$元组，这个$k$元组的第$i$个位置代表着出度数为$i$的点走他的边权从小到大为第$c_i$的边，问多元组最多有多少种</p><p>**解题思路:**首先我们可以发现这样子一件事情，因为$k$的范围并不大，因此如果我们暴力去枚举多元组的样子最多也只有$9!$种，那么我们是否可以有一种很快速的$check$方法来检查一种多元组是否合法呢？首先我们可以想这样一件事情，因为对于每一个点最后都能跳回到自己，所以最后的结果必定是一个环，那么对于一个环来说我们可以粗略的将其看成一个集合，然后我们给每个点刚开始随机一个数值。然后我们分析多元组的性质，对于任意一种多元组，第$i$位的跳跃到第$c_i$个，那么我们可以刚开始预处理这个东西，对于当前点的出度和当前去往点的序号记录一个数组然后加起来就可以了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn &#x3D; 1e6 + 10;int n,m,k;int sum[15][15];int a[maxn],ansha,ans;int res;vector&lt;pair&lt;int,int&gt;&gt; edge[maxn];void dfs(int now)&#123;if(now &#x3D;&#x3D; k + 1)&#123;if(res &#x3D;&#x3D; ansha) ans++;return;&#125;for(int i &#x3D; 1;i &lt;&#x3D; now;++i)&#123;res +&#x3D; sum[now][i];dfs(now + 1);res -&#x3D; sum[now][i];&#125;return;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);srand(time(NULL));cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) a[i] &#x3D; rand() * rand(),ansha +&#x3D; a[i];for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge[u].push_back(&#123;w,v&#125;);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) sort(edge[i].begin(),edge[i].end());for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int sz &#x3D; edge[i].size();for(int j &#x3D; 0;j &lt; sz;++j)&#123;auto to &#x3D; edge[i][j].second;sum[sz][j + 1] +&#x3D; a[to];&#125;&#125;dfs(1);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Slipper"><a href="#Slipper" class="headerlink" title="Slipper"></a>Slipper</h2><p>(<a href="https://vjudge.net/contest/517945#problem/C">https://vjudge.net/contest/517945#problem/C</a>)</p><p>**题目大意:**给定一棵树，结点个数为$n (1 \leq n \leq 1e5)$,给定每条树边连接的两个结点和对应的边权，除此之外可以进行若干次魔法，若$|dep_u - dep_v| &#x3D; k$，那么从$u$到$v$只需要$d$点边权，给定两个点$s$和$t$，求从$s$到$t$最少需要多少边权</p><p>**解题思路:**我们可以刚开始这么思考，如果不考虑任何优化，我们可以将每个点放到对应的一个存储容器中，这个容易用$dep$ 来标记，如果两个容器相差$k$，那么我们对于两个集合中的点进行一一连边即可。但是这样子实际的时间复杂度很大，那么我们考虑优化建边。根据上面的思考，我们可以发现一个性质只有层与层之间才会连接一条边，其实很多边是重复的，那么我们对于每一个层来说我们可以建一个点，表示层，那么我们对于每一个点来说，连向这个层，那么对于层与层之间的，我们可以从$u$往$u + k$建一条边，同时也可以从$u + k$往$u$建边，但是只有一层层点是不够的，因为原来的树点连过来的边权是$0$，那么我们再建一层层点来跑最短路即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F; #define int long longtypedef long long ll;const int maxn &#x3D; 6e6 + 10;const int maxm &#x3D; 1e6 + 10;const ll inf &#x3D; 1e18;int tot;struct node&#123;    int u,v,w,nxt;&#125;edge[maxn &lt;&lt; 1];int head[maxn];inline void add(int u,int v,int w)&#123;    edge[++tot].u &#x3D; u,edge[tot].v &#x3D; v,edge[tot].w &#x3D; w,edge[tot].nxt &#x3D; head[u],head[u] &#x3D; tot;&#125;int n,dep[maxm],k,p,s,t,mxdep;void dfs(int s,int fa)&#123;    dep[s] &#x3D; dep[fa] + 1;    mxdep &#x3D; max(mxdep, dep[s]);    for(int i &#x3D; head[s];i;i &#x3D; edge[i].nxt)    &#123;        int to &#x3D; edge[i].v;        if(to &#x3D;&#x3D; fa) continue;        dfs(to,s);    &#125;&#125;void dij()&#123;    vector&lt;int&gt; vis(3 * n + 10, 0);    vector&lt;ll&gt; dis(3 * n + 10, inf);    dis[s] &#x3D; 0;    priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt;&gt;, greater&lt;pair&lt;ll, int&gt;&gt;&gt; que;    que.push(&#123;0, s&#125;);    while(!que.empty())    &#123;        auto now &#x3D; que.top().second;        que.pop();        if(vis[now])            continue;        vis[now] &#x3D; 1;        for(int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)        &#123;            int to &#x3D; edge[i].v;            ll ww &#x3D; edge[i].w * 1ll;            if(dis[to] &gt; dis[now] + ww)            &#123;                dis[to] &#x3D; dis[now] + ww;                que.push(&#123;dis[to], to&#125;);            &#125;        &#125;    &#125;    printf(&quot;%lld\n&quot;,dis[t]);&#125;void solve()&#123;    tot &#x3D; 0;    scanf(&quot;%d&quot;,&amp;n);    &#x2F;&#x2F; cin &gt;&gt; n;    mxdep &#x3D; 0;    for(int i &#x3D; 1;i &lt;&#x3D; n + n + n + 10;++i) head[i] &#x3D; 0;    for (int i &#x3D; 1, u, v, w; i &lt;&#x3D; n - 1;++i)    &#123;        scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);        &#x2F;&#x2F; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        add(u,v,w);        add(v,u,w);    &#125;    dfs(1, 0);    scanf(&quot;%d %d&quot;,&amp;k,&amp;p);    scanf(&quot;%d %d&quot;,&amp;s,&amp;t);    for (int i &#x3D; 1; i &lt;&#x3D; n;++i)    &#123;        add(i,dep[i] + n,0);        add(dep[i] + n + n,i,0);    &#125;    for (int l &#x3D; 1; l &lt;&#x3D; n;++l)    &#123;        int r &#x3D; l + k;        if(r &gt; mxdep)            break;        add(l + n,r + n + n,p);        add(r + n + n,l + n,p);    &#125;    dij();&#125;signed main()&#123;    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);    int T;    scanf(&quot;%d&quot;, &amp;T);    &#x2F;&#x2F; cin &gt;&gt; T;    while(T--)    &#123;        solve();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flow</title>
      <link href="/2022/09/29/Flow/"/>
      <url>/2022/09/29/Flow/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>网络流时间复杂度大约为$O(n^2m)$</p><p>不过也比较玄学罢了</p><p>将一张图建完之后直接跑$dinic$即可</p><p>接下来有封装之后的版本</p><p>注意这个封装版本的最大流应该有以下的特征：</p><ul><li><p>首先最大流这个点我们是从$1$开始的，因此我们在设置对应的起点和终点的时候，应该注意设置</p></li><li><p>其次是边的标号，因为是从$0$开始的</p></li><li><p>所以我们每次开始的边其实都是$etot$</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 1210;const int E &#x3D; 121000;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;        etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,m,s,t;FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;g.init(s,t,n);for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;g.addedge(u,v,w);&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方案分配"><a href="#方案分配" class="headerlink" title="方案分配"></a>方案分配</h3><p>方案分配实际上我们可以思考他的<strong>流量</strong>和之前的关系，然后我们判断这个<strong>流量</strong>来输出方案</p><p>题目条件可以是类似于这样子的，给定一些试题类型，其中再给定一些试题，我每个试题是属于不同的试题类型的，求是否可以分配，并且输出方案</p><p>那么其实我们对应的解决方案是把相对应的东西放到一个$vector$中，然后去判断对应的边的流量即可</p><h4 id="P2763"><a href="#P2763" class="headerlink" title="P2763"></a>P2763</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 1210;const int E &#x3D; 121000;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;        etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,k,s,t;FlowGraph&lt;ll&gt; g;struct node&#123;int st,num,id;&#125;;vector&lt;int&gt; prob[100];int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; k &gt;&gt; n;s &#x3D; n + k + 1;t &#x3D; n + k + 2;g.init(s,t,t + 10);int sum &#x3D; 0;for(int i &#x3D; 1,x;i &lt;&#x3D; k;++i)&#123;&#x2F;&#x2F;1 -&gt; typecin &gt;&gt; x;sum +&#x3D; x;g.addedge(s,i,x);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;sum -&gt; &quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;vector&lt;node&gt; used;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;&#x2F;&#x2F;type + 1 -&gt; type + nint num;cin &gt;&gt; num;for(int j &#x3D; 1,bel;j &lt;&#x3D; num;++j)&#123;cin &gt;&gt; bel;used.push_back(&#123;bel,i,g.etot&#125;);g.addedge(bel,k + i,1);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;g.addedge(k + i,t,1);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;??\n&quot;;ll namomo &#x3D; g.dinic();if(namomo !&#x3D; sum)&#123;cout &lt;&lt; &quot;\n&quot;;&#125;else&#123;for(auto now:used)&#123;int idd &#x3D; now.id;if(g.e[idd].f &#x3D;&#x3D; 0)&#123;prob[now.st].push_back(now.num);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;cout &lt;&lt; i &lt;&lt; &quot;:&quot;;for(auto to:prob[i])&#123;cout &lt;&lt; &quot; &quot; &lt;&lt; to;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;&#125;return 0;&#125;&#x2F;*属于是最大流的方案分配问题，首先显而易见我们可以通过这一条边的流量去判断这个边是否被用过来判断是否属于这一个方案当中那么我们可以这样子，因为我们是把试题库和相对应的试题连接在一起ok，那么这样子我们在建边的时候我们可以把相对应的边的号给放到一个vector里面然后后续我们去检查这个边的流量是否为1即可*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="路径模型"><a href="#路径模型" class="headerlink" title="路径模型"></a>路径模型</h3><p>比如说一个序列，如果可以从$a_i$ 到$a_j$有一条路径，实际上我们也可以映射到一张图上面去考虑，因为我们在做最大流的过程中实际上就是在走一些流的路径</p><p>然后对于一些<strong>流量限制</strong>的情况下我们可以采用<strong>拆点</strong>的方法去限制流量</p><h4 id="P2776"><a href="#P2776" class="headerlink" title="P2776"></a>P2776</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 101210;const int E &#x3D; 1210000;const int maxn &#x3D; 5e2 + 10;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,m,s,t;int a[maxn],dp[maxn];FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];dp[i] &#x3D; 1;&#125;int ans &#x3D; 1;for(int i &#x3D; 2;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt; i;++j)&#123;if(a[i] &gt;&#x3D; a[j])&#123;dp[i] &#x3D; max(dp[i],dp[j] + 1);&#125;&#125;ans &#x3D; max(ans,dp[i]);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;s &#x3D; 2 * n + 1;t &#x3D; 2 * n + 2;g.init(s,t,t);for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(dp[i] &#x3D;&#x3D; 1) g.addedge(s,i,n);&#x2F;&#x2F;添加流量为inf的边if(dp[i] &#x3D;&#x3D; ans) g.addedge(i + n,t,n);g.addedge(i,i + n,1);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(a[j] &gt;&#x3D; a[i] &amp;&amp; dp[j] &#x3D;&#x3D; dp[i] + 1)&#123;g.addedge(i + n,j,1);&#125;&#125;&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;g.init(s,t,t);for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(dp[i] &#x3D;&#x3D; 1) g.addedge(s,i,n);&#x2F;&#x2F;添加流量为inf的边if(dp[i] &#x3D;&#x3D; ans) g.addedge(i + n,t,n);if(ans &#x3D;&#x3D; 1) g.addedge(i,i + n,1);else g.addedge(i,i + n,n);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(a[j] &gt;&#x3D; a[i] &amp;&amp; dp[j] &#x3D;&#x3D; dp[i] + 1)&#123;g.addedge(i + n,j,1);&#125;&#125;&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;&#125;&#x2F;*题目大意：给定一个序列，需要解决如下的三个问题1.求这个序列的最长非递减子序列2.每个元素只能使用一次的情况下序列的最长非递减子序列3.每个元素使用多次的情况下序列的最长非递减子序列建图思路:首先对于第一个问题来说我们直接dp即可对于第二个问题，我们需要思考以下我们的建图方向因为只需要求方案数目，那么我们可以进行这样子的建图，我们可以从s-&gt;dp &#x3D; 1的值建一条边我们也可以从dp &#x3D; ans -&gt; t建一条边因为在第一种情况我们只考虑每一个点使用一个那么我们可以使用拆点拆点是为了加一个限制只能流一个1然后因为我们要找第j个数字可能从哪个第i个数字转移过来 那么我们继续找重新建边即可对于第三个问题 实际上我一个点可以使用多次了那么我们先特判考虑最后答案是1的情况 其实实际上下面两个问题的答案就是n然后我们再考虑一个可以使用多次 那么我们拆店的时候对于多个点建n就可以了*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><p>**概念:**给定一张图，删除一些边使得$s$和$t$不连通</p><p>那么其实就是对于每一个点，我去将点划分为两个集合，每一个点要么属于$s$集合，要么属于$t$集合</p><p>那么对于这里割边来说，实际上就是找一条边，对于他的两个端点$u$和$v$，两个点分别属于一个集合</p><p>最小割 $\geq$ 最大流</p><p>接下来我们分析一下建边的过程</p><p>对于无向图建立割边，实际上我们不仅要考虑正向边，我们也要考虑反向边，那么对于无向图的建图方式实际上就是建两条相同边权的边</p><p>具体的建边方式如下图所示可以</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void addedge(int u,int v,T f,T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],f2&#125;; head[v] &#x3D; etot++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么有向图的话实际上还是和之前的类似，我去建一条长度为$c$的边，另外一条是长度为$0$的边</p><p>如何在实际题目中去思考到<strong>最小割</strong>这个东西呢？</p><h3 id="最大权独立集"><a href="#最大权独立集" class="headerlink" title="最大权独立集"></a>最大权独立集</h3><p>首先我们可以考虑引入这样子的一个问题</p><p>假设我们有两个集合(假设为一个黑子集合和一个白子集合)，每个集合都有$n$个点，每个点都有一个点权，如果我们取了一些黑子那么我们就不能取白子，要求我们最后取得的权值<strong>最大</strong>，对于这一个问题我们如何解答呢？</p><p>我们可以考虑这样子的一个解题方向，我们最后的集合一定是分为两个集合，一个集合是取到的棋子，另外一个集合是没有取到的集合。</p><p>那么分为两个集合的操作是不是就是一个求最小割的过程呢？我们只需要把两个集合分别和$S$和$T$集合连边就可以，然后接下来相对应连边的权值就是他们的点权，然后点之间的限制因为无法切割我们可以采用$inf$</p><p>那么其实对应的如果是二维棋盘我们也可以通过这样子的操作</p><h4 id="P2774"><a href="#P2774" class="headerlink" title="P2774"></a>P2774</h4><p>方格取数，每个方格有一定权值，可以取若干个方格，方格之间不能有相互重叠的边</p><p>本质上也就是求一个最大权独立集的问题，行列相对应建边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const ll inf &#x3D; (1ll &lt;&lt; 60);int n,m,s,t,x;FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;s &#x3D; n * m + 1;t &#x3D; n * m + 2;g.init(s,t,t);ll ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;cin &gt;&gt; x;ans +&#x3D; x;int id &#x3D; (i - 1) * m + j;if((i + j) % 2 &#x3D;&#x3D; 1) &#123;g.addedge(s,id,x);if(i - 1 &gt;&#x3D; 1) g.addedge(id,id - m,inf);if(i + 1 &lt;&#x3D; n) g.addedge(id,id + m,inf);if(j + 1 &lt;&#x3D; m) g.addedge(id,id + 1,inf);if(j - 1 &gt;&#x3D; 1) g.addedge(id,id - 1,inf);&#125;else g.addedge(id,t,x);&#125;&#125;cout &lt;&lt; ans - g.dinic() &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h3><p>最大权闭合子图的定义实际上就是我每个点有一定的点权，选定一些点需要使得点权和最大，然后如果我选了一个点我是必须需要选定其他后继点的，然后我们来求这张图最多获得多少的点权</p><p>其实这个也是最小割的一种模型，那么实际上和最大权独立集的本质是一样的，我给$s$和$t$集合一定的意义，然后我去进行相应的连边。</p><p>考虑这样的一件事情，因为我们在求最小割的过程中实际上是求在$S$集合中的最小割，那么实际上也就是我们把一些东西放到了$S$集合上面。</p><p>那么之前我们说了边的方案如何选择，那么如何去进行选择点的方案呢？</p><p>那么我们可以去看$dis$数组里面的东西，因为$dis$刚开始都是$0$的，对于放在$S$集合里面的东西我们都应该选择$dis$不为$0$的点即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n,m,s,t;FlowGraph&lt;ll&gt; g;string str;const ll inf &#x3D; (1ll &lt;&lt; 60);int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; m &gt;&gt; n;s &#x3D; m + n + 1;t &#x3D; m + n + 2;g.init(s,t,t);ll ans &#x3D; 0;getline(cin,str);for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;getline(cin,str);stringstream ss;ss &lt;&lt; str;&#x2F;&#x2F; cout &lt;&lt; &quot;str -&gt; &quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;;int x;ss &gt;&gt; x;g.addedge(s,i,x);&#x2F;&#x2F;第i个实验的费用ans +&#x3D; x;while(!ss.eof())&#123;ss &gt;&gt; x;g.addedge(i,x + m,inf);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int x;cin &gt;&gt; x;g.addedge(i + m,t,x);&#125;ans -&#x3D; g.dinic();vector&lt;int&gt; p1,p2;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;if(g.dis[i] &gt; 0) p1.push_back(i);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(g.dis[i + m] &gt; 0) p2.push_back(i);&#125;for(auto to:p1) cout &lt;&lt; to &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\n&quot;;for(auto to:p2) cout &lt;&lt; to &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\n&quot;;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 20100;const int E &#x3D; 201000;template&lt;typename T&gt;struct MinCostGraph&#123;int s,t,vtot;int head[V],cur[V],etot;T dis[V],flow,cost;int pre[V];bool vis[V];struct edge&#123;int v,nxt;T f,c;&#125;e[E * 2];void addedge(int u,int v, T f, T c, T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v, head[u], f, c&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u, head[v], f2, -c&#125;; head[v] &#x3D; etot++;&#125;bool spfa()&#123;T inf &#x3D; numeric_limits&lt;T&gt;::max() &#x2F; 2;&#x2F;&#x2F;防止溢出for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i)&#123;dis[i] &#x3D; inf;vis[i] &#x3D; false;pre[i] &#x3D; -1; &#x2F;&#x2F;记录一下上一条边,方便增广&#125;dis[s] &#x3D; 0;vis[s] &#x3D; true;queue&lt;int&gt; q;q.push(s);while(!q.empty())&#123;auto u &#x3D; q.front();for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].nxt)&#123;int v &#x3D; e[i].v;if(e[i].f &amp;&amp; dis[v] &gt; dis[u] + e[i].c)&#123;dis[v] &#x3D; dis[u] + e[i].c;pre[v] &#x3D; i;if(!vis[v])&#123;vis[v] &#x3D; 1;q.push(v);&#125;&#125;&#125;q.pop();vis[u] &#x3D; false;&#125;return dis[t] !&#x3D; inf;&#125;&#x2F;&#x2F;增广void augment()&#123;int u &#x3D; t;T f &#x3D; numeric_limits&lt;T&gt;::max();while(~pre[u])&#123;f &#x3D; min(f, e[pre[u]].f);u &#x3D; e[pre[u] ^ 1].v;&#125;flow +&#x3D; f;cost +&#x3D; f * dis[t];u &#x3D; t;while(~pre[u])&#123;e[pre[u]].f -&#x3D; f;e[pre[u] ^ 1].f +&#x3D; f;u &#x3D; e[pre[u] ^ 1].v;&#125;&#125;pair&lt;T, T&gt; solve()&#123;flow &#x3D; 0;cost &#x3D; 0;while(spfa()) augment();return &#123;flow, cost&#125;;&#125;void init(int s_, int t_, int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i) head[i] &#x3D; -1;&#125;&#125;;MinCostGraph&lt;int&gt; g;int n,m,s,t;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;g.init(s,t,n);for(int i &#x3D; 1,u,v,f,c;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; f &gt;&gt; c;g.addedge(u,v,f,c);&#125;auto ans &#x3D; g.solve();cout &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大费用最大流"><a href="#最大费用最大流" class="headerlink" title="最大费用最大流"></a>最大费用最大流</h3><p>因为我们考虑这样子的一件事情，我们在求$MCMF$的时候实际上求的是最小的费用那么我们只需要建负边并且最终答案取反就可以了</p><h4 id="P4015"><a href="#P4015" class="headerlink" title="P4015"></a>P4015</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MinCostGraph&lt;ll&gt; g1,g2;int n,m,s,t;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;s &#x3D; n + m + 1;t &#x3D; n + m + 2;g1.init(s,t,t);g2.init(s,t,t);for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;g1.addedge(s,i,x,0);g2.addedge(s,i,x,0);&#125;for(int i &#x3D; 1,x;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; x;g1.addedge(i + n,t,x,0);g2.addedge(i + n,t,x,0);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;int x;cin &gt;&gt; x;g1.addedge(i,j + n,1 &lt;&lt; 30,x);g2.addedge(i,j + n,1 &lt;&lt; 30,-x);&#125;&#125;auto ans1 &#x3D; g1.solve();auto ans2 &#x3D; g2.solve();cout &lt;&lt; ans1.second &lt;&lt; &quot;\n&quot; &lt;&lt; -ans2.second &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化建图"><a href="#优化建图" class="headerlink" title="优化建图"></a>优化建图</h3><p><a href="https://codeforces.com/problemset/problem/1525/D">Problem - 1525D - Codeforces</a></p><p>**题意:**给定$n$个座位，每个座位刚开始有两个数字$1$和$0$，题目保证初始给定的$1$的数量少于$0$的数量，将一个$1$移动位置需要$abs(i - j)$的贡献，问让刚开始的$1$全部变成$0$最少需要多少贡献</p><p>**解题思路:**其实刚开始看到题目就想着是裸的费用流，将两种点分在两边，中间连接相对应的边权即可，但是后面发现这样子写的话会有问题。但是考虑反正$1$只会往相邻的$0$移动，那么就相邻的两边建边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 20100;const int E &#x3D; 521000;template&lt;typename T&gt;struct MinCostGraph&#123;int s,t,vtot;int head[V],cur[V],etot;T dis[V],flow,cost;int pre[V];bool vis[V];struct edge&#123;int v,nxt;T f,c;&#125;e[E * 2];void addedge(int u,int v, T f, T c, T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v, head[u], f, c&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u, head[v], f2, -c&#125;; head[v] &#x3D; etot++;&#125;bool spfa()&#123;T inf &#x3D; numeric_limits&lt;T&gt;::max() &#x2F; 2;&#x2F;&#x2F;防止溢出for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i)&#123;dis[i] &#x3D; inf;vis[i] &#x3D; false;pre[i] &#x3D; -1; &#x2F;&#x2F;记录一下上一条边,方便增广&#125;dis[s] &#x3D; 0;vis[s] &#x3D; true;queue&lt;int&gt; q;q.push(s);while(!q.empty())&#123;auto u &#x3D; q.front();for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].nxt)&#123;int v &#x3D; e[i].v;if(e[i].f &amp;&amp; dis[v] &gt; dis[u] + e[i].c)&#123;dis[v] &#x3D; dis[u] + e[i].c;pre[v] &#x3D; i;if(!vis[v])&#123;vis[v] &#x3D; 1;q.push(v);&#125;&#125;&#125;q.pop();vis[u] &#x3D; false;&#125;return dis[t] !&#x3D; inf;&#125;&#x2F;&#x2F;增广void augment()&#123;int u &#x3D; t;T f &#x3D; numeric_limits&lt;T&gt;::max();while(~pre[u])&#123;f &#x3D; min(f, e[pre[u]].f);u &#x3D; e[pre[u] ^ 1].v;&#125;flow +&#x3D; f;cost +&#x3D; f * dis[t];u &#x3D; t;while(~pre[u])&#123;e[pre[u]].f -&#x3D; f;e[pre[u] ^ 1].f +&#x3D; f;u &#x3D; e[pre[u] ^ 1].v;&#125;&#125;pair&lt;T, T&gt; solve()&#123;flow &#x3D; 0;cost &#x3D; 0;while(spfa()) augment();return &#123;flow, cost&#125;;&#125;void init(int s_, int t_, int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i) head[i] &#x3D; -1;&#125;&#125;;MinCostGraph&lt;int&gt; g;int n,m,s,t;int a[V];int main()&#123;cin &gt;&gt; n;s &#x3D; n + 1,t &#x3D; n + 2;g.init(s,t,t);vector&lt;int&gt; pos0,pos1;int ct &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];if(a[i])&#123;&#x2F;&#x2F; ct++;g.addedge(s,i,1,0);&#125;else&#123;g.addedge(i,t,1,0);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;g.addedge(i,i + 1,1 &lt;&lt; 30,1);g.addedge(i + 1,i,1 &lt;&lt; 30,1);&#125;auto [f,c] &#x3D; g.solve();cout &lt;&lt; c &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/28/hello-world/"/>
      <url>/2022/09/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
