<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并查集&amp;最小生成树部分题解及代码</title>
      <link href="/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81/"/>
      <url>/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集-amp-最小生成树题解"><a href="#并查集-amp-最小生成树题解" class="headerlink" title="并查集&amp;最小生成树题解"></a>并查集&amp;最小生成树题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p><strong>解题思路:</strong> 计算几个连通块，并查集一下即可</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p><strong>解题思路:</strong> 计算这片连通森林还需要几条边变成一个连通块，那么需要数量就是连通块数量减去$1$</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p><strong>解题思路:</strong> 最小生成树模板题</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p><strong>解题思路:</strong> $MST$模板题，先加上已经选择的边，再加上没有选择的边即可</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p><strong>解题思路:</strong> 判断是否只有一个$MST$，那么我们可以先找到一棵$MST$，记录这一棵$MST$的边，然后我们暴力去枚举去掉这条边之后是否还存在一棵和之前权值一样的$MST$</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <cstdio>#include <cmath>#include <iostream>#include <algorithm>using namespace std;const int maxn = 1e5 + 10;struct node&#123;    int x,y,r;&#125;a[maxn];int flag[maxn],n,m;struct DSU&#123;    int f[maxn],num;    int getf(int x)    &#123;        return x == f[x] ? x : f[x] = getf(f[x]);    &#125;    int merge(int x,int y)    &#123;        int fx = getf(x);        int fy = getf(y);        f[fx] = fy;        if(fx != fy)        &#123;            num++;            return 1;        &#125;        else return 0;    &#125;    void init()    &#123;        for(int i = 1;i <= n;++i) f[i] = i;        num = 0;    &#125;&#125;dsu;struct kruskal&#123;    DSU now;    int nowres;    void init()    &#123;        now.init();        nowres = 0;    &#125;&#125;kru;int cmp(node A,node B)&#123;    return A.r < B.r;&#125;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n >> m;        dsu.init();        for(int i = 1;i <= m;++i)        &#123;            cin >> a[i].x >> a[i].y >> a[i].r;            flag[i] = 0;        &#125;        sort(a + 1,a + 1 + m,cmp);        int ans = 0;        for(int i = 1;i <= m;++i)        &#123;            if(dsu.merge(a[i].x,a[i].y))            &#123;                ans += a[i].r;                flag[i] = 1;            &#125;        &#125;        int f = 1;        for(int i = 1;i <= m;++i)        &#123;            if(!flag[i]) continue;            kru.init();            for(int j = 1;j <= m;++j)            &#123;                if(j == i) continue;                if(kru.now.merge(a[j].x,a[j].y))                &#123;                    kru.nowres += a[j].r;                &#125;            &#125;            if(kru.nowres == ans && kru.now.num == n - 1) f = 0;        &#125;        if(f) cout << ans << "\n";        else cout << "Not Unique!\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p><strong>解题思路:</strong> 首先先把免费的边连接起来，然后对$n$个点建立点对，排序之后求最小生成树，直接用$Kruskal$记录边即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <cstdio>#include <cmath>#include <iostream>#include <algorithm>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longconst int maxn = 1e6 + 10;int p[maxn][2],tot,n,m;struct node&#123;    int x,y;    double r;    node()&#123;&#125;;    node(int _x,int _y,double _r): x(_x),y(_y),r(_r)&#123;&#125;&#125;a[maxn];struct DSU&#123;    int f[maxn];    int getf(int x)    &#123;        return x == f[x] ? x : f[x] = getf(f[x]);    &#125;    void merge(int x,int y,int op)    &#123;        int fx = getf(x);        int fy = getf(y);        if(fx != fy)        &#123;            f[fx] = fy;            if(op) cout << x << " " << y << "\n";        &#125;    &#125;    void init()    &#123;        for(int i = 1;i <= n;++i) f[i] = i;    &#125;&#125;dsu;int pow2(int x)&#123;    return x * x;&#125;double cal(int i,int j)&#123;    return sqrt(1.0 * pow2(p[i][0] - p[j][0]) + 1.0 * pow2(p[i][1] - p[j][1]));&#125;int cmp(node A,node B)&#123;    return A.r < B.r;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    for(int i = 1;i <= n;++i)    &#123;        cin >> p[i][0] >> p[i][1];    &#125;    cin >> m;    dsu.init();    for(int i = 1,u,v;i <= m;++i)    &#123;        cin >> u >> v;        dsu.merge(u,v,0);    &#125;    for(int i = 1;i <= n;++i)    &#123;        for(int j = i + 1;j <= n;++j)        &#123;            double dis = cal(i,j);            a[++tot] = node(i,j,dis);        &#125;    &#125;    sort(a + 1,a + 1 + tot,cmp);    for(int i = 1;i <= tot;++i)    &#123;        dsu.merge(a[i].x,a[i].y,1);    &#125;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p><strong>解题思路:</strong> 和上课讲的基本类似，同时需要注意的是这里存在位置固定的问题，如果位置固定的话那么对于他所存在的连通块只会带来$1$的贡献</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <cstdio>#include <cmath>#include <iostream>#include <algorithm>using namespace std;#define int long longconst int maxn = 5e5 + 10;const int mod = 1e9 + 7;int a[maxn],b[maxn],c[maxn],n;struct DSU&#123;    int f[maxn],sz[maxn];    int getf(int x)    &#123;        return x == f[x] ? x : f[x] = getf(f[x]);    &#125;    void merge(int x,int y)    &#123;        int fx = getf(x);        int fy = getf(y);        if(fx != fy)        &#123;            f[fy] = fx;            sz[fx] += sz[fy];        &#125;    &#125;    void init()    &#123;        for(int i = 1;i <= n;++i) f[i] = i,sz[i] = 1;    &#125;&#125;dsu;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        for(int i = 1;i <= n;++i) cin >> a[i];        for(int i = 1;i <= n;++i) cin >> b[i];        for(int i = 1;i <= n;++i) cin >> c[i];        dsu.init();        for(int i = 1;i <= n;++i)        &#123;            dsu.merge(a[i],b[i]);        &#125;        for(int i = 1;i <= n;++i)        &#123;            if(c[i])            &#123;                dsu.sz[dsu.getf(c[i])] = 0;            &#125;        &#125;        int ans = 1;        for(int i = 1;i <= n;++i)        &#123;            if(dsu.f[i] == i)            &#123;                if(dsu.sz[i] >= 2) ans = ans * 2 % mod;            &#125;        &#125;        cout << ans << "\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p><strong>解题思路:</strong> 种族并查集，首先我们先思考如何解决多个种族之间的事情，首先我们先考虑$A$这个位置，因为它可以吃$B$,但是被$C$吃，因此在这里的关系存在的是三种：自己(同族)，食物，敌人。所以我们再开空间的时候可以开$3$倍的空间。</p><p>然后我们考虑这样一件事情，假设$a$可以吃$b,c$，那么$b,c$实际上是同族；同理如果$b,c$可以吃$a$，那么$b,c$也是同族。那么也就是说 <strong>敌人的敌人是朋友</strong></p><p>那么接下来考虑什么时候不合法，首先是在$x$和$y$合并的时候，如果$x$是$y$的敌人或者$y$是$x$的敌人就不行</p><p>然后考虑$x$可以吃$y$的情况下，首先是题目告诉如果相同就不行，然后是如果$x$是$y$的同族或者$y$可以吃$x$不行</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <cstdio>#include <cmath>#include <iostream>#include <algorithm>using namespace std;const int maxn = 1e5 + 10;// const int inf = 1e18;int f[maxn * 3],n,m,ans;int getf(int x)&#123;    return x == f[x] ? x : f[x] = getf(f[x]);&#125;void merge(int x,int y)&#123;    int fx = getf(x);    int fy = getf(y);    f[fx] = fy;&#125;signed main()&#123;    // ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    // cin >> n >> m;    scanf("%d %d",&n,&m);    for(int i = 1;i <= 3 * n;++i) f[i] = i;    //A -> B -> C -> A    for(int i = 1,op,x,y;i <= m;++i)    &#123;        scanf("%d %d %d",&op,&x,&y);        if(x > n || y > n)        &#123;            ans++;            continue;        &#125;        if(op == 1)        &#123;            if(getf(x) == getf(y + 2 * n) || getf(x + 2 * n) == getf(y))            &#123;                ans++;            &#125;            else            &#123;                merge(x,y);                merge(x + n,y + n);                merge(x + 2 * n,y + 2 * n);            &#125;        &#125;        else        &#123;            if(x == y)            &#123;                ans++;            &#125;            else if(getf(x) == getf(y) || getf(x + 2 * n) == getf(y))            &#123;                ans++;            &#125;            else            &#123;                merge(x,y + 2 * n);                merge(x + n,y);                merge(x + 2 * n,y + n);            &#125;        &#125;    &#125;    printf("%d\n",ans);    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p><strong>解题思路:</strong> 求一个连通块最大是多少，但是由于标号很大所以我们先需要离散化再进行并查集查找即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;const int maxn = 1e6 + 10;int ans,n;struct DSU&#123;    unordered_map<int,int> f;    unordered_map<int,int> sz;    int getf(int x)    &#123;        return x == f[x] ? x : f[x] = getf(f[x]);    &#125;    void merge(int x,int y)    &#123;        int fx = getf(x);        int fy = getf(y);        if(fx != fy)        &#123;            f[fx] = fy;            sz[fy] += sz[fx];            ans = max(ans,sz[fy]);        &#125;    &#125;    void init()    &#123;        f.clear();        sz.clear();        ans = 0;    &#125;&#125;dsu;array<int,2> p[maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        dsu.init();        cin >> n;        for(int i = 1,u,v;i <= n;++i)        &#123;            cin >> u >> v;            p[i] = &#123;u,v&#125;;            dsu.f[u] = u,dsu.sz[u] = 1;            dsu.f[v] = v,dsu.sz[v] = 1;        &#125;        for(int i = 1;i <= n;++i)        &#123;            auto [u,v] = p[i];            dsu.merge(u,v);        &#125;        cout << ans << "\n";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><p><strong>题目大意:</strong> 有三个长度为$n$的序列$a,b,c$</p><p>$Alice$和$Bob$玩游戏，一共进行$n$个回合，游戏规则如下：</p><ul><li>选定$a_i,b_i,c_i$</li><li>$Alice$从这三个数字选择一个数字删掉</li><li>$Bob$从这三个数字选择一个数字</li></ul><p>我们让$Bob$每回合选择的数字是$d_i$,如果序列$d$是一个排列那么$Alice$获胜否则$Bob$获胜</p><p>现在给定$a,b$两个数组，问有多少个$c$数组可以使得$Bob$获胜，结果对$998244353$取模</p><p><strong>解题思路:</strong> 首先我们先考虑$Alice$会选择什么数字删掉，假设对于第$i$次操作来说，$a_i &#x3D; b_i$,那么我们可以选择任意的$c_i$并且最终把$c_i$删掉，这样子$Bob$一定取到的是$a_i$这个数字表示的值(因为$a_i &#x3D; b_i$)</p><p>然后我们考虑如果$a_i \neq b_i$那么我们选择的$c_i$就非常重要，因为$c_i$决定着我们可以选择$a_i$或者$b_i$中的哪个数字，只需要让$c_i &#x3D; a_i \ or \ c_i &#x3D; b_i$即可</p><p>那么选择某一个位置的思路就很清晰了，我们只需要考虑构造大于等于两个相同的并且把其中一个不需要的值删掉即可</p><p>接下来我们再考虑位置之间带来的因素</p><p>假设我们没有$a_i &#x3D; b_i$的情况，那么我们现在的问题可以转换为给定两个序列分别是$a,b$，每个位置上面取一个看是否可以构成一个排序</p><p>对于这一个问题来说，因为每一个位置做一个选择，同时也相同与每一个位置的两个数字相互制衡，那么我们可以用图论的语言来表达，在他们之间建一条边</p><p>我们可以发现只有基环树的形式是可以的，而基环树的形式实际上就是点数等于边数</p><p>那么我们最终只需要使用并查集取维护每个环中存在点数和边数即可</p><p>那么最后再思考答案贡献，对于一个基环树来说，如果这个树里面没有自环，那么贡献就是$2$，因为考虑每条边有两个选择，如果里面有自环的话，贡献就是$n$</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longconst int maxn = 1e6 + 10;const int mod = 998244353;int n,m,a[maxn],b[maxn];int f[maxn],szv[maxn],sze[maxn],loop[maxn];void init()&#123;    for(int i = 1;i <= n;++i)    &#123;        f[i] = i;        szv[i] = 1;        sze[i] = 0;        loop[i] = 0;    &#125;&#125;int getf(int x)&#123;    return x == f[x] ? x : f[x] = getf(f[x]);&#125;void merge(int x,int y)&#123;    int fx = getf(x);    int fy = getf(y);    if(fx != fy)    &#123;        f[fy] = fx;        sze[fx] += sze[fy];        szv[fx] += szv[fy];        loop[fx] += loop[fy];    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        init();        for(int i = 1;i <= n;++i) cin >> a[i];        for(int i = 1;i <= n;++i) cin >> b[i];        for(int i = 1;i <= n;++i)        &#123;            merge(a[i],b[i]);            sze[getf(a[i])]++;            if(a[i] == b[i]) loop[getf(a[i])]++;        &#125;        int ans = 1;        for(int i = 1;i <= n;++i)        &#123;            if(i == getf(i))            &#123;                if(sze[i] != szv[i]) ans = 0;                else ans = ans * 2 % mod;            &#125;        &#125;        cout << ans << "\n";    &#125;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dsu </tag>
            
            <tag> mst </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythonbasic</title>
      <link href="/2023/01/03/pythonbasic/"/>
      <url>/2023/01/03/pythonbasic/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础语法和基本数据"><a href="#Python基础语法和基本数据" class="headerlink" title="Python基础语法和基本数据"></a>Python基础语法和基本数据</h1><h2 id="标识符号"><a href="#标识符号" class="headerlink" title="标识符号"></a>标识符号</h2><ul><li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符对大小写敏感。</li></ul><h2 id="Python保留字"><a href="#Python保留字" class="headerlink" title="Python保留字"></a>Python保留字</h2><p>保留字即关键字，我们不能把它们用作任何标识符名称。$Python$ 的标准库提供了一个 $keyword$ 模块。</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">import keywordprint(keyword.kwlist)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>$python$中单行注释以 <strong>#</strong> 开头</p><p>多行注释可以用多个 <strong>#</strong> 号，还有 <strong>‘’’</strong> 和 **”””**：</p><h2 id="Python多行语句"><a href="#Python多行语句" class="headerlink" title="Python多行语句"></a>Python多行语句</h2><p>$Python$ 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 *<em>*</em> 来实现多行语句，例如:</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">total = item_one + \        item_two + \        item_three<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>用 <code>**</code> 运算符来计算乘方</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">print(5 ** 2)#25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在交互模式下，可以用变量 <code>_</code> 表示上一次的值</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>$Python$中单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用完全相同。</p></li><li><p>使用三引号(<strong>‘’’</strong> 或 <strong>“””</strong>)可以指定一个多行字符串。</p></li><li><p>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong>。</p></li><li><p>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复。</p></li><li><p>$Python$ 中的字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始。</p></li><li><p>$Python$ 中的字符串不能改变。</p></li><li><p>$Python$ 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p></li><li><p>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></p></li></ul><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>$Python$中单引号 <code>&#39;</code> 和双引号 <code>&quot;</code>使用完全相同。</p><p>反斜杠 <code>\</code> 可以用来转义，或者如果我们想要使用单引号我们外面可以加一个双引号</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">print('this is test1')print('this is \' test2')print("this is test '3 ")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>this is test1this is &#39; test2this is test &#39;3</code></pre><p>注意如果我们不需要使用到转义的话我们可以在字符串前面加一个<code>r</code></p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">print('\hahah\tese')print(r'\hahah\tese')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">\hahahese\hahah\tese<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="跨行连续输入"><a href="#跨行连续输入" class="headerlink" title="跨行连续输入"></a>跨行连续输入</h3><p>使用三引号<code>&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;</code>可以指定一个多行字符串。</p><h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">print(3 * 'ha' + 'uhuh')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-line-numbers language-txt"><code class="language-line-numbers language-txt">hahahauhuh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者说可以按照字面意思连接字符串，比如相邻多个字符串会自动连接到一起</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">print('114514''1919810')<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre><code>1145141919810</code></pre><p>因此我们在输出较长字符串的时候我们可以使用按照字面意思连接的方法来输出</p><h3 id="字符串只读"><a href="#字符串只读" class="headerlink" title="字符串只读"></a>字符串只读</h3><p>$python$中的字符串不能被修改，如果我们需要强行修改的话会错掉</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">test = "testword"test[3] = 'i'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>Traceback (most recent call last):  File &quot;e:\Sublime Text\code\codeforces\traing\test.py&quot;, line 2, in &lt;module&gt;    test[3] = &#39;i&#39;TypeError: &#39;str&#39; object does not support item assignment</code></pre><p>如果需要一个新的字符串我们只能通过新建的方式来，同时我们可以使用$len$来获取字符串的长度</p><h3 id="字符串属性"><a href="#字符串属性" class="headerlink" title="字符串属性"></a>字符串属性</h3><pre><code>文本序列类型 --- str     字符串是一种 *序列类型* ，因此也支持序列类型的各种操作。  字符串的方法     字符串支持许多变换和查找的方法。  格式化字符串字面值     内嵌表达式的字符串字面值。  格式字符串语法     使用 &quot;str.format()&quot; 进行字符串格式化。  printf 风格的字符串格式化     这里详述了使用 &quot;%&quot; 运算符进行字符串格式化。</code></pre><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>字符串是可以被索引 (下标) 访问的，字符串的第一个字母的索引是 $0$</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">test = "testword"print(test[0])print(test[2])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>ts</code></pre><h3 id="负索引"><a href="#负索引" class="headerlink" title="负索引"></a>负索引</h3><p>索引使用负数的话说明是从右边往左边开始数，因为我们考虑到0的负数还是本身所以我们从 $-1$开始数</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">test = "testword"print(test[-1])print(test[-3])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>do</code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>索引可以获得单个字符，切片可以获得一个字符串的字串，切片的形式是$[l:r]$，对于切片来说$l$是被包含在输出的字符串当中但是$r$不会</p><p>切片的索引有默认值；省略开始索引时默认为0，省略结束索引时默认为到字符 串的结束:</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">test = "testword"print(test[0:2])print(test[2:5])print(test[:2] + test[2:])print(test[:3])print(test[-3:])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>testwtestwordtesord</code></pre><p>我们可以发现一个性质就是对于一个字符串来说$s[:i] + s[i:] &#x3D; s$</p><h3 id="索引越界"><a href="#索引越界" class="headerlink" title="索引越界"></a>索引越界</h3><p>在我们使用过大的索引的时候会出现以下的错误:</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">test = "testword"print(test[114514])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>Traceback (most recent call last):  File &quot;e:\Sublime Text\code\codeforces\traing\test.py&quot;, line 2, in &lt;module&gt;    print(test[114514])IndexError: string index out of range</code></pre><p>但是对于切片中的越界索引他会自动去取到相对应的边界</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">test = "testword"print(test[2:114514])print(test[114514:])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>stword</code></pre><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>列表是写在<code>[]</code>之间用有道分隔开的元素列表，和字符串一样列表也可以被索引和截取，列表被截取后返回一个包含所需元素的新列表，注意列表中的元素类型可以不相同</p><p>我们可以通过和字符串类似的写法$[a:b:c]$来表示从坐标$a$开始到坐标$b - 1$每次相间隔$c$去一个列表中的元素，特别需要注意的是，当$c &lt; 0$的时候，截取字符是从后往前的，那么我们可以采用如下的写法来进行对一个列表逆序</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">def reverseWords(input):         # 通过空格将字符串分隔符，把各个单词分隔为列表    inputWords = input.split(" ")     # 翻转字符串    # 假设列表 list = [1,2,3,4],      # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)    # inputWords[-1::-1] 有三个参数    # 第一个参数 -1 表示最后一个元素    # 第二个参数为空，表示移动到列表末尾    # 第三个参数为步长，-1 表示逆向    inputWords=inputWords[-1::-1]     # 重新组合字符串    output = ' '.join(inputWords)         return output if __name__ == "__main__":    input = 'I like runoob'    rw = reverseWords(input)    print(rw)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表还可以通过$append$来添加元素</p><h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p><p>像$ if $、$ while $ 、$ def $ 和$ class$ 这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">if expression :    suiteelif expression :    suite else :    suite<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p><p>元组中的类型也可以不相同</p><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 ${ }$ 或者 $set()$ 函数创建集合，注意：创建一个空集合必须用 $set()$ 而不是 ${ }$，因为 ${ }$ 是用来创建一个空字典。</p><p>创建格式：</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">st = &#123;1,2,3,4,5&#125;a = set("1234567")print("a:",a)print("st:",st)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">a: &#123;'2', '3', '1', '4', '6', '5', '7'&#125;st: &#123;1, 2, 3, 4, 5&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，对于一个已有元素的$set$,如果我们需要往这个里面添加元素的话，我们可以使用$add$函数来进行添加</p><p>注意这里的集合是一个 <strong>没有顺序</strong> 的集合</p><p>对于集合来说我们通常还需要判断一个集合和另外一个集合之间的关系，那么实际上 $python$也为我们提供了这些方法</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">print(a - b)     # a 和 b 的差集print(a | b)     # a 和 b 的并集print(a & b)     # a 和 b 的交集print(a ^ b)     # a 和 b 中不同时存在的元素，即只在一个集合中出现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">a = set("145296")b = set("256789")print(a - b)print(a | b)print(a & b)print(a ^ b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">&#123;'1', '4'&#125;&#123;'1', '5', '8', '9', '2', '4', '6', '7'&#125;&#123;'9', '5', '2', '6'&#125;&#123;'1', '4', '8', '7'&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p>字典是一种映射类型，字典用 ${ }$标识，它是一个无序的 键$(key)$ : 值$(value)$ 的集合。</p><p>键$(key)$必须使用不可变类型。</p><p>在同一个字典中，键$(key)$必须是唯一的。</p><p>注意对于字典的构造函数$dict()$也可以直接从键值对序列中构建字典如下</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">>>> dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])&#123;'Runoob': 1, 'Google': 2, 'Taobao': 3&#125;>>> &#123;x: x**2 for x in (2, 4, 6)&#125;&#123;2: 4, 4: 16, 6: 36&#125;>>> dict(Runoob=1, Google=2, Taobao=3)&#123;'Runoob': 1, 'Google': 2, 'Taobao': 3&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h3><p>$python$提供$input()$函数从标准输入中读入一行 <strong>文本</strong></p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">str = input()print(str)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="读取一行中的多个数字"><a href="#读取一行中的多个数字" class="headerlink" title="读取一行中的多个数字"></a>读取一行中的多个数字</h3><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python"># 读取一行中的两个整数a, b = map(float, input().split())print(a,b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="读取一行中的数字，两个数字类型不一样"><a href="#读取一行中的数字，两个数字类型不一样" class="headerlink" title="读取一行中的数字，两个数字类型不一样"></a>读取一行中的数字，两个数字类型不一样</h3><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python"># 读取一行中的两个数字a, b = input().split()a = int(a)b = float(b)print(a,b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读取一个文件直到末尾"><a href="#读取一个文件直到末尾" class="headerlink" title="读取一个文件直到末尾"></a>读取一个文件直到末尾</h3><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python"># 打开文件with open("test.txt", "r") as f:    # 读取文件的每一行    for line in f:        # 在这里处理每一行的数据        print(line)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python循环语句"><a href="#Python循环语句" class="headerlink" title="Python循环语句"></a>Python循环语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>$python$中并不存在$do…while$的语法，因此我们可以直接用$while$来写。</p><p>除此之外$python$还存在在一个$while$后面跟着$else$</p><p>一般来说是如果我当前的$while$不执行的话那么我就会直接走后面的$else$</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">n = 10now = 0sum = 0while now <= n:    sum += now    now += 1else:    print("sum??",sum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如上面的程序就是先去计算$1…10$的和然后跳出循环之后直接输出这个和是多少</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>我们需要注意的是，对于$python$来说，$for$循环可以遍历任何可以迭代的对象，比如一个列表或者一个字符串</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">a = [1,2,3,4,5]for i in a:    if(i == 3):        print("Good number")        break    print("now number is",i)else:    print("no good number")print("finish")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上述程序我们跑出来的结果是</p><pre><code>now number is 1now number is 2Good numberfinish</code></pre><p>更改成以下内容跑出来的数据相对应的是</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">a = [1,2,7,4,5]for i in a:    if(i == 3):        print("Good number")        break    print("now number is",i)else:    print("no good number")print("finish")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>now number is 1now number is 2now number is 7now number is 4now number is 5no good numberfinish</code></pre><h4 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h4><p>遍历数字序列的时候我们可以使用内置的$range$函数</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">for i in range(5):    print(i,end = " ")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>0 1 2 3 4</code></pre><p>如何指定区间的话，假设$range(l,r)$，那么我们获得的数字就是从$l$然后一直到$r - 1$</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">for i in range(5,10):    print(i,end = " ")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre><code>5 6 7 8 9</code></pre><p>当然$range$还具有第三个参数步长，可以通过给这个步长一些指定的参数来进行循环</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">sum = 0for i in range(0,10,2):    print(i)    sum += iprint(sum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如上述程序就会从$0 - 8$逐个相加</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">sum = 0for i in range(0,10,2):    print(i)    sum += iprint(sum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时我们也可以通过$range$和$len$函数去遍历一个序列的索引</p><pre class="line-numbers language-line-numbers language-python"><code class="language-line-numbers language-python">a = [1,2,3,4,55,666,7777]for i in range(len(a)):    print(i,a[i])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre><code>0 11 22 33 44 555 6666 7777</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goodbye2022</title>
      <link href="/2023/01/03/goodbye2022/"/>
      <url>/2023/01/03/goodbye2022/</url>
      
        <content type="html"><![CDATA[<h1 id="Good-Bye-2022"><a href="#Good-Bye-2022" class="headerlink" title="Good Bye 2022"></a>Good Bye 2022</h1><h2 id="A-Koxia-and-Whiteboards"><a href="#A-Koxia-and-Whiteboards" class="headerlink" title="A.Koxia and Whiteboards"></a>A.Koxia and Whiteboards</h2><p>**题目大意: ** 给定一个长度为$n$的序列，接下来进行$m$次操作，问操作之后序列值最大是多少</p><p><strong>解题思路:</strong> 数量级很小考虑暴力即可，每次把$a$序列中最小的元素换下来</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longconst int maxn = 1e6 + 10;int n,m,a[maxn],b[maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n >> m;        multiset<int> st;        for(int i = 1;i <= n;++i) cin >> a[i],st.insert(a[i]);        for(int i = 1;i <= m;++i) cin >> b[i];        for(int i = 1;i <= m;++i)        &#123;            st.erase(st.begin());            st.insert(b[i]);        &#125;        int sum = 0;        for(auto to:st) sum += to;        cout << sum << "\n";    &#125;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Koxia-and-Permutation"><a href="#B-Koxia-and-Permutation" class="headerlink" title="B. Koxia and Permutation"></a>B. Koxia and Permutation</h2><p><strong>题目大意:</strong> 构造一个长度为$n$的序列，进行$n - k + 1$次划分，第$i$次划分获得的是从$i$开始$k$个数字的最大值和最小值相加，一个排列$p$的代价是划分中的值的最大值，问这个最大值最小的序列是什么样的</p><p><strong>解题思路:</strong> 因为最后要让我们的最大值最小，考虑值的构成是一个区域内的最大值加上最小值，如果一段区域里面都是连续的大数是肯定不行的，因此我们可以从$1-n$的数字头尾顺序取即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longconst int maxn = 1e6 + 10;int n,m,a[maxn],b[maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n >> m;        vector<int> ans;        for(int i = 1,j = n;i < j;++i,--j)        &#123;            ans.push_back(j);            ans.push_back(i);            // cout << "??? " << i << " " << j << "\n";        &#125;        if(n & 1) ans.push_back((n + 1) / 2);        for(auto to:ans)        &#123;            cout << to << " ";        &#125;        cout << "\n";    &#125;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Koxia-and-Number-Theory"><a href="#C-Koxia-and-Number-Theory" class="headerlink" title="C. Koxia and Number Theory"></a>C. Koxia and Number Theory</h2><p><strong>题目大意:</strong> 给定一个长度为$n$的序列,问是否存在一个$x$使得每一对$gcd(a_i+ x ,a_j + x) &#x3D; 1$</p><p><strong>解题思路:</strong> 不懂数学，感觉可以看严格鸽的</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longconst int maxn = 1e6 + 10;int n,m,a[maxn],b[maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        set<int> st;        for(int i = 1;i <= n;++i) cin >> a[i],st.insert(a[i]);        if(st.size() != n)        &#123;            cout << "No\n";            continue;        &#125;        int f = 1;        for(int p = 2;p <= n;++p)        &#123;            map<int,int> mp;            for(int i = 1;i <= n;++i) mp[a[i] % p]++;            int mi = n + n;            int ha = 0;            for(auto to:mp)            &#123;                if(to.second >= 2) ha++;            &#125;            if(ha >= p) f = 0;        &#125;        if(f) cout << "Yes\n";        else cout << "No\n";    &#125;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Koxia-and-Game"><a href="#D-Koxia-and-Game" class="headerlink" title="D. Koxia and Game"></a>D. Koxia and Game</h2><p><strong>题目大意:</strong> 有三个长度为$n$的序列$a,b,c$</p><p>$Alice$和$Bob$玩游戏，一共进行$n$个回合，游戏规则如下：</p><ul><li>选定$a_i,b_i,c_i$</li><li>$Alice$从这三个数字选择一个数字删掉</li><li>$Bob$从这三个数字选择一个数字</li></ul><p>我们让$Bob$每回合选择的数字是$d_i$,如果序列$d$是一个排列那么$Alice$获胜否则$Bob$获胜</p><p>现在给定$a,b$两个数组，问有多少个$c$数组可以使得$Bob$获胜，结果对$998244353$取模</p><p><strong>解题思路:</strong> 首先我们先考虑$Alice$会选择什么数字删掉，假设对于第$i$次操作来说，$a_i &#x3D; b_i$,那么我们可以选择任意的$c_i$并且最终把$c_i$删掉，这样子$Bob$一定取到的是$a_i$这个数字表示的值(因为$a_i &#x3D; b_i$)</p><p>然后我们考虑如果$a_i \neq b_i$那么我们选择的$c_i$就非常重要，因为$c_i$决定着我们可以选择$a_i$或者$b_i$中的哪个数字，只需要让$c_i &#x3D; a_i \ or \ c_i &#x3D; b_i$即可</p><p>那么选择某一个位置的思路就很清晰了，我们只需要考虑构造大于等于两个相同的并且把其中一个不需要的值删掉即可</p><p>接下来我们再考虑位置之间带来的因素</p><p>假设我们没有$a_i &#x3D; b_i$的情况，那么我们现在的问题可以转换为给定两个序列分别是$a,b$，每个位置上面取一个看是否可以构成一个排序</p><p>对于这一个问题来说，因为每一个位置做一个选择，同时也相同与每一个位置的两个数字相互制衡，那么我们可以用图论的语言来表达，在他们之间建一条边</p><p>我们可以发现只有基环树的形式是可以的，而基环树的形式实际上就是点数等于边数</p><p>那么我们最终只需要使用并查集取维护每个环中存在点数和边数即可</p><p>那么最后再思考答案贡献，对于一个基环树来说，如果这个树里面没有自环，那么贡献就是$2$，因为考虑每条边有两个选择，如果里面有自环的话，贡献就是$n$</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longconst int maxn = 1e6 + 10;const int mod = 998244353;int n,m,a[maxn],b[maxn];int f[maxn],szv[maxn],sze[maxn],loop[maxn];void init()&#123;    for(int i = 1;i <= n;++i)    &#123;        f[i] = i;        szv[i] = 1;        sze[i] = 0;        loop[i] = 0;    &#125;&#125;int getf(int x)&#123;    return x == f[x] ? x : f[x] = getf(f[x]);&#125;void merge(int x,int y)&#123;    int fx = getf(x);    int fy = getf(y);    if(fx != fy)    &#123;        f[fy] = fx;        sze[fx] += sze[fy];        szv[fx] += szv[fy];        loop[fx] += loop[fy];    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        init();        for(int i = 1;i <= n;++i) cin >> a[i];        for(int i = 1;i <= n;++i) cin >> b[i];        for(int i = 1;i <= n;++i)        &#123;            merge(a[i],b[i]);            sze[getf(a[i])]++;            if(a[i] == b[i]) loop[getf(a[i])]++;        &#125;        int ans = 1;        for(int i = 1;i <= n;++i)        &#123;            if(i == getf(i))            &#123;                if(sze[i] != szv[i]) ans = 0;                else ans = ans * 2 % mod;            &#125;        &#125;        cout << ans << "\n";    &#125;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC-2021-EC-J</title>
      <link href="/2022/11/11/ICPC-2021-EC-J/"/>
      <url>/2022/11/11/ICPC-2021-EC-J/</url>
      
        <content type="html"><![CDATA[<h1 id="J-Elden-Ring"><a href="#J-Elden-Ring" class="headerlink" title="J. Elden Ring"></a>J. Elden Ring</h1><p><a href="https://codeforces.com/gym/103861/problem/J">https://codeforces.com/gym/103861/problem/J</a></p><p><strong>题目大意:</strong> 给定一个规模为$2e5$的无向图，每个点除了起始点都有一个怪物在那里，第$i$个点的怪物的战力值为$l_i$，我们初始的战力值为$l_1$</p><p>我们可以打败怪物当且仅当我们的战力值比怪物的高。怪物每天的战力值会增加$B$，我们杀掉一只怪物增加的战力值为$A$，问我们是否可以到达最终点</p><p><strong>解题思路:</strong> 考虑这道题和别的题目不一样的地方也就是引入了战力值这个概念，首先我们假设我们的战力值永远不会改变，那么起始也就是对于$A &#x3D; B$的这一种情况，我们直接$BFS$，并且看当前这个点的战力值是否比起始点要小，符合条件的那么我们就可以加入相对应的队列即可。</p><p>然后我们考虑$A &lt; B$的这一种情况，因为我们的战力值是不断减少的，那么我们仍然可以直接$BFS$去找我们可以到达的点，并且比较到达当前点消耗的数值是否比原来的战力值小即可。</p><p>最后我们来分析$A &gt; B$的情况，因为$A &gt; B$，所以我们的战力值是在不断增加的。在不断增加的时候我们实际上是可以开放很多点的，那么对于原来的跑图来说我们处理的要么是本身可以到达的，要么是处理因为一些条件不能到达的，因此对于这一张新图来说我们先跑一遍最短路来处理什么点在这种情况下可以先到达。</p><p>对于处理这一张新图来说我们首先先把$1$号节点给放进去，然后我们再跑$dij$，优先队列里面放的是当前点的权值和这个点，维护一个小数字在前面的队列。因为小数字在前面，那么我们可以不断增加自己的战力值，因此最后有可能达到一些权值更大的情况。</p><p>然后在跑实际天数的时候我们可以直接跑$dij$，但是这里的话使用的是从$1$号节点到当前这个$now$节点所需要的天数,然后对当前的值进行分析，如果比转移点要小的话直接$+1$即可，否则计算以下从$1$号节点转移过来的权值</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;typedef long long ll;const int maxn = 2e5 + 10;const ll inf = 1e18;vector<int> edge[maxn];ll n,m,A,B;ll dis[maxn],vis[maxn],val[maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    for(int Case = 1;Case <= T;++Case)    &#123;        cin >> n >> m >> A >> B;        for(int i = 1;i <= n;++i)        &#123;            edge[i].clear();            dis[i] = inf;            vis[i] = 0;        &#125;        for(int i = 1,u,v;i <= m;++i)        &#123;            cin >> u >> v;            edge[u].push_back(v);            edge[v].push_back(u);        &#125;        for(int i = 1;i <= n;++i) cin >> val[i],val[i] += B;        val[1] -= B;        if(A == B)        &#123;            queue<int> que;            que.push(1);            dis[1] = 0;            while(!que.empty())            &#123;                auto now = que.front();                que.pop();                for(auto to:edge[now])                &#123;                    if(val[to] < val[1] && dis[to] > dis[now])                    &#123;                        que.push(to);                        dis[to] = dis[now] + 1;                    &#125;                &#125;            &#125;            cout << (dis[n] == inf ? -1 : dis[n]) << "\n";        &#125;        else if(A < B)        &#123;            queue<int> que;            que.push(1);            dis[1] = 0;            while(!que.empty())            &#123;                auto now = que.front();                que.pop();                for(auto to:edge[now])                &#123;                    if(1ll * val[to] + dis[now] * (B - A) * 1ll < val[1] && dis[to] > dis[now])                    &#123;                        dis[to] = dis[now] + 1;                        que.push(to);                    &#125;                &#125;            &#125;            cout << (dis[n] == inf ? -1 : dis[n]) << "\n";        &#125;        else        &#123;            priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> que;            int day = -1;            que.push(&#123;0,1&#125;);            while(!que.empty())            &#123;                auto [nowd,now] = que.top();                que.pop();                if(vis[now]) continue;                if(day != -1 && val[now] >= val[1] + (A - B) * day)                &#123;                    break;                &#125;                vis[now] = 1;                day++;                for(auto to:edge[now])                &#123;                    if(!vis[to]) que.push(&#123;val[to],to&#125;);                &#125;            &#125;            dis[1] = 0;            while(!que.empty()) que.pop();            que.push(&#123;dis[1],1&#125;);            while(!que.empty())            &#123;                auto [nowd,now] = que.top();                que.pop();                if(nowd > dis[now]) continue;                for(auto to:edge[now])                &#123;                    if(!vis[to]) continue;                    if(val[to] < val[now] && dis[to] > nowd + 1)                    &#123;                        dis[to] = nowd + 1;                        que.push(&#123;dis[to],to&#125;);                        continue;                    &#125;                    if(dis[to] > max(nowd + 1ll,(val[to] - val[1]) / (A - B) + 2))                    &#123;                        dis[to] = max(nowd + 1ll,(val[to] - val[1]) / (A - B) + 2);                        que.push(&#123;dis[to],to&#125;);                    &#125;                &#125;            &#125;            cout << (dis[n] == inf ? -1 : dis[n]) << "\n";        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 831 A - E</title>
      <link href="/2022/11/01/Codeforces-Round-831-A-E/"/>
      <url>/2022/11/01/Codeforces-Round-831-A-E/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-831-A-E"><a href="#Codeforces-Round-831-A-E" class="headerlink" title="Codeforces Round 831 A - E"></a>Codeforces Round 831 A - E</h1><h2 id="A-Factorise-N-M"><a href="#A-Factorise-N-M" class="headerlink" title="A. Factorise N+M"></a>A. Factorise N+M</h2><p><strong>题目大意:</strong> 给定一个质数$n$，找到一个质数$m$ ，使得$n + m$是一个非质数</p><p><strong>解题思路:</strong> 对于非$2$的质数来说其他质数全部都是奇数，那么我们可以对于这些质数加上一个$3$，然后对于$2$特判加上$5$即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        if(n == 2)        &#123;            cout << 7 << "\n";        &#125;        else cout << 3 << "\n";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Jumbo-Extra-Cheese-2"><a href="#B-Jumbo-Extra-Cheese-2" class="headerlink" title="B. Jumbo Extra Cheese 2"></a>B. Jumbo Extra Cheese 2</h2><p><strong>题目大意:</strong> 给定$n$个矩阵，我们需要把矩阵放到$x$轴上面，一个矩阵不能放在另外一个矩阵的上面，问这个矩阵的形成的一个图形的周长是多少</p><p><strong>解题思路:</strong> 将这个图形拿出来在颅内思考一下，发现因为很多个矩形会贴在一起，那么对于形成的这个图形的 <strong>高</strong> 实际上就是最长的矩形的高，同时对于每个矩形来说他们的宽都要计算两边，那么我们对于每一个矩形来说我们可以选定较小的那一部分作为宽，较高的那一部分作为高，然后找一个最长的高即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">pair<int,int> a[maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        for(int i = 1,u,v;i <= n;++i)        &#123;            cin >> u >> v;            if(u < v) swap(u,v);            a[i] = &#123;u,v&#125;;        &#125;        sort(a + 1,a + 1 + n);        int ans = 2 * a[n].first;        for(int i = 1;i <= n;++i)        &#123;            ans += a[i].second * 2;        &#125;        cout << ans << "\n";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Bricks-and-Bags"><a href="#C-Bricks-and-Bags" class="headerlink" title="C. Bricks and Bags"></a>C. Bricks and Bags</h2><p><strong>题目大意:</strong> 给定$n(1 \leq n \leq 10^5)$个数字，将他们放在$a,b,c$三个背包中，玩家需要从这三个背包中各选择一个数字，并且计算$|w_1 - w_2| + |w_2 - w_3|$ $(w_1 \in a,w_2 \in b,w_3 \in c)$的值是多少，然后玩家想要让值尽可能的小，放置者想要让值尽可能的大，问如何放置才能使得这个值最大</p><p><strong>解题思路:</strong> 首先先放在数轴上面考虑这个问题，我们假设$w_3 &gt; w_1$，如果$w_2$在$w_1$和$w_3$之间，那么值就是$w_3 - w_1$，如果$w_2 &lt; w_1$，那么对应的值就是$w_1 - w_2 + w_3 - w_2$，若$w_2 &gt; w_3$，那么对应的值就是$w_2 - w_3 + w_2 - w_1$</p><p>对于夹在中间的情况，我们可以直接计算，也就是整个序列的最大值减去整个序列的最小值</p><p>如果是第一种情况$w_2 &lt; w_1$，那么实际上我们是去取若干个小值给放在$b$中，为了让权值最大我们可以把$a_n$给单独拉出来当作$w_3$，假设目前取到的小值已经到了第$i$位，那么权值就是$a_n - a_i + a_{i + 1} - a_i$</p><p>如果是第二种情况$w_2 &gt; w_3$，那么实际上我们就是去取若干个大值给放在$b$中，为了让权值最大我们可以把$a_1$给单独拉出来当作$w_1$，假设目前取到的大值已经到了第$i$位，那么权值实际上就是$a_i - a_1 + a_i - a_{i - 1}$</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        for(int i = 1;i <= n;++i) cin >> a[i];        sort(a + 1,a + 1 + n);        int ans = 0;        for(int i = 1;i < n - 1;++i)        &#123;            chkmax(ans,a[n] - a[i] + a[i + 1] - a[i]);        &#125;        for(int i = n;i > 2;--i)        &#123;            chkmax(ans,a[i] - a[i - 1] + a[i] - a[1]);        &#125;        cout << ans << "\n";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Knowledge-Cards"><a href="#D-Knowledge-Cards" class="headerlink" title="D. Knowledge Cards"></a>D. Knowledge Cards</h2><p><strong>题目大意:</strong> 给定一个$n * m(n * m \leq 10^6)$的矩阵，刚开始在矩阵$(1,1)$堆积着$k$张牌，从顶部到底部分别是$a_1,a_2,…,a_k$，接下来我们可以把牌移动到别的格子中，注意除了$(1,1)$和$(n,m)$这两个格子其他格子放置的牌数不能超过一张，然后$(1,1)$不能被重复放置牌，也不能从$(n,m)$移出去一张牌，问堆在$(n,m)$上面的牌从顶部到底部牌的排列是否可以是$1,2,3,…k$</p><p><strong>解题思路:</strong> 直接移动牌即可，因为我们在移动牌的时候肯定需要给当前一张牌留出一点位置的，所以除了$(1,1)$和$(n,m)$我们另外留出一个位置就能随便移动了，否则就是不能构成的情况</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">cin >> n >> m >> k;for(int i = 1;i <= k;++i) cin >> a[i];int nowcnt = k;priority_queue<int,vector<int>,less<int>> q;int f = 1;for(int i = 1;i <= k;++i)&#123;    q.push(a[i]);    if(q.size() >= n * m - 2)    &#123;        f = 0;        break;    &#125;    while(!q.empty() && q.top() == nowcnt)    &#123;        q.pop();        nowcnt--;    &#125;&#125;if(f) cout << "YA\n";else cout << "TIDAK\n";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Hanging-Hearts"><a href="#E-Hanging-Hearts" class="headerlink" title="E. Hanging Hearts"></a>E. Hanging Hearts</h2><p><strong>题目大意:</strong> 给定一棵树，我们需要给这棵树分配一些权值，这些权值属于一个排列。然后我们从叶子开始取，取的时候会构成一个序列。我们每次取叶子的时候判断他的父节点是否大于叶子结点如果大于叶子结点那么父节点的权值也变成叶子结点的权值，问构成的序列中形成的最大非递减子序列长度是多少</p><p><strong>解题思路:</strong> 考虑拿取叶子的性质实际上我们将小的权值放在下面更好一点，因为小的权值会把权值赋值给上面的父亲节点，那么对于一个节点来说她下面可能有很多条链，我这个节点要么作为子序列的终点要么作为子序列的中转点。如果作为终点的话那么也需要从下面的终点转移过来，如果作为中转点的话就可以将下面的节点选择他们的中转点或者是终点取最大然后把权值全部加起来</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">int n,m,k;int dp[maxn][2];vector<int> edge[maxn];void dfs(int s,int fa)&#123;    dp[s][0] = dp[s][1] = 0;    int mx = 0;    for(auto to:edge[s])    &#123;        if(to == fa) continue;        dfs(to,s);        dp[s][0] += max(dp[to][0],dp[to][1]);        chkmax(mx,dp[to][1]);    &#125;    dp[s][1] = mx + 1;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    for(int i = 2,x;i <= n;++i)    &#123;        cin >> x;        edge[i].push_back(x);        edge[x].push_back(i);    &#125;    dfs(1,0);    cout << max(dp[1][0],dp[1][1]) << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computational Geometry</title>
      <link href="/2022/10/29/Computational-Geometry/"/>
      <url>/2022/10/29/Computational-Geometry/</url>
      
        <content type="html"><![CDATA[<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;using point_t=long double;  //全局数据类型，可修改为 long long 等constexpr point_t eps=1e-8;constexpr long double PI=3.1415926535897932384l;// 点与向量template<typename T> struct point&#123;    T x,y;    bool operator==(const point &a) const &#123;return (abs(x-a.x)<=eps && abs(y-a.y)<=eps);&#125;    bool operator<(const point &a) const &#123;if (abs(x-a.x)<=eps) return y<a.y-eps; return x<a.x-eps;&#125;    bool operator>(const point &a) const &#123;return !(*this<a || *this==a);&#125;    point operator+(const point &a) const &#123;return &#123;x+a.x,y+a.y&#125;;&#125;    point operator-(const point &a) const &#123;return &#123;x-a.x,y-a.y&#125;;&#125;    point operator-() const &#123;return &#123;-x,-y&#125;;&#125;    point operator*(const T k) const &#123;return &#123;k*x,k*y&#125;;&#125;    point operator/(const T k) const &#123;return &#123;x/k,y/k&#125;;&#125;    T operator*(const point &a) const &#123;return x*a.x+y*a.y;&#125;  // 点积    T operator^(const point &a) const &#123;return x*a.y-y*a.x;&#125;  // 叉积，注意优先级    int toleft(const point &a) const &#123;const auto t=(*this)^a; return (t>eps)-(t<-eps);&#125;  // to-left 测试    T len2() const &#123;return (*this)*(*this);&#125;  // 向量长度的平方    T dis2(const point &a) const &#123;return (a-(*this)).len2();&#125;  // 两点距离的平方    // 涉及浮点数    long double len() const &#123;return sqrtl(len2());&#125;  // 向量长度    long double dis(const point &a) const &#123;return sqrtl(dis2(a));&#125;  // 两点距离    long double ang(const point &a) const &#123;return acosl(max(-1.0l,min(1.0l,((*this)*a)/(len()*a.len()))));&#125;  // 向量夹角    point rot(const long double rad) const &#123;return &#123;x*cos(rad)-y*sin(rad),x*sin(rad)+y*cos(rad)&#125;;&#125;  // 逆时针旋转（给定角度）    point rot(const long double cosr,const long double sinr) const &#123;return &#123;x*cosr-y*sinr,x*sinr+y*cosr&#125;;&#125;  // 逆时针旋转（给定角度的正弦与余弦）&#125;;using Point=point<point_t>;// 极角排序struct argcmp&#123;    bool operator()(const Point &a,const Point &b) const    &#123;        const auto quad=[](const Point &a)        &#123;            if (a.y<-eps) return 1;            if (a.y>eps) return 4;            if (a.x<-eps) return 5;            if (a.x>eps) return 3;            return 2;        &#125;;        const int qa=quad(a),qb=quad(b);        if (qa!=qb) return qa<qb;        const auto t=a^b;        // if (abs(t)<=eps) return a*a<b*b-eps;  // 不同长度的向量需要分开        return t>eps;    &#125;&#125;;// 直线template<typename T> struct line&#123;    point<T> p,v;  // p 为直线上一点，v 为方向向量    bool operator==(const line &a) const &#123;return v.toleft(a.v)==0 && v.toleft(p-a.p)==0;&#125;    int toleft(const point<T> &a) const &#123;return v.toleft(a-p);&#125;  // to-left 测试    bool operator<(const line &a) const  // 半平面交算法定义的排序    &#123;        if (abs(v^a.v)<=eps && v*a.v>=-eps) return toleft(a.p)==-1;        return argcmp()(v,a.v);    &#125;    // 涉及浮点数    point<T> inter(const line &a) const &#123;return p+v*((a.v^(p-a.p))/(v^a.v));&#125;  // 直线交点    long double dis(const point<T> &a) const &#123;return abs(v^(a-p))/v.len();&#125;  // 点到直线距离    point<T> proj(const point<T> &a) const &#123;return p+v*((v*(a-p))/(v*v));&#125;  // 点在直线上的投影&#125;;using Line=line<point_t>;//线段template<typename T> struct segment&#123;    point<T> a,b;    bool operator<(const segment &s) const &#123;return make_pair(a,b)<make_pair(s.a,s.b);&#125;    // 判定性函数建议在整数域使用    // 判断点是否在线段上    // -1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上    int is_on(const point<T> &p) const      &#123;        if (p==a || p==b) return -1;        return (p-a).toleft(p-b)==0 && (p-a)*(p-b)<-eps;    &#125;    // 判断线段直线是否相交    // -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交    int is_inter(const line<T> &l) const    &#123;        if (l.toleft(a)==0 || l.toleft(b)==0) return -1;        return l.toleft(a)!=l.toleft(b);    &#125;        // 判断两线段是否相交    // -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交    int is_inter(const segment<T> &s) const    &#123;        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;        const line<T> l&#123;a,b-a&#125;,ls&#123;s.a,s.b-s.a&#125;;        return l.toleft(s.a)*l.toleft(s.b)==-1 && ls.toleft(a)*ls.toleft(b)==-1;    &#125;    // 点到线段距离    long double dis(const point<T> &p) const    &#123;        if ((p-a)*(b-a)<-eps || (p-b)*(a-b)<-eps) return min(p.dis(a),p.dis(b));        const line<T> l&#123;a,b-a&#125;;        return l.dis(p);    &#125;    // 两线段间距离    long double dis(const segment<T> &s) const    &#123;        if (is_inter(s)) return 0;        return min(&#123;dis(s.a),dis(s.b),s.dis(a),s.dis(b)&#125;);    &#125;&#125;;using Segment=segment<point_t>;//----------------------------必打-----------------------//// 多边形template<typename T> struct polygon&#123;    vector<point<T>> p;  // 以逆时针顺序存储    size_t nxt(const size_t i) const &#123;return i==p.size()-1?0:i+1;&#125;    size_t pre(const size_t i) const &#123;return i==0?p.size()-1:i-1;&#125;        // 回转数    // 返回值第一项表示点是否在多边形边上    // 对于狭义多边形，回转数为 0 表示点在多边形外，否则点在多边形内    pair<bool,int> winding(const point<T> &a) const    &#123;        int cnt=0;        for (size_t i=0;i<p.size();i++)        &#123;            const point<T> u=p[i],v=p[nxt(i)];            if (abs((a-u)^(a-v))<=eps && (a-u)*(a-v)<=eps) return &#123;true,0&#125;;            if (abs(u.y-v.y)<=eps) continue;            const Line uv=&#123;u,v-u&#125;;            if (u.y<v.y-eps && uv.toleft(a)<=0) continue;            if (u.y>v.y+eps && uv.toleft(a)>=0) continue;            if (u.y<a.y-eps && v.y>=a.y-eps) cnt++;            if (u.y>=a.y-eps && v.y<a.y-eps) cnt--;        &#125;        return &#123;false,cnt&#125;;    &#125;    // 多边形面积的两倍    // 可用于判断点的存储顺序是顺时针或逆时针    T area() const    &#123;        T sum=0;        for (size_t i=0;i<p.size();i++) sum+=p[i]^p[nxt(i)];        return sum;    &#125;    // 多边形的周长    long double circ() const    &#123;        long double sum=0;        for (size_t i=0;i<p.size();i++) sum+=p[i].dis(p[nxt(i)]);        return sum;    &#125;&#125;;using Polygon=polygon<point_t>;//凸多边形template<typename T> struct convex: polygon<T>&#123;    // 闵可夫斯基和    convex operator+(const convex &c) const      &#123;        const auto &p=this->p;        vector<Segment> e1(p.size()),e2(c.p.size()),edge(p.size()+c.p.size());        vector<point<T>> res; res.reserve(p.size()+c.p.size());        const auto cmp=[](const Segment &u,const Segment &v) &#123;return argcmp()(u.b-u.a,v.b-v.a);&#125;;        for (size_t i=0;i<p.size();i++) e1[i]=&#123;p[i],p[this->nxt(i)]&#125;;        for (size_t i=0;i<c.p.size();i++) e2[i]=&#123;c.p[i],c.p[c.nxt(i)]&#125;;        rotate(e1.begin(),min_element(e1.begin(),e1.end(),cmp),e1.end());        rotate(e2.begin(),min_element(e2.begin(),e2.end(),cmp),e2.end());        merge(e1.begin(),e1.end(),e2.begin(),e2.end(),edge.begin(),cmp);        const auto check=[](const vector<point<T>> &res,const point<T> &u)        &#123;            const auto back1=res.back(),back2=*prev(res.end(),2);            return (back1-back2).toleft(u-back1)==0 && (back1-back2)*(u-back1)>=-eps;        &#125;;        auto u=e1[0].a+e2[0].a;        for (const auto &v:edge)        &#123;            while (res.size()>1 && check(res,u)) res.pop_back();            res.push_back(u);            u=u+v.b-v.a;        &#125;        if (res.size()>1 && check(res,res[0])) res.pop_back();        return &#123;res&#125;;    &#125;    // 旋转卡壳    // func 为更新答案的函数，可以根据题目调整位置    template<typename F> void rotcaliper(const F &func) const    &#123;        const auto &p=this->p;        const auto area=[](const point<T> &u,const point<T> &v,const point<T> &w)&#123;return (w-u)^(w-v);&#125;;        for (size_t i=0,j=1;i<p.size();i++)        &#123;            const auto nxti=this->nxt(i);            func(p[i],p[nxti],p[j]);            while (area(p[this->nxt(j)],p[i],p[nxti])>=area(p[j],p[i],p[nxti]))            &#123;                j=this->nxt(j);                func(p[i],p[nxti],p[j]);            &#125;        &#125;    &#125;    // 凸多边形的直径的平方    T diameter2() const    &#123;        const auto &p=this->p;        if (p.size()==1) return 0;        if (p.size()==2) return p[0].dis2(p[1]);        T ans=0;        auto func=[&](const point<T> &u,const point<T> &v,const point<T> &w)&#123;ans=max(&#123;ans,w.dis2(u),w.dis2(v)&#125;);&#125;;        rotcaliper(func);        return ans;    &#125;        // 判断点是否在凸多边形内    // 复杂度 O(logn)    // -1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内    int is_in(const point<T> &a) const    &#123;        const auto &p=this->p;        if (p.size()==1) return a==p[0]?-1:0;        if (p.size()==2) return segment<T>&#123;p[0],p[1]&#125;.is_on(a)?-1:0;         if (a==p[0]) return -1;        if ((p[1]-p[0]).toleft(a-p[0])==-1 || (p.back()-p[0]).toleft(a-p[0])==1) return 0;        const auto cmp=[&](const Point &u,const Point &v)&#123;return (u-p[0]).toleft(v-p[0])==1;&#125;;        const size_t i=lower_bound(p.begin()+1,p.end(),a,cmp)-p.begin();        if (i==1) return segment<T>&#123;p[0],p[i]&#125;.is_on(a)?-1:0;        if (i==p.size()-1 && segment<T>&#123;p[0],p[i]&#125;.is_on(a)) return -1;        if (segment<T>&#123;p[i-1],p[i]&#125;.is_on(a)) return -1;        return (p[i]-p[i-1]).toleft(a-p[i-1])>0;    &#125;    // 凸多边形关于某一方向的极点    // 复杂度 O(logn)    // 参考资料：https://codeforces.com/blog/entry/48868    template<typename F> size_t extreme(const F &dir) const    &#123;        const auto &p=this->p;        const auto check=[&](const size_t i)&#123;return dir(p[i]).toleft(p[this->nxt(i)]-p[i])>=0;&#125;;        const auto dir0=dir(p[0]); const auto check0=check(0);        if (!check0 && check(p.size()-1)) return 0;        const auto cmp=[&](const Point &v)        &#123;            const size_t vi=&v-p.data();            if (vi==0) return 1;            const auto checkv=check(vi);            const auto t=dir0.toleft(v-p[0]);            if (vi==1 && checkv==check0 && t==0) return 1;            return checkv^(checkv==check0 && t<=0);        &#125;;        return partition_point(p.begin(),p.end(),cmp)-p.begin();    &#125;    // 过凸多边形外一点求凸多边形的切线，返回切点下标    // 复杂度 O(logn)    // 必须保证点在多边形外    pair<size_t,size_t> tangent(const point<T> &a) const    &#123;        const size_t i=extreme([&](const point<T> &u)&#123;return u-a;&#125;);        const size_t j=extreme([&](const point<T> &u)&#123;return a-u;&#125;);        return &#123;i,j&#125;;    &#125;    // 求平行于给定直线的凸多边形的切线，返回切点下标    // 复杂度 O(logn)    pair<size_t,size_t> tangent(const line<T> &a) const    &#123;        const size_t i=extreme([&](...)&#123;return a.v;&#125;);        const size_t j=extreme([&](...)&#123;return -a.v;&#125;);        return &#123;i,j&#125;;    &#125;&#125;;using Convex=convex<point_t>;// 圆struct Circle&#123;    Point c;    long double r;    bool operator==(const Circle &a) const &#123;return c==a.c && abs(r-a.r)<=eps;&#125;    long double circ() const &#123;return 2*PI*r;&#125;  // 周长    long double area() const &#123;return PI*r*r;&#125;  // 面积    // 点与圆的关系    // -1 圆上 | 0 圆外 | 1 圆内    int is_in(const Point &p) const &#123;const long double d=p.dis(c); return abs(d-r)<=eps?-1:d<r-eps;&#125;    // 直线与圆关系    // 0 相离 | 1 相切 | 2 相交    int relation(const Line &l) const    &#123;        const long double d=l.dis(c);        if (d>r+eps) return 0;        if (abs(d-r)<=eps) return 1;        return 2;    &#125;    // 圆与圆关系    // -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含    int relation(const Circle &a) const    &#123;        if (*this==a) return -1;        const long double d=c.dis(a.c);        if (d>r+a.r+eps) return 0;        if (abs(d-r-a.r)<=eps) return 1;        if (abs(d-abs(r-a.r))<=eps) return 3;        if (d<abs(r-a.r)-eps) return 4;        return 2;    &#125;    // 直线与圆的交点    vector<Point> inter(const Line &l) const    &#123;        const long double d=l.dis(c);        const Point p=l.proj(c);        const int t=relation(l);        if (t==0) return vector<Point>();        if (t==1) return vector<Point>&#123;p&#125;;        const long double k=sqrt(r*r-d*d);        return vector<Point>&#123;p-(l.v/l.v.len())*k,p+(l.v/l.v.len())*k&#125;;    &#125;    // 圆与圆交点    vector<Point> inter(const Circle &a) const    &#123;        const long double d=c.dis(a.c);        const int t=relation(a);        if (t==-1 || t==0 || t==4) return vector<Point>();        Point e=a.c-c; e=e/e.len()*r;        if (t==1 || t==3)         &#123;            if (r*r+d*d-a.r*a.r>=-eps) return vector<Point>&#123;c+e&#125;;            return vector<Point>&#123;c-e&#125;;        &#125;        const long double costh=(r*r+d*d-a.r*a.r)/(2*r*d),sinth=sqrt(1-costh*costh);        return vector<Point>&#123;c+e.rot(costh,-sinth),c+e.rot(costh,sinth)&#125;;    &#125;    // 圆与圆交面积    long double inter_area(const Circle &a) const    &#123;        const long double d=c.dis(a.c);        const int t=relation(a);        if (t==-1) return area();        if (t<2) return 0;        if (t>2) return min(area(),a.area());        const long double costh1=(r*r+d*d-a.r*a.r)/(2*r*d),costh2=(a.r*a.r+d*d-r*r)/(2*a.r*d);        const long double sinth1=sqrt(1-costh1*costh1),sinth2=sqrt(1-costh2*costh2);        const long double th1=acos(costh1),th2=acos(costh2);        return r*r*(th1-costh1*sinth1)+a.r*a.r*(th2-costh2*sinth2);    &#125;    // 过圆外一点圆的切线    vector<Line> tangent(const Point &a) const    &#123;        const int t=is_in(a);        if (t==1) return vector<Line>();        if (t==-1)        &#123;            const Point v=&#123;-(a-c).y,(a-c).x&#125;;            return vector<Line>&#123;&#123;a,v&#125;&#125;;        &#125;        Point e=a-c; e=e/e.len()*r;        const long double costh=r/c.dis(a),sinth=sqrt(1-costh*costh);        const Point t1=c+e.rot(costh,-sinth),t2=c+e.rot(costh,sinth);        return vector<Line>&#123;&#123;a,t1-a&#125;,&#123;a,t2-a&#125;&#125;;    &#125;    // 两圆的公切线    vector<Line> tangent(const Circle &a) const    &#123;        const int t=relation(a);        vector<Line> lines;        if (t==-1 || t==4) return lines;        if (t==1 || t==3)        &#123;            const Point p=inter(a)[0],v=&#123;-(a.c-c).y,(a.c-c).x&#125;;            lines.push_back(&#123;p,v&#125;);        &#125;        const long double d=c.dis(a.c);        const Point e=(a.c-c)/(a.c-c).len();        if (t<=2)        &#123;            const long double costh=(r-a.r)/d,sinth=sqrt(1-costh*costh);            const Point d1=e.rot(costh,-sinth),d2=e.rot(costh,sinth);            const Point u1=c+d1*r,u2=c+d2*r,v1=a.c+d1*a.r,v2=a.c+d2*a.r;            lines.push_back(&#123;u1,v1-u1&#125;); lines.push_back(&#123;u2,v2-u2&#125;);        &#125;        if (t==0)        &#123;            const long double costh=(r+a.r)/d,sinth=sqrt(1-costh*costh);            const Point d1=e.rot(costh,-sinth),d2=e.rot(costh,sinth);            const Point u1=c+d1*r,u2=c+d2*r,v1=a.c-d1*a.r,v2=a.c-d2*a.r;            lines.push_back(&#123;u1,v1-u1&#125;); lines.push_back(&#123;u2,v2-u2&#125;);        &#125;        return lines;    &#125;    // 圆的反演    tuple<int,Circle,Line> inverse(const Line &l) const    &#123;        const Circle null_c=&#123;&#123;0.0,0.0&#125;,0.0&#125;;        const Line null_l=&#123;&#123;0.0,0.0&#125;,&#123;0.0,0.0&#125;&#125;;        if (l.toleft(c)==0) return &#123;2,null_c,l&#125;;        const Point v=l.toleft(c)==1?Point&#123;l.v.y,-l.v.x&#125;:Point&#123;-l.v.y,l.v.x&#125;;        const long double d=r*r/l.dis(c);        const Point p=c+v/v.len()*d;        return &#123;1,&#123;(c+p)/2,d/2&#125;,null_l&#125;;    &#125;        tuple<int,Circle,Line> inverse(const Circle &a) const    &#123;        const Circle null_c=&#123;&#123;0.0,0.0&#125;,0.0&#125;;        const Line null_l=&#123;&#123;0.0,0.0&#125;,&#123;0.0,0.0&#125;&#125;;        const Point v=a.c-c;        if (a.is_in(c)==-1)        &#123;            const long double d=r*r/(a.r+a.r);            const Point p=c+v/v.len()*d;            return &#123;2,null_c,&#123;p,&#123;-v.y,v.x&#125;&#125;&#125;;        &#125;        if (c==a.c) return &#123;1,&#123;c,r*r/a.r&#125;,null_l&#125;;        const long double d1=r*r/(c.dis(a.c)-a.r),d2=r*r/(c.dis(a.c)+a.r);        const Point p=c+v/v.len()*d1,q=c+v/v.len()*d2;        return &#123;1,&#123;(p+q)/2,p.dis(q)/2&#125;,null_l&#125;;    &#125;&#125;;// 圆与多边形面积交long double area_inter(const Circle &circ,const Polygon &poly)&#123;    const auto cal=[](const Circle &circ,const Point &a,const Point &b)    &#123;        if ((a-circ.c).toleft(b-circ.c)==0) return 0.0l;        const auto ina=circ.is_in(a),inb=circ.is_in(b);        const Line ab=&#123;a,b-a&#125;;        if (ina && inb) return ((a-circ.c)^(b-circ.c))/2;        if (ina && !inb)        &#123;            const auto t=circ.inter(ab);            const Point p=t.size()==1?t[0]:t[1];            const long double ans=((a-circ.c)^(p-circ.c))/2;            const long double th=(p-circ.c).ang(b-circ.c);            const long double d=circ.r*circ.r*th/2;            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d;            return ans-d;        &#125;        if (!ina && inb)        &#123;            const Point p=circ.inter(ab)[0];            const long double ans=((p-circ.c)^(b-circ.c))/2;            const long double th=(a-circ.c).ang(p-circ.c);            const long double d=circ.r*circ.r*th/2;            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d;            return ans-d;        &#125;        const auto p=circ.inter(ab);        if (p.size()==2 && Segment&#123;a,b&#125;.dis(circ.c)<=circ.r+eps)        &#123;            const long double ans=((p[0]-circ.c)^(p[1]-circ.c))/2;            const long double th1=(a-circ.c).ang(p[0]-circ.c),th2=(b-circ.c).ang(p[1]-circ.c);            const long double d1=circ.r*circ.r*th1/2,d2=circ.r*circ.r*th2/2;            if ((a-circ.c).toleft(b-circ.c)==1) return ans+d1+d2;            return ans-d1-d2;        &#125;        const long double th=(a-circ.c).ang(b-circ.c);        if ((a-circ.c).toleft(b-circ.c)==1) return circ.r*circ.r*th/2;        return -circ.r*circ.r*th/2;    &#125;;    long double ans=0;    for (size_t i=0;i<poly.p.size();i++)    &#123;        const Point a=poly.p[i],b=poly.p[poly.nxt(i)];        ans+=cal(circ,a,b);    &#125;    return ans;&#125;// 点集的凸包// Andrew 算法，复杂度 O(nlogn)Convex convexhull(vector<Point> p)&#123;    vector<Point> st;    if (p.empty()) return Convex&#123;st&#125;;    sort(p.begin(),p.end());    const auto check=[](const vector<Point> &st,const Point &u)    &#123;        const auto back1=st.back(),back2=*prev(st.end(),2);        return (back1-back2).toleft(u-back1)<=0;    &#125;;    for (const Point &u:p)    &#123;        while (st.size()>1 && check(st,u)) st.pop_back();        st.push_back(u);    &#125;    size_t k=st.size();    p.pop_back(); reverse(p.begin(),p.end());    for (const Point &u:p)    &#123;        while (st.size()>k && check(st,u)) st.pop_back();        st.push_back(u);    &#125;    st.pop_back();    return Convex&#123;st&#125;;&#125;// 半平面交// 排序增量法，复杂度 O(nlogn)// 输入与返回值都是用直线表示的半平面集合vector<Line> halfinter(vector<Line> l, const point_t lim=1e9)&#123;    const auto check=[](const Line &a,const Line &b,const Line &c)&#123;return a.toleft(b.inter(c))<0;&#125;;    // 无精度误差的方法，但注意取值范围会扩大到三次方    /*const auto check=[](const Line &a,const Line &b,const Line &c)    &#123;        const Point p=a.v*(b.v^c.v),q=b.p*(b.v^c.v)+b.v*(c.v^(b.p-c.p))-a.p*(b.v^c.v);        return p.toleft(q)<0;    &#125;;*/    l.push_back(&#123;&#123;-lim,0&#125;,&#123;0,-1&#125;&#125;); l.push_back(&#123;&#123;0,-lim&#125;,&#123;1,0&#125;&#125;);    l.push_back(&#123;&#123;lim,0&#125;,&#123;0,1&#125;&#125;); l.push_back(&#123;&#123;0,lim&#125;,&#123;-1,0&#125;&#125;);    sort(l.begin(),l.end());    deque<Line> q;    for (size_t i=0;i<l.size();i++)    &#123;        if (i>0 && l[i-1].v.toleft(l[i].v)==0 && l[i-1].v*l[i].v>eps) continue;        while (q.size()>1 && check(l[i],q.back(),q[q.size()-2])) q.pop_back();        while (q.size()>1 && check(l[i],q[0],q[1])) q.pop_front();        if (!q.empty() && q.back().v.toleft(l[i].v)<=0) return vector<Line>();        q.push_back(l[i]);    &#125;    while (q.size()>1 && check(q[0],q.back(),q[q.size()-2])) q.pop_back();    while (q.size()>1 && check(q.back(),q[0],q[1])) q.pop_front();    return vector<Line>(q.begin(),q.end());&#125;// 点集形成的最小最大三角形// 极角序扫描线，复杂度 O(n^2logn)// 最大三角形问题可以使用凸包与旋转卡壳做到 O(n^2)pair<point_t,point_t> minmax_triangle(const vector<Point> &vec)&#123;    if (vec.size()<=2) return &#123;0,0&#125;;    vector<pair<int,int>> evt;    evt.reserve(vec.size()*vec.size());    point_t maxans=0,minans=numeric_limits<point_t>::max();    for (size_t i=0;i<vec.size();i++)    &#123;        for (size_t j=0;j<vec.size();j++)        &#123;            if (i==j) continue;            if (vec[i]==vec[j]) minans=0;            else evt.push_back(&#123;i,j&#125;);        &#125;    &#125;    sort(evt.begin(),evt.end(),[&](const pair<int,int> &u,const pair<int,int> &v)    &#123;        const Point du=vec[u.second]-vec[u.first],dv=vec[v.second]-vec[v.first];        return argcmp()(&#123;du.y,-du.x&#125;,&#123;dv.y,-dv.x&#125;);    &#125;);    vector<size_t> vx(vec.size()),pos(vec.size());    for (size_t i=0;i<vec.size();i++) vx[i]=i;    sort(vx.begin(),vx.end(),[&](int x,int y)&#123;return vec[x]<vec[y];&#125;);    for (size_t i=0;i<vx.size();i++) pos[vx[i]]=i;    for (auto [u,v]:evt)    &#123;        const size_t i=pos[u],j=pos[v];        const size_t l=min(i,j),r=max(i,j);        const Point vecu=vec[u],vecv=vec[v];        if (l>0) minans=min(minans,abs((vec[vx[l-1]]-vecu)^(vec[vx[l-1]]-vecv)));        if (r<vx.size()-1) minans=min(minans,abs((vec[vx[r+1]]-vecu)^(vec[vx[r+1]]-vecv)));        maxans=max(&#123;maxans,abs((vec[vx[0]]-vecu)^(vec[vx[0]]-vecv)),abs((vec[vx.back()]-vecu)^(vec[vx.back()]-vecv))&#125;);        if (i<j) swap(vx[i],vx[j]),pos[u]=j,pos[v]=i;    &#125;    return &#123;minans,maxans&#125;;&#125;// 判断多条线段是否有交点// 扫描线，复杂度 O(nlogn)bool segs_inter(const vector<Segment> &segs)&#123;    if (segs.empty()) return false;    using seq_t=tuple<point_t,int,Segment>;    const auto seqcmp=[](const seq_t &u, const seq_t &v)    &#123;        const auto [u0,u1,u2]=u;        const auto [v0,v1,v2]=v;        if (abs(u0-v0)<=eps) return make_pair(u1,u2)<make_pair(v1,v2);        return u0<v0-eps;    &#125;;    vector<seq_t> seq;    for (auto seg:segs)    &#123;        if (seg.a.x>seg.b.x+eps) swap(seg.a,seg.b);        seq.push_back(&#123;seg.a.x,0,seg&#125;);        seq.push_back(&#123;seg.b.x,1,seg&#125;);    &#125;    sort(seq.begin(),seq.end(),seqcmp);    point_t x_now;    auto cmp=[&](const Segment &u, const Segment &v)    &#123;        if (abs(u.a.x-u.b.x)<=eps || abs(v.a.x-v.b.x)<=eps) return u.a.y<v.a.y-eps;        return ((x_now-u.a.x)*(u.b.y-u.a.y)+u.a.y*(u.b.x-u.a.x))*(v.b.x-v.a.x)<((x_now-v.a.x)*(v.b.y-v.a.y)+v.a.y*(v.b.x-v.a.x))*(u.b.x-u.a.x)-eps;    &#125;;    multiset<Segment,decltype(cmp)> s&#123;cmp&#125;;    for (const auto [x,o,seg]:seq)    &#123;        x_now=x;        const auto it=s.lower_bound(seg);        if (o==0)        &#123;            if (it!=s.end() && seg.is_inter(*it)) return true;            if (it!=s.begin() && seg.is_inter(*prev(it))) return true;            s.insert(seg);        &#125;        else        &#123;            if (next(it)!=s.end() && it!=s.begin() && (*prev(it)).is_inter(*next(it))) return true;            s.erase(it);        &#125;    &#125;    return false;&#125;// 多边形面积并// 轮廓积分，复杂度 O(n^2logn)，n为边数// ans[i] 表示被至少覆盖了 i+1 次的区域的面积vector<long double> area_union(const vector<Polygon> &polys)&#123;    const size_t siz=polys.size();    vector<vector<pair<Point,Point>>> segs(siz);    const auto check=[](const Point &u,const Segment &e)&#123;return !((u<e.a && u<e.b) || (u>e.a && u>e.b));&#125;;    auto cut_edge=[&](const Segment &e,const size_t i)    &#123;        const Line le&#123;e.a,e.b-e.a&#125;;        vector<pair<Point,int>> evt;        evt.push_back(&#123;e.a,0&#125;); evt.push_back(&#123;e.b,0&#125;);        for (size_t j=0;j<polys.size();j++)        &#123;            if (i==j) continue;            const auto &pj=polys[j];            for (size_t k=0;k<pj.p.size();k++)            &#123;                const Segment s=&#123;pj.p[k],pj.p[pj.nxt(k)]&#125;;                if (le.toleft(s.a)==0 && le.toleft(s.b)==0)                &#123;                    evt.push_back(&#123;s.a,0&#125;);                    evt.push_back(&#123;s.b,0&#125;);                &#125;                else if (s.is_inter(le))                &#123;                    const Line ls&#123;s.a,s.b-s.a&#125;;                    const Point u=le.inter(ls);                    if (le.toleft(s.a)<0 && le.toleft(s.b)>=0) evt.push_back(&#123;u,-1&#125;);                    else if (le.toleft(s.a)>=0 && le.toleft(s.b)<0) evt.push_back(&#123;u,1&#125;);                &#125;            &#125;        &#125;        sort(evt.begin(),evt.end());        if (e.a>e.b) reverse(evt.begin(),evt.end());        int sum=0;        for (size_t i=0;i<evt.size();i++)        &#123;            sum+=evt[i].second;            const Point u=evt[i].first,v=evt[i+1].first;            if (!(u==v) && check(u,e) && check(v,e)) segs[sum].push_back(&#123;u,v&#125;);            if (v==e.b) break;        &#125;    &#125;;        for (size_t i=0;i<polys.size();i++)    &#123;        const auto &pi=polys[i];        for (size_t k=0;k<pi.p.size();k++)        &#123;            const Segment ei=&#123;pi.p[k],pi.p[pi.nxt(k)]&#125;;            cut_edge(ei,i);        &#125;    &#125;    vector<long double> ans(siz);    for (size_t i=0;i<siz;i++)    &#123;        long double sum=0;        sort(segs[i].begin(),segs[i].end());        int cnt=0;        for (size_t j=0;j<segs[i].size();j++)        &#123;            if (j>0 && segs[i][j]==segs[i][j-1]) segs[i+(++cnt)].push_back(segs[i][j]);            else cnt=0,sum+=segs[i][j].first^segs[i][j].second;        &#125;        ans[i]=sum/2;    &#125;    return ans;&#125;// 圆面积并// 轮廓积分，复杂度 O(n^2logn)// ans[i] 表示被至少覆盖了 i+1 次的区域的面积vector<long double> area_union(const vector<Circle> &circs)&#123;    const size_t siz=circs.size();    using arc_t=tuple<Point,long double,long double,long double>;    vector<vector<arc_t>> arcs(siz);    const auto eq=[](const arc_t &u,const arc_t &v)    &#123;        const auto [u1,u2,u3,u4]=u;        const auto [v1,v2,v3,v4]=v;        return u1==v1 && abs(u2-v2)<=eps && abs(u3-v3)<=eps && abs(u4-v4)<=eps;    &#125;;    auto cut_circ=[&](const Circle &ci,const size_t i)    &#123;        vector<pair<long double,int>> evt;        evt.push_back(&#123;-PI,0&#125;); evt.push_back(&#123;PI,0&#125;);        int init=0;        for (size_t j=0;j<circs.size();j++)        &#123;            if (i==j) continue;            const Circle &cj=circs[j];            if (ci.r<cj.r-eps && ci.relation(cj)>=3) init++;            const auto inters=ci.inter(cj);            if (inters.size()==1) evt.push_back(&#123;atan2l((inters[0]-ci.c).y,(inters[0]-ci.c).x),0&#125;);            if (inters.size()==2)            &#123;                const Point dl=inters[0]-ci.c,dr=inters[1]-ci.c;                long double argl=atan2l(dl.y,dl.x),argr=atan2l(dr.y,dr.x);                if (abs(argl+PI)<=eps) argl=PI;                if (abs(argr+PI)<=eps) argr=PI;                if (argl>argr+eps)                &#123;                    evt.push_back(&#123;argl,1&#125;); evt.push_back(&#123;PI,-1&#125;);                    evt.push_back(&#123;-PI,1&#125;); evt.push_back(&#123;argr,-1&#125;);                &#125;                else                &#123;                    evt.push_back(&#123;argl,1&#125;);                    evt.push_back(&#123;argr,-1&#125;);                &#125;            &#125;        &#125;        sort(evt.begin(),evt.end());        int sum=init;        for (size_t i=0;i<evt.size();i++)        &#123;            sum+=evt[i].second;            if (abs(evt[i].first-evt[i+1].first)>eps) arcs[sum].push_back(&#123;ci.c,ci.r,evt[i].first,evt[i+1].first&#125;);            if (abs(evt[i+1].first-PI)<=eps) break;        &#125;    &#125;;    const auto oint=[](const arc_t &arc)    &#123;        const auto [cc,cr,l,r]=arc;        if (abs(r-l-PI-PI)<=eps) return 2.0l*PI*cr*cr;        return cr*cr*(r-l)+cc.x*cr*(sin(r)-sin(l))-cc.y*cr*(cos(r)-cos(l));    &#125;;    for (size_t i=0;i<circs.size();i++)    &#123;        const auto &ci=circs[i];        cut_circ(ci,i);    &#125;    vector<long double> ans(siz);    for (size_t i=0;i<siz;i++)    &#123;        long double sum=0;        sort(arcs[i].begin(),arcs[i].end());        int cnt=0;        for (size_t j=0;j<arcs[i].size();j++)        &#123;            if (j>0 && eq(arcs[i][j],arcs[i][j-1])) arcs[i+(++cnt)].push_back(arcs[i][j]);            else cnt=0,sum+=oint(arcs[i][j]);        &#125;        ans[i]=sum/2;    &#125;    return ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>abc274.md</title>
      <link href="/2022/10/25/abc274-md/"/>
      <url>/2022/10/25/abc274-md/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-Beginner-Contest-274-C-E"><a href="#Atcoder-Beginner-Contest-274-C-E" class="headerlink" title="Atcoder Beginner Contest 274 ( C - E )"></a>Atcoder Beginner Contest 274 ( C - E )</h1><h2 id="C-Ameba"><a href="#C-Ameba" class="headerlink" title="C - Ameba"></a>C - Ameba</h2><p><strong>题目大意:</strong> 刚开始有一个生物序号为$1$，有$n$次记录，在第$i$次记录中第$a_i$个生物消失会生成第$2i$和$2i+1$个生物，问对于生物从$1$到$2N+1$他们距离$1$有多少代</p><p><strong>解题思路:</strong> 按照题意模拟即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    for(int i = 1;i <= n;++i) cin >> a[i];    for(int i = 1;i <= n;++i)    &#123;        int to1 = i * 2;        int to2 = i * 2 + 1;        dis[to1] = dis[to2] = dis[a[i]] + 1;    &#125;    for(int i = 1;i <= 2 * n + 1;++i)    &#123;        cout << dis[i] << "\n";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Robot-Arms-2"><a href="#D-Robot-Arms-2" class="headerlink" title="D - Robot Arms 2"></a>D - Robot Arms 2</h2><p><strong>题目大意:</strong> 给定一个长度为$n$的序列以及$x,y$,问是否存在$n + 1$个点$p_1,p_2,…,p_n,p_{n + 1}$在二维坐标系中满足$p_1 &#x3D; (0,0),p_2 &#x3D; (a_1,0),p_{n + 1} &#x3D; (x,y)$相邻两个点距离是$a_i$并且是$90$度</p><p><strong>解题思路:</strong> 分析后发现实际上$x$和$y$是相互不干扰的，那么我们可以分开来处理，注意到$a$的范围很小那么我们可以枚举遍历到的数值是多少</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long long// typedef long long ll;const int maxn = 4e5 + 10;int n,x,y;int a[maxn],dis[maxn];int dp[2][maxn],pre[2][maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> x >> y;    for(int i = 1;i <= n;++i) cin >> a[i];    int midp = 10000;    pre[1][midp + a[1]] = 1;    pre[0][midp] = 1;    for(int i = 2;i <= n;++i)    &#123;        int now = i & 1;        for(int j = 0;j <= 20000;++j)        &#123;            if(pre[now][j])            &#123;                dp[now][j + a[i]] = 1;                if(j - a[i] >= 0) dp[now][j - a[i]] = 1;                // cout << "?? now-> " << now << " " << j << "\n";            &#125;        &#125;        for(int j = 0;j <= 20000;++j) pre[now][j] = dp[now][j],dp[now][j] = 0;    &#125;    if(pre[1][midp + x] && pre[0][midp + y]) cout << "Yes\n";    else cout << "No\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Booster"><a href="#E-Booster" class="headerlink" title="E - Booster"></a>E - Booster</h2><p><strong>题目大意:</strong> 给定一个二维平面其中有$n$个城镇和$m$个加速点$(1 \leq n + m \leq 17)$，初始点在$(0,0)$，问必须经理过所有城镇点需要的时间最短是多少，没必要经过所有加速点但是我们每经过一次加速点我们当前的速度就会翻倍</p><p><strong>解题思路:</strong> 看到题目数据的时候我们就会自然而然的考虑到状态压缩，如何存在当前的状态呢？我们可以用$dp[i][j]$来表示$i$的二进制位状态表示经过了哪些点，然后末尾点是$j$</p><p>那么我们思考转移的过程，假设我们当前位置$j$存在$1$,并且当前$k$也是$1$</p><p>那么我们可以从$k$点转移到$j$点，那么相对应的方程就是$dp[i][j] &#x3D; min(dp[i][j],dp[i - (1 &lt;&lt; j)][k] + d &#x2F; v)$</p><p>然后我们可以在最后枚举从哪个点最后来以及最后的状态获得答案</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;double dp[1 << 18][20];pair<double,double> p[20];double getdis(int i,int j)&#123;    return sqrt((p[i].first - p[j].first) * (p[i].first - p[j].first) + (p[i].second - p[j].second) * (p[i].second - p[j].second));&#125;int n,m;int countx(int x)&#123;    int now = 0;    for(int i = n;i < n + m;++i)    &#123;        if(x >> i & 1) now++;    &#125;    return now;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m;    p[0] = &#123;0,0&#125;;    n++;    for(int i = 1;i < n + m;++i)    &#123;        cin >> p[i].first >> p[i].second;    &#125;    for(int i = 0;i < (1 << (n + m));++i)    &#123;        for(int j = 0;j < n + m;++j) dp[i][j] = 1e18;    &#125;    dp[1][0] = 0;    cout << fixed << setprecision(10);    for(int i = 0;i < (1 << (n + m));++i)    &#123;        for(int j = 0;j < (n + m);++j)        &#123;            if(i >> j & 1)            &#123;                for(int k = 0;k < (n + m);++k)                &#123;                    if((i - (1 << j)) >> k & 1)                    &#123;                        double d = getdis(j,k);                        int nowcnt = countx(i - (1 << j));                        int v = (1 << nowcnt);                        dp[i][j] = min(dp[i][j],dp[i - (1 << j)][k] + d / (1.0 * v));                    &#125;                &#125;            &#125;        &#125;    &#125;    double ans = 1e18;    for(int i = (1 << n) - 1;i < (1 << (n + m));i += (1 << n))    &#123;        for(int j = 0;j < n + m;++j)        &#123;            double d = getdis(0,j);            int v = 1 << countx(i);            ans = min(ans,dp[i][j] + d / (1.0 * v));        &#125;    &#125;    cout << fixed << setprecision(10) << ans << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> abc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 825 A-C1 D</title>
      <link href="/2022/10/11/cf825/"/>
      <url>/2022/10/11/cf825/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-825-Div-2-A-C1-D"><a href="#Codeforces-Round-825-Div-2-A-C1-D" class="headerlink" title="Codeforces Round #825 (Div. 2) A-C1 D"></a>Codeforces Round #825 (Div. 2) A-C1 D</h1><h2 id="A-Make-A-Equal-to-B"><a href="#A-Make-A-Equal-to-B" class="headerlink" title="A. Make A Equal to B"></a>A. Make A Equal to B</h2><p><strong>题目大意:</strong>  给定两个$01$序列$a$,$b$长度为$n(1\leq n\leq 1e2)$，现在有两种操作，第一种操作是选择一个位置进行反转，第二个操作是任意排序$a$序列，问最少需要几次操作能让序列$a$等于序列$b$</p><p><strong>解题思路:</strong> 首先我们先思考一下，我们刚开始一定要让序列$a$和$b$中的$01$个数相同，然后在这个前提下，如果两个序列在增加$1$的过程中相同了，就不进行二操作，否则就进行二操作。如何判断两个序列是否在过程中就相同了呢？我们可以考虑将序列中的$0$变成$1$，然后看哪个序列中原本的$1$多，如果$b$中多就变$a$，$a$中多实际上就是变$b$</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        int na,nb;        na = nb = 0;        cin >> n;        for(int i = 1;i <= n;++i)        &#123;            cin >> a[i];            if(a[i]) na++;        &#125;        for(int i = 1;i <= n;++i)        &#123;            cin >> b[i];            if(b[i]) nb++;        &#125;        int f = 1;        int ck = 0;        if(na > nb) ck = 1;        if(na < nb)        &#123;            for(int i = 1;i <= n;++i)            &#123;                if(!a[i]) continue;                if(a[i] != b[i]) f = 0;            &#125;        &#125;        else        &#123;            for(int i = 1;i <= n;++i)            &#123;                if(!b[i]) continue;                if(a[i] != b[i]) f = 0;            &#125;        &#125;        cout << abs(na - nb) + (1 - f) << "\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Playing-with-GCD"><a href="#B-Playing-with-GCD" class="headerlink" title="B. Playing with GCD"></a>B. Playing with GCD</h2><p><strong>题目大意:</strong> 给定一个长度为$n(1\leq n \leq 2e5)$的序列，问是否存在一个长度为$n + 1$的序列$b$，满足$a_i &#x3D; gcd(b_i,b_{i + 1})$</p><p><strong>解题思路:</strong> 观察样例可得我们可以对原序列中的$a_{i - 1}$,$a_i$和$a_{i + 1}$进行分析，这三个数字分别由$b_{i - 1}$,$b_i$,$b_{i + 1}$,$b_{i + 2}$</p><p>考虑$b_i$和$b_{i + 1}$实际上还在$a_{i - 1}$和$a_{i + 1}$中，我们考虑$gcd$的性质实际上是去求若干个数字的质因子取$min$</p><p>那么我们可以对$a_{i- 1}$和$a_{i + 1}$取$gcd$，如果$a_i$不能和他们的$gcd$取余获得$0$的话，那么实际上就是不可以的，说明还有其他的质因子存在</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        for(int i = 1;i <= n;++i) cin >> a[i];        int f = 1;        for(int i = 2;i <= n - 1;++i)        &#123;            int gd = __gcd(a[i - 1],a[i + 1]);            if(a[i] % gd) f = 0;        &#125;        if(f) cout << "YES\n";        else cout << "NO\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C1-Good-Subarrays-Easy-Version"><a href="#C1-Good-Subarrays-Easy-Version" class="headerlink" title="C1. Good Subarrays (Easy Version)"></a>C1. Good Subarrays (Easy Version)</h2><p><strong>题目大意:</strong> 给定一个长度为$n(1\leq n \leq 2e5)$的序列，找出这个序列中有多少个序列满足好序列，好序列的要求是对于一段序列第$i$个元素大于等于$i$</p><p><strong>解题思路:</strong> 固定左端点取计算右端点在哪里。我们可以发现这样一件事情，如果我在当前这个位置$i$右端点到达$j$,那么我到$i + 1$的话，我可以继续从$j$往右边移动，满足双指针的性质，直接写就可以。</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        for(int i = 1;i <= n;++i) cin >> a[i];        int ans = 0;        int j = 1;        int now = 1;        for(int i = 1;i <= n;++i)        &#123;            if(j < i)            &#123;                j = i;                now = 1;            &#125;            while(a[j] >= now && j <= n)            &#123;                // cout << "i -> "<< i << " " << j << " " << now<< "\n";                j++;                now++;            &#125;            j--,now--;            int num = j - i + 1;            ans += num;            now--;            // cout << i << " " << j << "\n";        &#125;        cout << ans << "\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Equal-Binary-Subsequences"><a href="#D-Equal-Binary-Subsequences" class="headerlink" title="D. Equal Binary Subsequences"></a>D. Equal Binary Subsequences</h2><p><strong>题目大意:</strong> 给定一个长度为$2n(1\leq n \leq 1e5)$的$01$串，可以进行以下的操作一次，选择一个子序列，并且把这个子序列中的数字往前移动一个，如果是第一个就移动到最后一个，问是否能够将这个$01$串分割成两个子序列，使得这两个子序列相同</p><p><strong>解题思路:</strong> 首先我们先考虑无法构成的情况，如果$0$的个数或者$1$的个数是奇数，那么这个序列肯定就无法构成</p><p>做一个大胆的猜想，假设目前剩下的情况下所有情况都是有解的，那么剩下的串可能是由若干个$00$ $01$ $10$ $11$组成的</p><p>我们从前往后对于一个子序列来说$00$和$11$肯定是可以直接放进去的，那么对于$01$和$10$呢？</p><p>我们可以考虑把他们放到操作里面去变换，那么实际上我们只需要把奇数位置上面的$1$放到偶数位置上去，把偶数位置上面的$1$放到奇数位置上去</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        cin >> str;        str = " " + str;        int num = 0;        n <<= 1;        for(int i = 1;i <= n;++i)        &#123;            num += (str[i] == '1');        &#125;        if(num & 1)        &#123;            cout << -1 << "\n";            continue;        &#125;        vector<int> pos;        for(int i = 1;i <= n;i += 2)        &#123;            if(str[i] == str[i + 1]) continue;            pos.push_back(i);        &#125;        vector<int> ans;        for(int i = 0;i < pos.size();++i)        &#123;            int now = pos[i];            if((i & 1) == str[now] - '0')            &#123;                ans.push_back(now);            &#125;            else ans.push_back(now + 1);        &#125;        cout << ans.size() << "\n";        for(auto to:ans)        &#123;            cout << to << " ";        &#125;        cout << "\n";        for(int i = 1;i <= n;i += 2) cout << i << " \n"[i == n - 1];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DailyTraing</title>
      <link href="/2022/10/09/DailyTraing/"/>
      <url>/2022/10/09/DailyTraing/</url>
      
        <content type="html"><![CDATA[<h1 id="每日思维题"><a href="#每日思维题" class="headerlink" title="每日思维题"></a>每日思维题</h1><h2 id="Graph-and-String"><a href="#Graph-and-String" class="headerlink" title="Graph and String"></a>Graph and String</h2><p><a href="https://codeforces.com/contest/623/problem/A">Problem - A - Codeforces</a></p><p>题目大意：</p><p>给出一个由字符串s<em>s</em>建图的过程。</p><ul><li>字符仅有$a,b,c$三种，建出的图中第$i$个顶点表示原来的第$i$个字符。</li><li>$i$与$j$有连边，当且仅当$s[i]$与$s[j]$相同或$s[i]$和$s[j]$是相邻的字符（$a$与$b$相邻，$b$与$c$相邻）</li></ul><p>现给出由某个字符串$s$建出的图，构造一个字符串使其符合上面的要求要求，或者回答不存在这样的字符串。</p><p>解题思路：首先分析题目可以发现这样一件事情，对于出现的$b$来说他是需要连接所有点的，$a$只需要连接相邻的$a$以及$b$即可，$c$的话和$a$同理，那么其实这样子的话我们可以在刚开始的时候处理以下所有和其他点连接的点，赋值为$b$，然后我们可以考虑一件事情，对于$a$和$c$来说相对应的边是不相连的，那么对于原图的补图来说一定是一张二分图，然后我们可以判断二分图并且染色之后再去根据颜色判断，如果两个相邻的边是$a$以及$c$那么就是不行的</p><pre class="line-numbers language-line-numbers language-C++"><code class="language-line-numbers language-C++">#include <bits/stdc++.h>using namespace std;const int maxn = 5e2 + 10;int mp[maxn][maxn],n,m;int deg[maxn],col[maxn];char ans[maxn];vector<int> edge[maxn];int flag = 1;void dfs(int s,int fa)&#123;    for(auto to:edge[s])    &#123;        if(to == fa) continue;        if(col[to] == -1)        &#123;            col[to] = col[s] ^ 1;            dfs(to,s);        &#125;        else if(col[to] == col[s]) flag = 0;    &#125;&#125;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m;    for(int i = 1;i <= n;++i) mp[i][i] = 1,col[i] = -1;    for(int i = 1,u,v;i <= m;++i)    &#123;        cin >> u >> v;        mp[u][v] = mp[v][u] = 1;        deg[u]++;        deg[v]++;    &#125;    for(int i = 1;i <= n;++i)    &#123;        for(int j = i + 1;j <= n;++j)        &#123;            if(mp[i][j]) continue;            edge[i].emplace_back(j);            edge[j].emplace_back(i);        &#125;    &#125;    for(int i = 1;i <= n;++i)    &#123;        if(deg[i] == n - 1) ans[i] = 'b';        else        &#123;            if(col[i] == -1) col[i] = 0,dfs(i,0);        &#125;    &#125;    if(!flag)    &#123;        cout << "No\n";        return 0;    &#125;    for(int i = 1;i <= n;++i)    &#123;        for(int j = i + 1;j <= n;++j)        &#123;            if(mp[i][j] && col[i] + col[j] == 1)            &#123;                cout << "No\n";                return 0;            &#125;        &#125;    &#125;    cout << "Yes\n";    for(int i = 1;i <= n;++i)    &#123;        if(deg[i] == n - 1)        &#123;            cout << "b";        &#125;        else if(col[i] == 0) cout << "a";        else cout << "c";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Carousel"><a href="#Carousel" class="headerlink" title="Carousel"></a>Carousel</h2><p><a href="https://www.luogu.com.cn/problem/CF1328D">CF1328D Carousel - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a> </p><p><strong>题目大意:</strong> 有$q$组询问,每组询问如下:</p><p>已知一个有$n(3\le n\le 2<em>10^5)$个点的*<em>环</em></em>,点$i$的类型为$a_i$,现在需要给每个点进行染色,要求<strong>相邻</strong>不同类型的点的颜色不同且所用颜色数最小.输出颜色数及一种染色方案即可.(颜色从1开始)</p><p>注意: $n ≤2*10^5$</p><p><strong>解题思路:</strong></p><p>其实很容易想到环的颜色种类不多，至多只有$3$</p><p>那么我们可以进行这样子的讨论，首先我们可以把这个环分成奇环和偶环，对于偶环来说他有比较好的性质我们直接赋值$1$ $2$交替即可</p><p>那奇环呢？分析样例我们可以得出对于两两之间不一样的都是$3$种，反之就是$2$种</p><p>同时我们需要特判以下情况，在这个序列中只存在$1$种或者$2$种数字的情况</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;const int maxn = 2e5 + 10;int a[maxn],num[maxn],n;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        int cnt = 0;        for(int i = 1;i <= n;++i)        &#123;            cin >> a[i];            num[a[i]]++;            if(num[a[i]] == 1) cnt++;        &#125;        if(cnt == 1)        &#123;            cout << "1\n";            for(int i = 1;i <= n;++i)            &#123;                cout << "1 ";            &#125;            cout << "\n";        &#125;        else if(cnt == 2)        &#123;            cout << 2 << "\n";            for(int i = 1;i <= n;++i)            &#123;                if(a[i] == a[1]) cout << "1 ";                else cout << "2 ";            &#125;            cout << "\n";        &#125;        else if(n % 2 == 0)        &#123;            cout << 2 << "\n";            for(int i = 1;i <= n;++i)            &#123;                cout << (i & 1)  + 1<< " ";            &#125;            cout << "\n";        &#125;        else        &#123;            int flag = -1;            for(int i = 1;i <= n - 1;++i)            &#123;                if(a[i] == a[i + 1]) flag = i;            &#125;            if(a[n] == a[1]) flag = n;            if(flag == -1)            &#123;                cout << "3\n";                for(int i = 1;i <= n - 1;++i)                &#123;                    cout << (i & 1) + 1 << " ";                 &#125;                cout << "3\n";            &#125;            else            &#123;                cout << "2\n";                for(int i = 1;i <= flag;++i)                &#123;                    if(i % 2) cout << 1 << " ";                    else cout << 2 << " ";                &#125;                for(int i = flag + 1;i <= n;++i)                &#123;                    if(i % 2) cout << 2 << " ";                    else cout << 1 << " ";                &#125;                cout << "\n";            &#125;        &#125;        for(int i = 1;i <= n;++i) num[a[i]] = 0;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="What-a-Colorful-Wall"><a href="#What-a-Colorful-Wall" class="headerlink" title="What a Colorful Wall"></a>What a Colorful Wall</h2><p><a href="https://codeforces.com/group/MKpYqfAQQQ/contest/393177/problem/F">Problem - F - Codeforces</a></p><p><strong>题目大意:</strong> 给定$n$个矩形，每个矩形有一定的颜色，矩形之间可以相互覆盖，问在$n$个矩形覆盖之后整个坐标系中最多存在着多少种颜色</p><p><strong>解题思路:</strong> 首先先思考这样子的一件事情，因为矩形具有覆盖性，因此我们可以从后往前去放置矩形，因为后面的矩形总是不会被前面的矩形所覆盖，首先对于相同的$x$坐标的一个区域来说，如果一个矩形的高度小于另外一个的高度并且它的，那么它在这个$x$轴影响的$y$上面是被覆盖的，那么对于其他的$x$呢？我们可以利用一个类似于扫描线的做法，遍历相对应的$x$轴遍历过去即可，然后用并查集维护相对应的$y$是否已经是在同一条线上面</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;const int maxn = 4e3 + 10;int fa[maxn * 2],n,ans[maxn];vector<int> posx,posy;vector<array<int,5>> pos;void init()&#123;    for(int i = 0;i <= 8010;++i) fa[i] = i;&#125;int getf(int x)&#123;    if(x == fa[x]) return x;    fa[x] = getf(fa[x]);    return fa[x];&#125;void merge(int x,int y)&#123;    x = getf(x);    y = getf(y);    fa[x] = y;&#125;int getx(int x)&#123;    int px = lower_bound(posx.begin(),posx.end(),x) - posx.begin();    return px;&#125;int gety(int y)&#123;    int py = lower_bound(posy.begin(),posy.end(),y) - posy.begin();    return py;&#125;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    for(int i = 1,x1,y1,x2,y2,col;i <= n;++i)    &#123;        cin >> x1 >> y1 >> x2 >> y2 >> col;        posx.push_back(x1),posx.push_back(x2);        posy.push_back(y1),posy.push_back(y2);        pos.push_back(&#123;x1,y1,x2,y2,col&#125;);    &#125;    sort(posx.begin(),posx.end());    sort(posy.begin(),posy.end());    posx.erase(unique(posx.begin(),posx.end()),posx.end());    posy.erase(unique(posy.begin(),posy.end()),posy.end());    for(auto &now:pos)    &#123;        now[0] = getx(now[0]),now[2] = getx(now[2]);        now[1] = gety(now[1]),now[3] = gety(now[3]);         // cout << now[0] << " "    &#125;    int tot = posx.size();    for(int i = 0;i <= tot;++i)    &#123;        init();        for(int j = n - 1;j >= 0;--j)        &#123;            auto now = pos[j];            if(now[0] <= i && now[2] > i)            &#123;                int ny = getf(now[1]);                while(ny > now[3])                &#123;                    merge(ny,ny - 1);                    ans[now[4]] = 1;                    ny = getf(ny);                &#125;            &#125;        &#125;    &#125;    int res = 0;    for(int i = 1;i <= n;++i) res += ans[i];    cout << res << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Chemical-table"><a href="#Chemical-table" class="headerlink" title="Chemical table"></a>Chemical table</h2><p><a href="https://codeforces.com/contest/1013/problem/D">Problem - D - Codeforces</a></p><p><strong>题意:</strong> 给定一个$n * m$的棋盘，给定$q$个元素，这些元素在棋盘的上面，如果对于一个$2 * 2$的矩形来说，这个矩形中的三个值都存在但是还有一个值不存在，那么这个值也会自动生成，问最多要加多少个值才能使得这个棋盘最后是满的</p><p><strong>解题思路:</strong> 首先我们先分析最后的棋盘的状态，最后棋盘的状态是一个满的形式，对于棋盘来说我们可以把它看成一个二分图的形式，左边是列右边是行，然后我们去分析最终态，最终态是行和列的点都在一个连通块中；然后我们分析题目给定的条件，每次对于一个行和列连边，然后对于生成那个新点来说，实际上并不会影响当前连通块的情况，那么我们只需要连接所有的边，然后找出连通块的数量是多少，最后再加上相对应的边即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;const int maxn = 4e5 + 10;int f[maxn],n,m,q;int getf(int x)&#123;    return x == f[x] ? x : f[x] = getf(f[x]);&#125;void merge(int x,int y)&#123;    x = getf(x);    y = getf(y);    f[x] = y;&#125;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m >> q;    for(int i = 1;i <= n + m;++i)    &#123;        f[i] = i;    &#125;    for(int i = 1,x,y;i <= q;++i)    &#123;        cin >> x >> y;        merge(x,y + n);    &#125;    int ans = 0;    for(int i = 1;i <= n + m;++i)    &#123;        if(getf(i) == i)        &#123;            ans++;        &#125;    &#125;    cout << ans - 1 << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Cross-Swapping"><a href="#Cross-Swapping" class="headerlink" title="Cross Swapping"></a>Cross Swapping</h2><p><a href="https://codeforces.com/contest/1713/problem/E">Problem - E - Codeforces</a></p><p><strong>题意:</strong> 给定一个$n * n$的矩阵，可以选定一个$k$，交换所有的$mp[i][k]$和$mp[k][i]$，可以进行这样子的操作若干次，问在进行操作<br>之后这个矩阵字典序最小是什么样子的<br><strong>解题思路:</strong> 模拟每一次交换的过程，我们发现实际上$mp[i][j]$只会和$mp[j][i]$交换，既然这样那么实际上我们就很好去操作了<br>如果我们要交换$mp[i][j]$和$mp[j][i]$，我们只需要选定$k &#x3D; i$ $or$ $k &#x3D; j$,如果不交换我们可以两个都不选或者两个都选偶数次<br>然后的话我们可以用并查集来维护相对应的关系，用类似于敌人朋友的并查集来维护这个东西。</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;const int maxn = 2e3 + 10;int mp[maxn][maxn],n;int f[maxn];int getf(int x)&#123;    return x == f[x] ? x : f[x] = getf(f[x]);&#125;void merge(int x,int y)&#123;    x = getf(x);    y = getf(y);    f[x] = y;&#125;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        for(int i = 1;i <= n;++i)        &#123;            for(int j = 1;j <= n;++j)            &#123;                cin >> mp[i][j];            &#125;        &#125;        for(int i = 1;i <= 2 * n;++i) f[i] = i;        for(int i = 1;i <= n;++i)        &#123;            for(int j = i;j <= n;++j)            &#123;                if(mp[i][j] < mp[j][i])                &#123;                    //not change                    if(getf(i) == getf(j + n)) continue;                    merge(i,j),merge(i + n,j + n);                &#125;                else if(mp[i][j] > mp[j][i])                &#123;                    //change                    if(getf(i) == getf(j)) continue;                    merge(i,j + n),merge(i + n,j);                &#125;            &#125;        &#125;        for(int k = 1;k <= n;++k)        &#123;            if(getf(k) > n) continue;            for(int i = 1;i <= n;++i)            &#123;                swap(mp[i][k],mp[k][i]);            &#125;        &#125;        for(int i = 1;i <= n;++i)        &#123;            for(int j = 1;j <= n;++j)            &#123;                cout << mp[i][j] << " \n"[j == n];            &#125;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Mikasa"><a href="#Mikasa" class="headerlink" title="Mikasa"></a>Mikasa</h2><p><a href="https://codeforces.com/contest/1554/problem/C">Problem - C - Codeforces</a></p><p><strong>题意:</strong> 给定$T$组数据，每组数据有一个$n$和$m$,给定一个序列从$n \bigoplus 0,n \bigoplus 1,…,n \bigoplus m$问这个序列中没有出现过的最小数字是多少</p><p><strong>解题思路:</strong> 考虑再这个序列中出现过的数字$k$,那么存在$x$使得式子$n \bigoplus x &#x3D; k,x ∈ [0,m]$成立,那么对于上面的式子其实可以等价于$n \bigoplus k &#x3D; x, 0 \leq n \bigoplus k \leq m$，那么我们要求的答案也就是去找一个最小的$k$使得$n \bigoplus k \geq m + 1$，那么这样子的话我们就可以进行按位考虑，假设$p &#x3D; m + 1$,我们从高位开始考虑，如果这个位置上面$n_i &#x3D; 1,p_i &#x3D; 0$,那么直接break掉，如果$n_i &#x3D; 0,p_i &#x3D; 1$,则需要加上这一位的贡献</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;#define int long longint n,m;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n >> m;        int p = m + 1;        int ans = 0;        for(int i = 30;i >= 0;--i)        &#123;            int ni = (n >> i & 1);            int pi = (p >> i & 1);            if(ni == 1 && pi == 0) break;            if(ni == 0 && pi == 1) ans += (1 << i);        &#125;        cout << ans << "\n";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Count-Triangles"><a href="#Count-Triangles" class="headerlink" title="Count Triangles"></a>Count Triangles</h2><p><a href="https://codeforces.com/problemset/problem/1355/C">Problem - 1355C - Codeforces</a></p><p><strong>题意:</strong> 给定四个数字$A,B,C,D$使得三角形的三个边$a,b,c$分别满足$A \leq a \leq B, B\leq b \leq C,C \leq c \leq D$,问这样子的三元组$a,b,c$有多少</p><p><strong>解题思路:</strong> 其实拿到题目的时候我们可以直接考虑枚举，但是直接分别枚举$a,b$是否在区间里面时间肯定是有点问题的，但是既然是三角形我们其实如果知道$a + b$是多少我们就能找到对应的第三条边是多少，既然这样的话那么我们只需要枚举$a + b$中有多少个就可以了，然后通过差分数组去维护相对应的数量，那么对应的$a + b$在数据范围中对应的第三条边可能是啥呢？其实是在一个范围中，我们在$a + b - C$和$D + C - 1$中取小的就可以了，当然需要特判一下$a + b - C$小于$0$的情况</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;#define int long longtypedef long long ll;vector<int> pa,pb,pc;int A,B,C,D;const int maxn = 2e6 + 10;int sum[maxn];signed  main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> A >> B >> C >> D;    for(int i = A;i <= B;++i) sum[i + B]++,sum[i + C + 1]--;    for(int i = 1;i <= 3 * D;++i) sum[i] += sum[i - 1];    int ans = 0;    for(int i = 1;i <= 3 * D;++i)    &#123;        ans += sum[i] * max(0ll,min(i - C,D - C + 1));    &#125;    cout << ans << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Integers-Have-Friends"><a href="#Integers-Have-Friends" class="headerlink" title="Integers Have Friends"></a>Integers Have Friends</h2><p><a href="https://codeforces.com/problemset/problem/1548/B">Problem - 1548B - Codeforces</a></p><p><strong>题意:</strong> 给定一个长度为$n$的序列，序列中每个元素的数值各不相同，找一个最长的子序列使得这个子序列中$mod $ $m$都是相同的数字</p><p><strong>解题思路:</strong> 因为题目中需要找到$a[i]$  $mod$ $m$ $&#x3D;$ $a[j]$ $mod$ $m$,那么对于这样子的式子我们可以先进行一个化简，那么就是$(a[i] - a[j])  $ $ mod $</p><p> $m &#x3D; 0$,然后我们可以对这个序列进行一个处理，处理之后二分找最长的即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;#define int long longtypedef long long ll;const int maxn = 2e5 + 10;int a[maxn],n;int b[maxn],tree[maxn << 2];inline void build(int k,int l,int r)&#123;    if(l == r)    &#123;        tree[k] = b[l];        return;    &#125;    int mid = (l + r) >> 1;    build(k << 1,l,mid);    build(k << 1 | 1,mid + 1,r);    tree[k] = __gcd(tree[k << 1],tree[k << 1 | 1]);    return;&#125;inline int query(int k,int l,int r,int lx,int rx)&#123;    if(l == lx && r == rx)    &#123;        return tree[k];    &#125;    int mid = (l + r) >> 1;    int ans = 0;    if(rx <= mid) ans = __gcd(ans,query(k << 1,l,mid,lx,rx));    else    &#123;        if(lx > mid) ans = __gcd(ans,query(k << 1 | 1,mid + 1,r,lx,rx));        else ans =__gcd(ans,__gcd(query(k << 1,l,mid,lx,mid),query(k << 1 | 1,mid + 1,r,mid + 1,rx)));    &#125;    return ans;&#125;int check(int x)&#123;    for(int i = 1;i <= n;++i)    &#123;        if(i + x - 1 > n) break;        if(abs(query(1,1,n,i + 1,i + x - 1)) != 1)        &#123;            return 1;        &#125;    &#125;    return 0;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        for(int i = 1;i <= n;++i)        &#123;            cin >> a[i];        &#125;        for(int i = 1;i <= n;++i)        &#123;            b[i] = a[i] - a[i - 1];        &#125;        build(1,1,n);        int ans = 1;        int L = 2;        int R = n;        while(L <= R)        &#123;            int mid = (L + R) >> 1;            if(check(mid))            &#123;                L = mid + 1;                ans = max(ans,mid);            &#125;            else            &#123;                R = mid - 1;            &#125;        &#125;        cout << ans<< "\n";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Distance-in-Tree"><a href="#Distance-in-Tree" class="headerlink" title="Distance in Tree"></a>Distance in Tree</h2><p><a href="https://codeforces.com/contest/161/problem/D">Problem - D - Codeforces</a></p><p><strong>题意:</strong> 给定一棵$n$个结点的树，需要找出这个树上面距离严格为$k$的点对有多少个<br><strong>解题思路:</strong> 拿到题目之后看$k$的范围实际上不大，有$500$左右，那么其实$nk$时间复杂度的算法是可以过的<br>那么接下来去思考如何用$nk$的时间复杂度去求<br>那么我们可以考虑这样子的一件事情，假设我们已经知道当前这里的一个点距离它距离为$x$的点都已知道<br>那么对于答案的贡献实际上可以是$ans +&#x3D; dp[now][i] * dp[to][k - i - 1]$<br>然后我们再更新相对应的数量即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;#define int long longconst int maxn = 5e4 + 10;int dp[maxn][520];int n,ans,k;vector<int> edge[maxn];void dfs(int s,int fa)&#123;    dp[s][0] = 1;    for(auto to:edge[s])    &#123;        if(to == fa) continue;        dfs(to,s);        for(int i = 0;i < k;++i) ans += dp[s][i] * dp[to][k - i - 1];        for(int i = 0;i < k;++i) dp[s][i + 1] += dp[to][i];    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> k;    for(int i = 1,u,v;i <= n - 1;++i)    &#123;        cin >> u >> v;        edge[u].emplace_back(v);        edge[v].emplace_back(u);    &#125;    dfs(1,0);    cout << ans << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="The-Sports-Festival"><a href="#The-Sports-Festival" class="headerlink" title="The Sports Festival"></a>The Sports Festival</h2><p><a href="https://codeforces.com/problemset/problem/1509/C">Problem - 1509C - Codeforces</a></p><h2 id="Three-Bags"><a href="#Three-Bags" class="headerlink" title="Three Bags"></a>Three Bags</h2><p><a href="https://codeforces.com/problemset/problem/1467/C">Problem - 1467C - Codeforces</a></p><p><strong>题目大意:</strong> 给定$3$个集合，可以选定任意两个集合中的元素$a,b$,移走$b$并且让$a$变成$a - b$</p><p>问最后剩下的元素最大值是多少</p><p><strong>解题思路:</strong> 首先考虑如果在没有集合限制的情况下，其实我们进行这样子的操作就会使得一个数字没有取到，那么其实对应到集合来说，就是两个不同集合的数字的最小值没有取到是最优的；还有一种取法，就是另外两个集合全部取完，还有一个集合全部不取</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;#define int long longconst int maxn = 1e6 + 10;int n,m,k;int sum;int a[maxn],b[maxn],c[maxn],sa,sb,sc;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m >> k;    int ma,mb,mc;    ma = mb = mc = 1e9 + 7;    for(int i = 1;i <= n;++i)    &#123;        cin >> a[i];        sum += a[i];        sa += a[i];        ma = min(ma,a[i]);    &#125;    for(int i = 1;i <= m;++i)    &#123;        cin >> b[i];        sum += b[i];        sb += b[i];        mb = min(mb,b[i]);    &#125;    for(int i = 1;i <= k;++i)    &#123;        cin >> c[i];        sum += c[i];        sc += c[i];        mc = min(mc,c[i]);    &#125;    int ans = max(&#123;sum - 2 * (ma + mb),sum - 2 * (mb + mc),sum - 2 * (mc + ma),sum - 2 * sa,sum - 2 * sb,sum - 2 * sc&#125;);    cout << ans << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dr-Evil-Underscores"><a href="#Dr-Evil-Underscores" class="headerlink" title="Dr. Evil Underscores"></a>Dr. Evil Underscores</h2><p><a href="https://codeforces.com/contest/1285/problem/D">Problem - D - Codeforces</a></p><p><strong>题意:</strong> 给定$n$个数字，需要找到一个数字$x$使得这些数字$\bigoplus x$的最大值最小</p><p><strong>解题思路:</strong> 拿到题目之后我们可以想到拆位去思考，首先我们考虑这样子的一件事情，对于高位来说肯定是能消掉尽可能消掉，不能消掉再看接下来这个高位所带来的影响，然后对于一位来说，如果这一位在所有数字上面都是相同的，那么其实它就可以最后消掉；如果有存在不相同的，对于最终答案来说这一位肯定是取$1$的，但是对于后面的位数还是不确定什么是更优的，因此还是需要找下去</p><p>所以我们可以建立一棵$tire$树，在$tire$树上面跑$dfs$即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;const int maxn = 2e6 + 10;int tire[maxn][2],cnt,n;void insert(int x)&#123;    int root = 0;    for(int i = 30;i >= 0;--i)    &#123;        int id = (x >> i & 1);        if(!tire[root][id]) tire[root][id] = ++cnt;        root = tire[root][id];    &#125;&#125;int dfs(int pos,int now)&#123;    if(now < 0) return 0;    int ans = 0;    if(tire[pos][0] && tire[pos][1])    &#123;        ans += (1 << now);        ans += min(dfs(tire[pos][0],now - 1),dfs(tire[pos][1],now - 1));     &#125;    else if(tire[pos][0])    &#123;        ans += dfs(tire[pos][0],now - 1);    &#125;    else if(tire[pos][1])    &#123;        ans += dfs(tire[pos][1],now - 1);    &#125;    return ans;&#125;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    for(int i = 1,x;i <= n;++i)    &#123;        cin >> x;        insert(x);    &#125;    cout << dfs(0,30) << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="New-Year’s-Problem"><a href="#New-Year’s-Problem" class="headerlink" title="New Year’s Problem"></a>New Year’s Problem</h2><p><a href="https://codeforces.com/contest/1619/problem/D">Problem - D - Codeforces</a></p><p><strong>题目大意:</strong> 给定$m$个商店，有$n$个人，最多可以在$n - 1$个商店中买东西，第$i$个人收到第$j$个物品的数值是$A{i,j}$</p><p>问如何选择能够让所有人的最小开心值最高</p><p><strong>解题思路:</strong> 其实题目有两个$trick$点，一个是最小的开心值最大，对于这一个点我们可以使用二分来解决，还有一个就是$n - 1$个商店，那么对于$n - 1$来说我们可以思考的一个点也就是鸽巢原理。那么我们在写二分$check$的时候可以这样子，因为我们是选定$n - 1$个，如果对于当前选定的$x$来说，存在对应的人的最大值没有，那么就直接返回$0$，然后对于第二个部分的话我们可以考虑这样子的一个东西，至少要有一个商店带来两个人的贡献，否则就无法使用$n - 1$个</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;const int maxn = 1e5 + 10;int n,m;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n >> m;        vector<vector<int>> mp(n + 1,vector<int>(m + 1));        for(int i = 1;i <= n;++i)        &#123;            for(int j = 1;j <= m;++j)            &#123;                cin >> mp[i][j];            &#125;        &#125;        auto check = [](int x,vector<vector<int>> &mp)        &#123;            for(int i = 1;i <= m;++i)            &#123;                int f = 0;                for(int j = 1;j <= n;++j)                &#123;                    if(mp[j][i] >= x) f = 1;                &#125;                if(!f) return 0;            &#125;            for(int i = 1;i <= n;++i)            &#123;                int ct = 0;                for(int j = 1;j <= m;++j)                &#123;                    ct += (mp[i][j] >= x);                &#125;                if(ct >= 2) return 1;            &#125;            return 0;        &#125;;        int L = 0;        int R = 1000000000;        int ans = 0;        while(L <= R)        &#123;            int mid = (L + R) >> 1;            if(check(mid,mp))            &#123;                L = mid + 1;                ans = max(ans,mid);            &#125;            else R = mid - 1;        &#125;        cout << ans << "\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Left-Right-Operation"><a href="#Left-Right-Operation" class="headerlink" title="Left Right Operation"></a><strong>Left Right Operation</strong></h2><p><a href="https://atcoder.jp/contests/abc263/tasks/abc263_d">D - Left Right Operation (atcoder.jp)</a></p><h2 id="Zuma"><a href="#Zuma" class="headerlink" title="Zuma"></a>Zuma</h2><p><a href="https://codeforces.com/contest/607/problem/B">Problem - B - Codeforces</a></p><p><strong>题目大意:</strong> 给定$n$个东西，每个东西有一个颜色，每次可以消除颜色是回文串的一个字串，消除一个字串之后会自动拼接回去，问最少需要几次可以消除完</p><p><strong>解题思路:</strong> 数据很小只有$500$，考虑区间$dp$</p><p>然后接下来我们来思考转移过程，因为每次消去的都是一个回文串，那么对于我们枚举的$l$和$r$来说可以放到上一个回文串中一起删除掉，如果$l &#x3D;&#x3D; r$</p><p>那么$dp[l][r] &#x3D; dp[l - 1][r + 1]$</p><p>否则我们需要考虑一个断点，在这个断点的两边进行$dp$</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longconst int maxn = 5e2 + 10;int dp[maxn][maxn];int a[maxn],n;int check(int l,int r)&#123;    string s = "";    for(int i = l;i <= r;++i)    &#123;        char id = '0' + a[i];        s.push_back(id);    &#125;    string ss = s;    reverse(ss.begin(),ss.end());    return ss == s;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    for(int i = 1;i <= n;++i)    &#123;        cin >> a[i];        dp[i][i] = 1;    &#125;    for(int i = 1;i <= n;++i)    &#123;        int r = i + 2 - 1;        if(r > n) break;        if(a[i] != a[r])        &#123;            dp[i][r] = 2;        &#125;        else dp[i][r] = 1;    &#125;    for(int len = 3;len <= n;++len)    &#123;        for(int l = 1;l <= n;++l)        &#123;            int r = l + len - 1;            if(r > n) break;            if(a[l] == a[r]) dp[l][r] = dp[l + 1][r - 1];            else dp[l][r] = min(dp[l + 1][r],dp[l][r - 1]) + 1;            for(int mid = l;mid <= r;++mid)            &#123;                chkmin(dp[l][r],dp[l][mid] + dp[mid + 1][r]);            &#125;        &#125;    &#125;    cout << dp[1][n] << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Book-of-Evil"><a href="#Book-of-Evil" class="headerlink" title="Book of Evil"></a>Book of Evil</h2><p><a href="https://codeforces.com/problemset/problem/337/D">Problem - 337D - Codeforces</a></p><h2 id="Empty-Graph"><a href="#Empty-Graph" class="headerlink" title="Empty Graph"></a>Empty Graph</h2><p><a href="https://codeforces.com/problemset/problem/1712/D">https://codeforces.com/problemset/problem/1712/D</a></p><p><strong>题目大意:</strong> 给定一个长度为$n(1\leq n \leq 2e5)$的序列,对于任意的$(l,r),1 \leq l &lt; r \leq n$存在一条边连接$l$以及$r$，边权是$min(a_l,a_{l + 1},…,a_r)$</p><p>我们有$k$次操作机会可以将一个位置上的数字变成任意数字$x(1\leq x \leq 1e9)$,问这张图的直径是多少</p><p>一张图的直径定义如下所示: $max_{1 \leq u &lt; v \leq n}d(u,v)$,$d(u,v)$是从$u$到$v$的最短路</p><p><strong>解题思路:</strong>  首先我们先分析一下$d(u,v)$在这种情况下可能由什么组成，要么我是走两条最小的从$u$到$v$，如果是两个相邻的情况，那么我实际上$u$到$v$是只需要取$min(a_u,a_v)$</p><p>然后考虑这$k$次操作我们怎么使用，因为次数肯定是使用越多我最后的答案趋向于越大，具有一定的单调性，因此我们可以使用二分来写</p><p>我们去遍历整个序列，对于我们当前$check$的$x$来说，如果当前的数字小于$\frac{x}{2}$，那么我们需要一次机会将其变大</p><p>如果当前所需要的次数大于$k$的话，那么是不行的，我们就不要这一种情况</p><p>如果相同的话，我们看一下整个序列最大的$d$是多少，看看是否大于等于$x$即可</p><p>如果小于$k$次的话，找序列中最大的数字即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longconst int maxn = 2e5 + 10;int a[maxn],n,k,use[maxn];int cal()&#123;    int now1 = min(use[1],use[2]);    for(int i = 1;i <= n - 1;++i)    &#123;        now1 = max(now1,min(use[i],use[i + 1]));    &#125;    int mi = use[1];    for(int i = 1;i <= n;++i)    &#123;        chkmin(mi,use[i]);    &#125;    return min(2 * mi,now1);&#125;int check(int x)&#123;    int cs = 0;    for(int i = 1;i <= n;++i) use[i] = a[i];    for(int i = 1;i <= n;++i)    &#123;        if(use[i] * 2 < x)        &#123;            cs++;            use[i] = 1e9;        &#125;    &#125;    if(cs > k) return 0;    else if(cs == k)    &#123;        int now = cal();        // cout << "??? " << now << "\n";        if(now >= x) return 1;        return 0;    &#125;    else    &#123;        // cout << 33 << "\n";        if(k == 1)        &#123;            int now = use[1];            for(int i = 1;i <= n;++i)            &#123;                chkmax(now,use[i]);            &#125;            // cout << "now -> " << now << " x -> " << x << "\n";            if(now >= x) return 1;            return 0;        &#125;        return 1;    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n >> k;        for(int i = 1;i <= n;++i) cin >> a[i];        int L = 1,R = 1e9;        int ans = 0;        // cout << "?? " << check(4) << "\n";        while(L <= R)        &#123;            int mid = (L + R) >> 1;            if(check(mid))            &#123;                L = mid + 1;                ans = mid;            &#125;            else R = mid - 1;        &#125;        cout << ans << "\n";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在异或运算中，若$x \bigoplus y &#x3D; z$则有$x \bigoplus z &#x3D; y$</li><li>在两个数字取余需要相等的时候，可以转移一下位置变成一个等式</li><li>注意模拟样例的时候样例给定的特殊性质</li><li>对于$n - 1$这个数字我们要特殊考虑一下$trick$点</li><li>边着色考虑特殊情况比如有一些情况只需要两种颜色即可$(CF1217D)$</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dytechlab Cup 2022</title>
      <link href="/2022/10/09/Dytechlab-Cup-2022/"/>
      <url>/2022/10/09/Dytechlab-Cup-2022/</url>
      
        <content type="html"><![CDATA[<h1 id="Dytechlab-Cup-2022"><a href="#Dytechlab-Cup-2022" class="headerlink" title="Dytechlab Cup 2022"></a>Dytechlab Cup 2022</h1><h2 id="A-Ela-Sorting-Books"><a href="#A-Ela-Sorting-Books" class="headerlink" title="A. Ela Sorting Books"></a>A. Ela Sorting Books</h2><p><strong>题目大意:</strong>  给定$n(1 \leq n \leq 200)$本书,每本书有一个首字符，要把这$n$本书放到$k$个书架上，每个书架上面按照字典序第一个没有出现过的字符加入集合中，问这个集合最大能够构成的字符是什么</p><p><strong>解题思路:</strong> 模拟样例可以发现一件事情，假设我们当前还有若干个字符，那么从第一个字符按顺序放到最后一个可以连续放置的字符肯定是最优秀的放置方法。那么我们怎么写呢？我们可以枚举每个书架可以最终放入集合的字符是多少，然后$check$即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn = 1e6 + 10;int a[maxn],n,k;string str;map<int,int> mp;int check(int x)&#123;    if(x > n / k) return 0;    for(int i = 0;i <= x - 1;++i)    &#123;        if(mp[i] <= 0) return 0;     &#125;    for(int i = 0;i <= x - 1;++i)    &#123;        mp[i]--;    &#125;    return 1;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n >> k;        cin >> str;        mp.clear();        for(auto to:str)        &#123;            int id = to - 'a';            mp[id]++;        &#125;        vector<char> ans;        for(int i = 1;i <= k;++i)        &#123;            for(int j = 25;j >= 0;--j)            &#123;                if(check(j))                &#123;                    ans.push_back('a' + j);                    break;                &#125;            &#125;        &#125;        sort(ans.begin(),ans.end());        reverse(ans.begin(),ans.end());        for(auto to:ans)        &#123;            cout << to;        &#125;        cout << "\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Ela’s-Fitness-and-the-Luxury-Number"><a href="#B-Ela’s-Fitness-and-the-Luxury-Number" class="headerlink" title="B. Ela’s Fitness and the Luxury Number"></a>B. Ela’s Fitness and the Luxury Number</h2><p><strong>题目大意:</strong> 给定$T (1 \leq T \leq 2e5)$组样例，每组两个数字分别是$l$ 以及$r(1 \leq l,r \leq 1e18)$ ，问在这个区间中美丽数字的个数是多少。美丽数字的定义是$x$可以被$x $  $mod$ $\lfloor\sqrt{x}\rfloor$ $ &#x3D; 0$</p><p><strong>解题思路:</strong> 发现数据范围实际上很大，然后我打了一下表发现了一个规律，就是根据每一个平方数去划分，可以以每个平方数划分成一个块，假设当前的平方数是$x$，当前的平方根是$y$，那么在这一个块中存在的数字分别是$x,x + y,x + 2 * y$</p><p>特别需要注意的是，$floor$存在的一定精度误差，因此在取的时候可以采取一些操作比如$–$来优化</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn = 1e6 + 10;int a[maxn],n,k;string str;void get()&#123;    for(int i = 1;i <= 20;++i)    &#123;        int div = floor(sqrt(1.0 * i));        if(i % div == 0)        &#123;            cout << "i -> " << i << "\n";        &#125;    &#125;&#125;int getans(int x)&#123;    if(x == 0) return 0;    int rd = (sqrt(1.0 * x));    if(rd * rd > x) rd--;    int haha = rd * rd;    int ans = (rd - 1) * 3;    if(x >= haha)    &#123;        ans++;    &#125;    if(x >= haha + rd)    &#123;        ans++;    &#125;    if(x >= haha + rd * 2)    &#123;        ans++;    &#125;    return ans;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        int l,r;        cin >> l >> r;        // cout << getans(l - 1) << "\n";        // cout << l << " " << getans(l - 1) << " " << r << " " << getans(r) << "\n";        cout << getans(r) - getans(l - 1) << "\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Ela-and-Crickets"><a href="#C-Ela-and-Crickets" class="headerlink" title="C. Ela and Crickets"></a>C. Ela and Crickets</h2><p><strong>题目大意:</strong> 给定一个无限大的棋盘，给定一个$L$形状的棋子以及这个棋子刚开始的坐标，给定一个目标坐标，问这个棋子通过跳跃的方式能否到达这个目标点</p><p><strong>解题思路:</strong> 既然在一个棋盘上面，我们可以先考虑本身这个棋盘所带来的性质，也就是考虑存在的$L$形状的奇偶性带来的影响。我们可以模拟样例，发现对于一个$L$形状来说，和那个空着的格子的横纵坐标奇偶性都一样的那么我们是不可达的；然后我们考虑特殊情况，如果那个小角在边缘的话，那么不管怎么样子也只能再这个边缘移动，然后这样子判断即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn = 1e2 + 10;int r[maxn],n,k,c[maxn],x,y,sx,sy;string str;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n;        map<int,int> mpx,mpy;        for(int i = 1;i <= 3;++i)        &#123;            cin >> r[i] >> c[i];            mpx[r[i]]++;            mpy[c[i]]++;        &#125;        cin >> x >> y;        sx = sy = 0;        for(auto [to,cs]:mpx)        &#123;            if(cs == 2) sx = to;        &#125;        for(auto [to,cs]:mpy)        &#123;            if(cs == 2) sy = to;        &#125;        //边缘        if((sx == 1 || sx == n) && (sy == 1 || sy == n))        &#123;            if(sx == x || sy == y) cout << "YES\n";            else cout << "NO\n";            continue;        &#125;        if((sx - x + sy - y) % 2 == 1)        &#123;            cout << "YES\n";            continue;        &#125;        if((sx - x) % 2 == 0) cout << "YES\n";        else if((sy - y) % 2 == 0) cout << "YES\n";        else cout << "NO\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Ela-and-the-Wiring-Wizard"><a href="#D-Ela-and-the-Wiring-Wizard" class="headerlink" title="D. Ela and the Wiring Wizard"></a>D. Ela and the Wiring Wizard</h2><p><strong>题目大意:</strong> 给定一张图，图有$n$个点$m$条边$(2 \leq n \leq 500,n - 1\leq m \leq 100000)$每次可以进行若干次操作，操作如下所示</p><p>选择两条边$(u,v)$和$(v,w)$删除$(u,v)$然后连接$(u,w)$，代价是$(u,v)$的边权</p><p>问从节点$1$到节点$n$最少需要多少次</p><p><strong>解题思路:</strong> 刚开始拿到题目的时候发现没有任何思路，模拟样例可以发现一个性质，就是无论最后怎么样，最后只有一条从$1$到$n$的边使用</p><p>那么我们可以提出猜想，是否从$1$到$n$只需要连接一条路呢？</p><p>接下来的部分参考了$pzr$佬的</p><p>我们可以做出反证感性理解一下，假设我们有多条路到$n$，其中分别是$1 -&gt; u_1 -&gt; u_2 -&gt; n$,设$u_1 -&gt;u_2$的距离是$w_1$，另外一条从$1 -&gt; u_1$权值是$w_2$</p><p>首先就放着这两条边，边权是$w_1 + w_2$</p><p>如果让我们把所有的边都变成$w_1$,那么就是$2w_1$</p><p>或者我们把所有边变成$w_2$，那么就是$2w_2$</p><p>那么进行修改后我们总能贪心取到最小的</p><p>分析样例之后，我们发现建边有成自环和非自环的情况</p><p>分析非自环的情况，那么对于一条边来说，就是去修改$dis(1,u) + dis(v,n)$的次数然后再加上$1$次走到的贡献</p><p>那么接下来考虑自环的情况，如果有自环的话最多可能存在几个自环呢？</p><p>我们可以把自环看成是一个点，设自环点是$x$,那么我们额外花费一个贡献连接$x$,从$1$到$x$再从$x$到$n$的距离相加然后乘贡献，这个$x$相当于中间的一个断点去更新整张图，因此实际上最多也就只有一个</p><p>那么对于这一种题目来说，分析完整道题目我们发现都是对<strong>边</strong> 这一个元素进行考虑</p><p>因为从一开始我们就在思考，从得出结论开始，再到实际上我去取哪条边最优</p><pre class="line-numbers language-line-numbers language-C++"><code class="language-line-numbers language-C++">#define int long longtypedef long long ll;const int maxn = 1e3 + 10;const int inf = 1e9;int dis[maxn][maxn],n,m;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n >> m;        vector<array<int,3>> edge;        for(int i = 1;i <= n;++i)        &#123;            for(int j = 1;j <= n;++j)            &#123;                dis[i][j] = inf;            &#125;        &#125;        for(int i = 1;i <= n;++i) dis[i][i] = 0;        for(int i = 1,u,v,w;i <= m;++i)        &#123;            cin >> u >> v >> w;            edge.push_back(&#123;u,v,w&#125;);            dis[u][v] = dis[v][u] = 1;        &#125;        for(int k = 1;k <= n;++k)        &#123;            for(int i = 1;i <= n;++i)            &#123;                for(int j = 1;j <= n;++j)                &#123;                    chkmin(dis[i][j],dis[i][k] + dis[k][j]);                &#125;            &#125;        &#125;        int ans = 1e18;        for(auto [u,v,w]:edge)        &#123;            chkmin(ans,(dis[1][u] + 1 + dis[v][n]) * w);            chkmin(ans,(dis[1][v] + dis[u][n] + 1) * w);            for(int x = 1;x <= n;++x)            &#123;                chkmin(ans,(min(dis[u][x],dis[v][x]) + dis[1][x] + dis[x][n] + 2) * w);            &#125;        &#125;        cout << ans << "\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/09/hello-world/"/>
      <url>/2022/10/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-line-numbers language-bash"><code class="language-line-numbers language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-line-numbers language-bash"><code class="language-line-numbers language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-line-numbers language-bash"><code class="language-line-numbers language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-line-numbers language-bash"><code class="language-line-numbers language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 272</title>
      <link href="/2022/10/08/Atcoder-Beginner-Contest-272/"/>
      <url>/2022/10/08/Atcoder-Beginner-Contest-272/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-Beginner-Contest-272"><a href="#Atcoder-Beginner-Contest-272" class="headerlink" title="Atcoder Beginner Contest 272"></a>Atcoder Beginner Contest 272</h1><h2 id="A-Integer-Sum"><a href="#A-Integer-Sum" class="headerlink" title="A - Integer Sum"></a>A - Integer Sum</h2><p><strong>题目大意:</strong> 给定$n$个数字，求$n$个数字的和</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long long// typedef long long ll;const int maxn = 2e5 + 10;int n,sum;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    for(int i = 1,x;i <= n;++i)    &#123;        cin >> x;        sum += x;    &#125;    cout << sum << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Everyone-is-Friends"><a href="#B-Everyone-is-Friends" class="headerlink" title="B - Everyone is Friends"></a>B - Everyone is Friends</h2><p><strong>题目大意:</strong> 给定$n$个人以及$m$个分组，问是否每两个人都曾经出现在同一组过</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long long// typedef long long ll;const int maxn = 2e5 + 10;int n,sum,m;set<int> a[maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m;    for(int i = 1,num;i <= m;++i)    &#123;        cin >> num;        for(int j = 1,x;j <= num;++j)        &#123;            cin >> x;            a[x].insert(i);        &#125;    &#125;    int f = 0;    for(int i = 1;i <= n;++i)    &#123;        for(int j = i + 1;j <= n;++j)        &#123;            int nm = 0;            for(auto to:a[i])            &#123;                auto it = a[j].find(to);                if(it != a[j].end())                 &#123;                    nm++;                &#125;            &#125;            if(nm >= 1) f++;        &#125;    &#125;    if(f == n * (n - 1) / 2) cout << "Yes\n";    else cout << "No\n";&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Max-Even"><a href="#C-Max-Even" class="headerlink" title="C - Max Even"></a>C - Max Even</h2><p><strong>题目大意:</strong> 给定$n(1 \leq n \leq 2e5)$个数字，问两个不相同的数字加起来的最大偶数是多少</p><p><strong>解题思路:</strong> 分析题目我们可以发现一个关键问题就是两个数字加起来是偶数，那么要么是奇数和奇数相加要么是偶数和偶数相加，我们分类一下数字的奇偶性即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long long// typedef long long ll;const int maxn = 2e5 + 10;int n,sum,m;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    set<int> odd,even;    cin >> n;    for(int i = 1,x;i <= n;++i)    &#123;        cin >> x;        if(x & 1) odd.insert(x);        else even.insert(x);    &#125;    int ans = -1;    if(odd.size() >= 2)    &#123;        int res = 0;        res += *odd.rbegin();        odd.erase(prev(odd.end()));        res += *odd.rbegin();        ans = max(ans,res);    &#125;    if(even.size() >= 2)    &#123;        int res = 0;        res += *even.rbegin();        even.erase(prev(even.end()));        res += *even.rbegin();        ans = max(ans,res);    &#125;    cout << ans << "\n";&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Root-M-Leaper"><a href="#D-Root-M-Leaper" class="headerlink" title="D - Root M Leaper"></a>D - Root M Leaper</h2><p><strong>题目大意:</strong> 给定一个$n * n(1\leq n \leq 400)$的棋盘，初始点在$(1,1)$，一个点如果在$(i,j)$当且仅当它可以到$(k,l)$存在他们的$\sqrt{(i - k) ^ 2 + (j - l) ^ 2} &#x3D; \sqrt{m} (1 \leq m \leq 1e5)$</p><p>求这个矩阵中的所有点最少需要几步能被走到</p><p><strong>解题思路:</strong> 发现无论怎么走实际上我们是走不出这个棋盘的，那么实际上$m$最多不会超过$n$，那么我们就可以预处理出所有可以走的步数然后进行$BFS$即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long long// typedef long long ll;const int maxn = 5e2 + 10;const int inf = 1e9;int n,m;int tx[] = &#123;1,-1,1,-1&#125;;int ty[] = &#123;1,1,-1,-1&#125;;int dis[maxn][maxn];int vis[maxn][maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m;    vector<pair<int,int>> stp;    int lmt = min(n,m) + 100;    for(int i = 0;i <= lmt;++i)    &#123;        for(int j = 0;j <= lmt;++j)        &#123;            if(i * i + j * j == m)            &#123;                stp.push_back(&#123;i,j&#125;);                stp.push_back(&#123;j,i&#125;);            &#125;        &#125;    &#125;    for(int i = 1;i <= n;++i)    &#123;        for(int j = 1;j <= n;++j) dis[i][j] = inf;    &#125;    queue<array<int,2>> que;    que.push(&#123;1,1&#125;);    vis[1][1] = 1;    dis[1][1] = 0;    while(!que.empty())    &#123;        auto [x,y] = que.front();        que.pop();        for(auto [spx,spy]:stp)        &#123;            for(int k = 0;k <= 3;++k)            &#123;                auto fx = x + spx * tx[k];                auto fy = y + spy * ty[k];                if(fx >= 1 && fx <= n && fy >= 1 && fy <= n && dis[fx][fy] == inf && vis[fx][fy] == 0)                &#123;                    dis[fx][fy] = dis[x][y] + 1;                    vis[fx][fy] = 1;                    que.push(&#123;fx,fy&#125;);                &#125;            &#125;        &#125;    &#125;    for(int i = 1;i <= n;++i)    &#123;        for(int j = 1;j <= n;++j)        &#123;            if(dis[i][j] == inf) dis[i][j] = -1;        &#125;    &#125;    for(int i = 1;i <= n;++i)    &#123;        for(int j = 1;j <= n;++j)        &#123;            cout << dis[i][j] << " \n"[j == n];        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Add-and-Mex"><a href="#E-Add-and-Mex" class="headerlink" title="E - Add and Mex"></a>E - Add and Mex</h2><p><strong>题目大意:</strong> 给定一个长度为$n (1 \leq n \leq 2e5)$的数组，数组是$int$范围，给定$m$次操作，每次操作第$i$个位置上面的数字都会加上$i$，问这个数组的$mex$是多少</p><p><strong>解题思路:</strong> 首先我们通过模拟样例可以发现一件事情，就是如果这个序列中的数字是负数，那么它实际上是没有用的，其次是考虑$mex$的性质，因为对于长度为$n$的数组来说，$mex$最大就是$n + 1$，那么对于每一个数字来说最多也不会超过$n + 1$，既然这样，因为对于一个下标为$i$的数字来说，最多加$n &#x2F; i$次，那么对于整个序列来说就是一个调和级数，模拟即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long long// typedef long long ll;const int maxn = 2e5 + 10;const int inf = 1e9;int n,m;int ans[maxn],a[maxn];vector<int> pos[maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m;    for(int i = 1;i <= n;++i)    &#123;        cin >> a[i];        int st = 0;        if(a[i] < 0)        &#123;            int rd = abs(a[i]) / i;            if(abs(a[i]) % i) rd++;            a[i] += i * rd;            st = rd;            if(st <= m)            &#123;                pos[st].push_back(a[i]);            &#125;        &#125;        while(a[i] + i <= n && st <= m)        &#123;            st++;            a[i] += i;            if(a[i] >= 0)            &#123;                pos[st].push_back(a[i]);            &#125;        &#125;    &#125;    for(int i = 1;i <= m;++i)    &#123;        sort(pos[i].begin(),pos[i].end());        pos[i].erase(unique(pos[i].begin(),pos[i].end()),pos[i].end());        int now = 0;        for(auto to:pos[i])        &#123;            if(to != now) break;            now++;        &#125;        cout << now << "\n";    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="G-Yet-Another-mod-M"><a href="#G-Yet-Another-mod-M" class="headerlink" title="G - Yet Another mod M"></a>G - Yet Another mod M</h2><p><strong>题目大意:</strong> 给定一个长度为$n(1 \leq n \leq 5000)$，然后找到一个数字$M$，使得这个序列中每一个数字$mod$ $M$后存在唯一的众数</p><p><strong>解题思路:</strong> 在赛时就在想随机是否可行但是没有一个好的$check$方案，然后参考了一下严格鸽的题解</p><p>首先因为是唯一的众数，那么假设我们在序列中取两个数字，这两个数字$mod$ $M$ 都是$0$的，那么就存在$(x - y) $  $mod$  $m &#x3D;&#x3D; 0$</p><p>那接下来我们去找$(x - y)$的因子就可以了</p><p>这样子做的正确概率是：因为$x,y$都有$\frac{1}{2}$的概率取到，那么总的取到的概率就是$\frac{1}{4}$，那我们选择多次选择不到的概率实际上很小，对赌就可以了</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;// #define int long long// typedef long long ll;const int maxn = 2e5 + 10;const int inf = 1e9;int n,m;int ans[maxn],a[maxn];vector<int> pos[maxn];int check(int x)&#123;    if(x < 3) return 0;    map<int,int> mp;    for(int i = 1;i <= n;++i)    &#123;        mp[a[i] % x]++;        if(mp[a[i] % x] * 2 > n) return 1;    &#125;    return 0;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    srand(time(NULL));    cin >> n;    for(int i = 1;i <= n;++i)    &#123;        cin >> a[i];    &#125;    int cnt = 200;    while(cnt--)    &#123;        int x = a[rand() % n + 1];        int y = a[rand() % n + 1];        int d = x - y;        if(d == 0) continue;        for(int i = 1;i * i <= d;++i)        &#123;            if(d % i != 0) continue;            if(check(i))            &#123;                cout << i << "\n";                return 0;            &#125;            if(check(d / i))            &#123;                cout << d / i << "\n";                return 0;            &#125;        &#125;    &#125;    cout << -1 << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> abc </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 271 C-F</title>
      <link href="/2022/10/02/abc271/"/>
      <url>/2022/10/02/abc271/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-Beginner-Contest-271-C-F"><a href="#Atcoder-Beginner-Contest-271-C-F" class="headerlink" title="Atcoder Beginner Contest 271 C-F"></a>Atcoder Beginner Contest 271 C-F</h1><h2 id="C-Manga"><a href="#C-Manga" class="headerlink" title="C - Manga"></a>C - Manga</h2><p><strong>题意:</strong> 给定一个长度为$n(1 \leq n \leq 3e5)$的序列,每个位置有一个值$x(1 \leq x \leq 1e9)$，我们可以进行任意多次操作，操作的话是如果序列的长度还大于等于$2$，那么我们可以任意选择$2$个数字去删除，然后加进去任意一个数字进去，问我们最后能够得到一个形似$1,2,3…$的最长序列</p><p><strong>解题思路:</strong> 首先我们分析一下题意，我们可以知道最后的答案最多不会超过$n$，那么我们在读入的时候可以将大于$n$的部分放进一个$vector$里面，然后对于小于$n$的一部分我们可以先给他标记然后放到一个双端队列里面，如果其中的数字有重复的部分我们也需要放进上面的$vector$之中。接着我们模拟这个过程即可。在模拟的时候注意我们优先取$vector$当中的，然后我们取队列后面的即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;const int maxn = 3e5 + 10;int vis[maxn],n;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    vector<int> a;    for(int i = 1,x;i <= n;++i)    &#123;        cin >> x;        if(x <= n)        &#123;            if(vis[x]) a.push_back(x);            else vis[x] = 1;        &#125;        else a.push_back(x);    &#125;    deque<int> q;    for(int i = 1;i <= n;++i)    &#123;        if(vis[i]) q.push_back(i);    &#125;    int ans = 0;    for(int i = 1;i <= n;++i)    &#123;        if(vis[i] && q.size())        &#123;            ans++;            q.pop_front();            continue;        &#125;        if(a.size() >= 2)        &#123;            a.pop_back();            a.pop_back();        &#125;        else if(a.size() == 1)        &#123;            a.pop_back();            if(!q.empty()) q.pop_back();             else break;        &#125;        else        &#123;            if(q.size() >= 2)            &#123;                q.pop_back();                q.pop_back();            &#125;            else break;        &#125;        ans++;    &#125;    cout << ans << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Flip-and-Adjust"><a href="#D-Flip-and-Adjust" class="headerlink" title="D - Flip and Adjust"></a>D - Flip and Adjust</h2><p><strong>题意:</strong> 给定$n(1 \leq n \leq 100)$张卡片，每张卡片背面和正面有一个数字，现在让我们选择每张卡片的正面或者反面，问是否能够组成$s(1\leq s \leq 10000)$</p><p><strong>解题思路:</strong> 首先我们可以观察数据范围，可能是$O(n ^ 3)$或者$O(ns)$的$dp$</p><p>接下来我们考虑这样的一个过程，首先无论如何每张牌都是要取的，那么假定我现在取到第$i - 1$张牌的值有$s_{i - 1}$，那么我取第$i$张牌的时候的值肯定有$s_{i - 1} + mp[i][0]$和$s_{i - 1} + mp[i][1]$$(mp[i][0&#x2F;1]表示第i张牌的正反面的值)$</p><p>那么我们就可以用$dp[i][s]$来表示前$i$张牌可能组成的值</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;const int maxn = 2e2 + 10;int mp[maxn][2],n,s;int dp[maxn][40010];int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> s;    dp[0][0] = 1;    for(int i = 1;i <= n;++i)    &#123;        cin >> mp[i][0] >> mp[i][1];        if(i == 1)        &#123;            dp[1][mp[i][0]] = 1;            dp[1][mp[i][1]] = 1;            continue;        &#125;        for(int j = 0;j <= s;++j)        &#123;            if(!dp[i - 1][j]) continue;            if(j + mp[i][0] <= s) dp[i][j + mp[i][0]] = 1;            if(j + mp[i][1] <= s) dp[i][j + mp[i][1]] = 1;        &#125;    &#125;    if(dp[n][s])    &#123;        cout << "Yes\n";        string ans = "";        for(int i = n;i >= 1;--i)        &#123;            if(s - mp[i][0] >= 0 && dp[i - 1][s - mp[i][0]])            &#123;                s -= mp[i][0];                ans.push_back('H');            &#125;            else            &#123;                s -= mp[i][1];                ans.push_back('T');            &#125;        &#125;        assert(ans.length() == n);        reverse(ans.begin(),ans.end());        cout << ans << "\n";    &#125;    else    &#123;        cout << "No\n";    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Subsequence-Path"><a href="#E-Subsequence-Path" class="headerlink" title="E - Subsequence Path"></a>E - Subsequence Path</h2><p><strong>题目大意:</strong> 给定$n$个点$m$条单向边$(1 \leq n,m \leq 2e5)$，没有重边和自环，每个边有一条权值，接下来给定一个序列$E$，我们走的路径的标号形成的序列必须是这个序列$E$的子序列，问从点$1$到点$n$的最短路径</p><p><strong>解题思路:</strong> 分析题目发现我们的突破口应该在这个给定我们的序列$E$这里，因为考虑我们取到的序列是这个序列的子序列，这里给我们透露到一些信息，就是假设我们当前已经遍历到第$i$条边，那么我们是可以用前面$i - 1$条边来更新这一张图的，那么我们知道这个点之后就可以写啦</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;#define int long longconst int maxn = 2e5 + 10;const int inf = 1e18;struct node&#123;    int u,v,w;&#125;edge[maxn];int n,m,k;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m >> k;    vector<int> dis(n + 1,inf);    for(int i = 1,u,v,w;i <= m;++i)    &#123;        cin >> u >> v >> w;        edge[i] = &#123;u,v,w&#125;;    &#125;    dis[1] = 0;    for(int i = 1,x;i <= k;++i)    &#123;        cin >> x;        int u = edge[x].u;        int v = edge[x].v;        int w = edge[x].w;        dis[v] = min(dis[v],dis[u] + w);    &#125;    if(dis[n] != inf) cout << dis[n] << "\n";    else cout << -1 << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="F-XOR-on-Grid-Path"><a href="#F-XOR-on-Grid-Path" class="headerlink" title="F - XOR on Grid Path"></a>F - XOR on Grid Path</h2><p><strong>题目大意:</strong> 给定一个$n * n(1\leq n \leq 20)$的矩阵，我们从点$(1,1)$开始，每次移动可以向$(x + 1,y)$或者$(x,y + 1)$移动，问我们到达$(n,n)$使得异或和为$0$的路径有多少条</p><p><strong>解题思路:</strong> 首先对于这种矩阵的题目我们肯定先去考虑$dp$的，但是如果暴力去枚举所有方案的话方案数实际会非常的大</p><p>根据官方题解的思路，建议我们使用$meet$  $in$ $middle$来做</p><p>那$meet$  $in$ $middle$是个什么东西呢？大概就是我从两个点来搜索，搜索到一些具有共同性质的点从而结束，因为这样子会大大减少我们所需要的时间复杂度</p><p>那么对于矩阵来说，我们可以从$(1,1)$点和$(n,n)$点来搜索，对于这两个点来说我们都搜索到对角线上面的点来结束,因为对角线刚好分割两个矩阵</p><p>那么我们对于$(1,1)$点来说，我们可以直接搜索下去到对角线来记录当前异或和的数值，那么对于$(n,n)$点来说，我们可以往上面搜索，搜到对角线的话就加上之前前面遍历到这一点的值，因为我们需要异或和是$0$嘛</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;#define int long longint mp[30][30],n;unordered_map<int,int> dp[30][30];int ans;void dfs1(int x,int y,int now)&#123;    if(x + y == n)    &#123;        dp[x][y][now]++;        return;    &#125;    if(x + y > n) return;    dfs1(x + 1,y,now ^ mp[x + 1][y]);    dfs1(x,y + 1,now ^ mp[x][y + 1]);&#125;void dfs2(int x,int y,int now)&#123;    if(x + y == n)    &#123;        ans += dp[x][y][now ^ mp[x][y]];        return;    &#125;    if(x + y < n) return;    dfs2(x - 1,y,now ^ mp[x - 1][y]);    dfs2(x,y - 1,now ^ mp[x][y - 1]);&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    for(int i = 1;i <= n;++i)    &#123;        for(int j = 1;j <= n;++j) cin >> mp[i][j];    &#125;    dfs1(1,1,mp[1][1]);    dfs2(n,n,mp[n][n]);    cout << ans << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> abc </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph Traing</title>
      <link href="/2022/09/29/Graph-Traing/"/>
      <url>/2022/09/29/Graph-Traing/</url>
      
        <content type="html"><![CDATA[<h1 id="Graph-Traing"><a href="#Graph-Traing" class="headerlink" title="Graph Traing"></a>Graph Traing</h1><h2 id="Boboniu-Walks-on-Graph"><a href="#Boboniu-Walks-on-Graph" class="headerlink" title="Boboniu Walks on Graph"></a>Boboniu Walks on Graph</h2><p><a href="https://codeforces.com/problemset/problem/1394/B">https://codeforces.com/problemset/problem/1394/B</a></p><p><strong>题目大意:</strong> 给定一张图有$n$个点$m$条边，每条边的权值从$1$ ~ $m$并且每条边的权值互相不相同，这张图中一个点的最大的出度是$k$,然后求$k$元组，这个$k$元组的第$i$个位置代表着出度数为$i$的点走他的边权从小到大为第$c_i$的边，问多元组最多有多少种</p><p><strong>解题思路:</strong> 首先我们可以发现这样子一件事情，因为$k$的范围并不大，因此如果我们暴力去枚举多元组的样子最多也只有$9!$种，那么我们是否可以有一种很快速的$check$方法来检查一种多元组是否合法呢？首先我们可以想这样一件事情，因为对于每一个点最后都能跳回到自己，所以最后的结果必定是一个环，那么对于一个环来说我们可以粗略的将其看成一个集合，然后我们给每个点刚开始随机一个数值。然后我们分析多元组的性质，对于任意一种多元组，第$i$位的跳跃到第$c_i$个，那么我们可以刚开始预处理这个东西，对于当前点的出度和当前去往点的序号记录一个数组然后加起来就可以了</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn = 1e6 + 10;int n,m,k;int sum[15][15];int a[maxn],ansha,ans;int res;vector<pair<int,int>> edge[maxn];void dfs(int now)&#123;    if(now == k + 1)    &#123;        if(res == ansha) ans++;        return;    &#125;    for(int i = 1;i <= now;++i)    &#123;        res += sum[now][i];        dfs(now + 1);        res -= sum[now][i];    &#125;    return;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    srand(time(NULL));    cin >> n >> m >> k;    for(int i = 1;i <= n;++i) a[i] = rand() * rand(),ansha += a[i];    for(int i = 1,u,v,w;i <= m;++i)    &#123;        cin >> u >> v >> w;        edge[u].push_back(&#123;w,v&#125;);    &#125;    for(int i = 1;i <= n;++i) sort(edge[i].begin(),edge[i].end());    for(int i = 1;i <= n;++i)    &#123;        int sz = edge[i].size();        for(int j = 0;j < sz;++j)        &#123;            auto to = edge[i][j].second;            sum[sz][j + 1] += a[to];        &#125;    &#125;    dfs(1);    cout << ans << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Slipper"><a href="#Slipper" class="headerlink" title="Slipper"></a>Slipper</h2><p>(<a href="https://vjudge.net/contest/517945#problem/C">https://vjudge.net/contest/517945#problem/C</a>)</p><p><strong>题目大意:</strong> 给定一棵树，结点个数为$n (1 \leq n \leq 1e5)$,给定每条树边连接的两个结点和对应的边权，除此之外可以进行若干次魔法，若$|dep_u - dep_v| &#x3D; k$，那么从$u$到$v$只需要$d$点边权，给定两个点$s$和$t$，求从$s$到$t$最少需要多少边权</p><p><strong>解题思路:</strong> 我们可以刚开始这么思考，如果不考虑任何优化，我们可以将每个点放到对应的一个存储容器中，这个容易用$dep$ 来标记，如果两个容器相差$k$，那么我们对于两个集合中的点进行一一连边即可。但是这样子实际的时间复杂度很大，那么我们考虑优化建边。根据上面的思考，我们可以发现一个性质只有层与层之间才会连接一条边，其实很多边是重复的，那么我们对于每一个层来说我们可以建一个点，表示层，那么我们对于每一个点来说，连向这个层，那么对于层与层之间的，我们可以从$u$往$u + k$建一条边，同时也可以从$u + k$往$u$建边，但是只有一层层点是不够的，因为原来的树点连过来的边权是$0$，那么我们再建一层层点来跑最短路即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;// #define int long longtypedef long long ll;const int maxn = 6e6 + 10;const int maxm = 1e6 + 10;const ll inf = 1e18;int tot;struct node&#123;    int u,v,w,nxt;&#125;edge[maxn << 1];int head[maxn];inline void add(int u,int v,int w)&#123;    edge[++tot].u = u,edge[tot].v = v,edge[tot].w = w,edge[tot].nxt = head[u],head[u] = tot;&#125;int n,dep[maxm],k,p,s,t,mxdep;void dfs(int s,int fa)&#123;    dep[s] = dep[fa] + 1;    mxdep = max(mxdep, dep[s]);    for(int i = head[s];i;i = edge[i].nxt)    &#123;        int to = edge[i].v;        if(to == fa) continue;        dfs(to,s);    &#125;&#125;void dij()&#123;    vector<int> vis(3 * n + 10, 0);    vector<ll> dis(3 * n + 10, inf);    dis[s] = 0;    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> que;    que.push(&#123;0, s&#125;);    while(!que.empty())    &#123;        auto now = que.top().second;        que.pop();        if(vis[now])            continue;        vis[now] = 1;        for(int i = head[now];i;i = edge[i].nxt)        &#123;            int to = edge[i].v;            ll ww = edge[i].w * 1ll;            if(dis[to] > dis[now] + ww)            &#123;                dis[to] = dis[now] + ww;                que.push(&#123;dis[to], to&#125;);            &#125;        &#125;    &#125;    printf("%lld\n",dis[t]);&#125;void solve()&#123;    tot = 0;    scanf("%d",&n);    // cin >> n;    mxdep = 0;    for(int i = 1;i <= n + n + n + 10;++i) head[i] = 0;    for (int i = 1, u, v, w; i <= n - 1;++i)    &#123;        scanf("%d %d %d",&u,&v,&w);        // cin >> u >> v >> w;        add(u,v,w);        add(v,u,w);    &#125;    dfs(1, 0);    scanf("%d %d",&k,&p);    scanf("%d %d",&s,&t);    for (int i = 1; i <= n;++i)    &#123;        add(i,dep[i] + n,0);        add(dep[i] + n + n,i,0);    &#125;    for (int l = 1; l <= n;++l)    &#123;        int r = l + k;        if(r > mxdep)            break;        add(l + n,r + n + n,p);        add(r + n + n,l + n,p);    &#125;    dij();&#125;signed main()&#123;    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);    int T;    scanf("%d", &T);    // cin >> T;    while(T--)    &#123;        solve();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ela-and-the-Wiring-Wizard"><a href="#Ela-and-the-Wiring-Wizard" class="headerlink" title="Ela and the Wiring Wizard"></a>Ela and the Wiring Wizard</h2><p><a href="https://codeforces.com/contest/1737/problem/D">https://codeforces.com/contest/1737/problem/D</a></p><p><strong>题目大意:</strong> 给定一张图，图有$n$个点$m$条边$(2 \leq n \leq 500,n - 1\leq m \leq 100000)$每次可以进行若干次操作，操作如下所示</p><p>选择两条边$(u,v)$和$(v,w)$删除$(u,v)$然后连接$(u,w)$，代价是$(u,v)$的边权</p><p>问从节点$1$到节点$n$最少需要多少次</p><p><strong>解题思路:</strong> 刚开始拿到题目的时候发现没有任何思路，模拟样例可以发现一个性质，就是无论最后怎么样，最后只有一条从$1$到$n$的边使用</p><p>那么我们可以提出猜想，是否从$1$到$n$只需要连接一条路呢？</p><p>接下来的部分参考了$pzr$佬的</p><p>我们可以做出反证感性理解一下，假设我们有多条路到$n$，其中分别是$1 -&gt; u_1 -&gt; u_2 -&gt; n$,设$u_1 -&gt;u_2$的距离是$w_1$，另外一条从$1 -&gt; u_1$权值是$w_2$</p><p>首先就放着这两条边，边权是$w_1 + w_2$</p><p>如果让我们把所有的边都变成$w_1$,那么就是$2w_1$</p><p>或者我们把所有边变成$w_2$，那么就是$2w_2$</p><p>那么进行修改后我们总能贪心取到最小的</p><p>分析样例之后，我们发现建边有成自环和非自环的情况</p><p>分析非自环的情况，那么对于一条边来说，就是去修改$dis(1,u) + dis(v,n)$的次数然后再加上$1$次走到的贡献</p><p>那么接下来考虑自环的情况，如果有自环的话最多可能存在几个自环呢？</p><p>我们可以把自环看成是一个点，设自环点是$x$,那么我们额外花费一个贡献连接$x$,从$1$到$x$再从$x$到$n$的距离相加然后乘贡献，这个$x$相当于中间的一个断点去更新整张图，因此实际上最多也就只有一个</p><p>那么对于这一种题目来说，分析完整道题目我们发现都是对<strong>边</strong> 这一个元素进行考虑</p><p>因为从一开始我们就在思考，从得出结论开始，再到实际上我去取哪条边最优</p><pre class="line-numbers language-line-numbers language-C++"><code class="language-line-numbers language-C++">#define int long longtypedef long long ll;const int maxn = 1e3 + 10;const int inf = 1e9;int dis[maxn][maxn],n,m;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    int T;    cin >> T;    while(T--)    &#123;        cin >> n >> m;        vector<array<int,3>> edge;        for(int i = 1;i <= n;++i)        &#123;            for(int j = 1;j <= n;++j)            &#123;                dis[i][j] = inf;            &#125;        &#125;        for(int i = 1;i <= n;++i) dis[i][i] = 0;        for(int i = 1,u,v,w;i <= m;++i)        &#123;            cin >> u >> v >> w;            edge.push_back(&#123;u,v,w&#125;);            dis[u][v] = dis[v][u] = 1;        &#125;        for(int k = 1;k <= n;++k)        &#123;            for(int i = 1;i <= n;++i)            &#123;                for(int j = 1;j <= n;++j)                &#123;                    chkmin(dis[i][j],dis[i][k] + dis[k][j]);                &#125;            &#125;        &#125;        int ans = 1e18;        for(auto [u,v,w]:edge)        &#123;            chkmin(ans,(dis[1][u] + 1 + dis[v][n]) * w);            chkmin(ans,(dis[1][v] + dis[u][n] + 1) * w);            for(int x = 1;x <= n;++x)            &#123;                chkmin(ans,(min(dis[u][x],dis[v][x]) + dis[1][x] + dis[x][n] + 2) * w);            &#125;        &#125;        cout << ans << "\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Session-in-BSU"><a href="#Session-in-BSU" class="headerlink" title="Session in BSU"></a>Session in BSU</h2><p><a href="https://codeforces.com/problemset/problem/1027/F">Problem - 1027F - Codeforces</a></p><p><strong>题目大意:</strong> 给定$n(1 \leq n \leq 10 ^ 6)$场比赛，每场比赛有两个数字$a_i,b_i(1 \leq a_i ,b_i \leq 10 ^ 9)$ 代表可以在第几天考试，问最早可以在哪一天结束比赛，如果无法结束比赛输出$-1$</p><p><strong>解题思路:</strong> 首先如果我们不看这个数据范围的话，那么是不是实际上可以一眼网络流，建立每个考试点和对应的天数点，跑最大流即可。但是观察一下数据范围实际上很大，那么我们就不能直接跑网络流，不过既然一眼网络流我们可以往建图这一个方向去思考这个问题。假设我对每场考试连一条边，那么是不是就代表着一件事情:我这一条边可以选择这两个点中的任意一个时间。那么整张图是不是就是一个森林了。然后我们来考虑一下每个连通块有什么性质，对于每个连通块中，我们都要让这个连通块的边数(考试场数) 小于等于点数(选择考试的天数)，那么对于每一个连通块中，我们假设边数是$num$,我们是不是选择第$num$大的天数就是这个连通块的答案</p><p>但是实际写起来之后发现这样子直接写会出现一些奇怪的问题，那么我们可以在思考刚刚形成的连通块是什么样子的，因为边数要小于等于点数，所以要么是一颗树，要么是一棵基环树，那么对于这两个来说我们只需要记录一个最大值和次大值即可，对于连通块是树的话输出次大值，基环树的输出最大值</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;const int maxn = 4e6 + 10;int f[maxn],n,m,edgenum[maxn],sz[maxn],ansmx2[maxn],ansmx[maxn],val[maxn],cnt;int getf(int x)&#123;    return x == f[x] ? x : f[x] = getf(f[x]);&#125;pair<int,int> edge[maxn];signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> m;    for(int i = 1,u,v;i <= m;++i)    &#123;        cin >> u >> v;        edge[i] = &#123;u,v&#125;;        val[++cnt] = u,val[++cnt] = v;    &#125;    sort(val + 1,val + 1 + cnt);    n = unique(val + 1,val + 1 + cnt) - (val + 1);    for(int i = 1;i <= n;++i) f[i] = i,sz[i] = 1,edgenum[i] = 0,ansmx[i] = i;    for(int i = 1;i <= m;++i)    &#123;        auto [u,v] = edge[i];        u = lower_bound(val + 1,val + 1 + n,u) - val;        v = lower_bound(val + 1,val + 1 + n,v) - val;        int fu = getf(u);        int fv = getf(v);        if(fu == fv)        &#123;            edgenum[fu]++;        &#125;        else        &#123;            f[fu] = fv;            sz[fv] += sz[fu];            edgenum[fv] += edgenum[fu] + 1;            vector<int> ha;            ha.push_back(ansmx2[fu]);ha.push_back(ansmx[fu]);            ha.push_back(ansmx2[fv]);ha.push_back(ansmx[fv]);            sort(ha.begin(),ha.end());            ansmx[fv] = ha[3];            ansmx2[fv] = ha[2];        &#125;    &#125;    int f = 1;    int res = 0;    for(int i = 1;i <= n;++i)    &#123;        int fi = getf(i);        if(i == fi)        &#123;            if(sz[i] < edgenum[i])            &#123;                 f = 0;                break;            &#125;            if(edgenum[i] == sz[i]) chkmax(res,val[ansmx[i]]);            else chkmax(res,val[ansmx2[i]]);        &#125;    &#125;    if(!f)    &#123;        cout << -1 << "\n";        return 0;    &#125;    cout << res << "\n";&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Moment-of-Bloom"><a href="#Moment-of-Bloom" class="headerlink" title="Moment of Bloom"></a>Moment of Bloom</h2><p><a href="https://codeforces.com/problemset/problem/1583/E">Problem - 1583E - Codeforces</a></p><p><strong>题目大意:</strong> 给定一个点数为$n$，边数为$m$的图$(1 \leq n,m \leq 3*10^5)$,初始所有点的点权为$0$。给定$q$次操作，每次操作给定两个点，你可以选择图上这两个点中任意一条简单路径，并且给这一条简单路径上面所有的点权加$1$，问经过$q$次操作这张图所有点的点权是否都是偶数，如果是的话输出$Y!ES$并且输出每次操作应该怎么操作，否则输出$N!O$并且输出最少还需要加几条边，特别注意的是$nq \leq 3 * 10^5$</p><p><strong>解题思路:</strong> 首先遇到这样子的问题在一张图上面会很棘手，因为两个点之间可能有很多的路径，那么既然这样，我们先尝试简化一下这个问题。如果我们把这一个问题放在一棵树上面，那么两点之间的路径是不是就已经确定了。既然这样，什么时候会出现不行的情况呢？我们每次可以对路径的两个端点增加一个值，如果最后在这一棵树上面存在点的点权是奇数，那么是肯定输出$NO$的。然后由于点是成对出现的，那么点也会是成对落单的，我们记录奇数个数的点为$num$个，那么最后需要的边数就是$\frac{num}{2}$个</p><p>然后对于原题来说我们已经把题目化成在树上面了，那么我们直接在树上类似$LCA$找祖先结点沿路径输出即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;const int maxn = 3e5 + 10;struct graph&#123;    vector<int> edge[maxn];    inline void add(int u,int v)    &#123;        edge[u].push_back(v);        edge[v].push_back(u);    &#125;&#125;g1,g2;int n,m,deg[maxn];pair<int,int> op[maxn];int f[maxn],p[maxn],dep[maxn];int getf(int x)&#123;    return x == f[x] ? x : f[x] = getf(f[x]);&#125;void dfs(int s,int fa)&#123;    dep[s] = dep[fa] + 1;    p[s] = fa;    for(auto to:g2.edge[s])    &#123;        if(to == fa) continue;        dfs(to,s);    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m;    for(int i = 1,u,v;i <= m;++i)    &#123;        cin >> u >> v;        g1.add(u,v);    &#125;    int q;    cin >> q;    for(int i = 1;i <= q;++i) cin >> op[i].first >> op[i].second,deg[op[i].first]++,deg[op[i].second]++;    int ct = 0;    for(int i = 1;i <= n;++i)    &#123;        ct += (deg[i] & 1);    &#125;    if(ct)    &#123;        cout << "NO\n";        cout << ct / 2 << "\n";        return 0;    &#125;    cout << "YES\n";    for(int i = 1;i <= n;++i) f[i] = i;    for(int i = 1;i <= n;++i)    &#123;        for(auto to:g1.edge[i])        &#123;            int fx = getf(i);            int fy = getf(to);            if(fx == fy) continue;            f[fy] = fx;            g2.add(i,to);        &#125;    &#125;    // cout << "?? " << "\n";    dfs(1,0);    for(int i = 1;i <= q;++i)    &#123;        auto [u,v] = op[i];        vector<int> now;        vector<int> now2;        // cout << "?? ? " << u << " " << v << "\n";        while(dep[u] != dep[v])        &#123;            if(dep[u] > dep[v]) now.push_back(u),u = p[u];            else now2.push_back(v),v = p[v];        &#125;        while(u != v)        &#123;            now.push_back(u);            now2.push_back(v);            u = p[u];            v = p[v];        &#125;        reverse(now2.begin(),now2.end());        now.push_back(u);        for(auto to:now2)        &#123;            now.push_back(to);        &#125;        cout << now.size() << "\n";        for(auto to:now)        &#123;            cout << to << " ";        &#125;        cout << "\n";    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Factory-Balls"><a href="#Factory-Balls" class="headerlink" title="Factory Balls"></a>Factory Balls</h2><p><a href="https://codeforces.com/gym/103855/problem/A">Problem - A - Codeforces</a></p><p>**题目大意: ** 给定一个球，球被划分成为$n$个区域，然后有$k$种颜色的油漆桶，有$m$个装备，球的每个区域在初始状态都是$1$</p><p>接下来可以进行以下三种操作若干次，一种是将这个球放入油漆桶里面，这个球没有被装备安装的部分全部会感染上这个颜色，一种是在这个球上面安装一个装备，一种是给这个球脱下一种装备</p><p>问这个球的区域是否可以达到给定的目标状态，如果可以的话输出最小的步数，否则输出$-1$</p><p>特别的是$1 \leq n,m,k \leq 10$</p><p><strong>解题思路:</strong>  首先考虑数据范围，因为我们的数据范围实际上其实很小，那么我们可以进行状压来表示 <strong>当前的状态</strong> 和 <strong>目标状态</strong> 是否一致，如果一致是$1$否则就是$0$ 。然后我们就这样子$BFS$，我们进行搜索的时候的状态可以以当前的颜色和目标的颜色的差别以及装备的数目和种类，然后我们思考，当前状态更新一步的操作要么是去不变颜色更新装备状态，不变状态更新装备颜色，然后搜索即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;template<typename T> inline bool chkmin(T &a, const T &b) &#123; return a > b ? a = b, 1 : 0; &#125;template<typename T> inline bool chkmax(T &a, const T &b) &#123; return a < b ? a = b, 1 : 0; &#125;const int maxn = 1111;const int inf = 1e9 + 7;int n,k,m;int col[maxn],vis[maxn];vector<int> equ[maxn];int dis[maxn][maxn];int main()&#123;    // ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> k >> m;    for(int i = 1;i <= n;++i) cin >> col[i];    int s = 0;    for(int i = 0,num;i < m;++i)    &#123;        cin >> num;        for(int j = 1,x;j <= num;++j)        &#123;            cin >> x;            equ[i].push_back(x);        &#125;    &#125;    for(int i = 1;i <= n;++i)    &#123;        if(col[i] == 1)        &#123;            s |= (1 << (i - 1));        &#125;    &#125;    queue<pair<int,int>> que;    memset(dis,0x3f,sizeof dis);    // cout << "?1" << dis[s][0] << "??\n";    dis[s][0] = 0;    que.push(&#123;s,0&#125;);    while(!que.empty())    &#123;        auto [nowcol,nowequ] = que.front();        que.pop();        // cout << "-----------------------------\n";        // cout << "now -> " << nowcol << " " << nowequ << "\n";        for(int i = 0;i < m;++i)        &#123;            auto toequ = nowequ ^ (1 << i);            if(dis[nowcol][toequ] > dis[nowcol][nowequ] + 1)            &#123;                dis[nowcol][toequ] = dis[nowcol][nowequ] + 1;                que.push(&#123;nowcol,toequ&#125;);            &#125;        &#125;        for(int i = 1;i <= n;++i) vis[i] = 0;        for(int i = 0;i < m;++i)        &#123;            if(nowequ >> i & 1)            &#123;                for(auto to:equ[i])                &#123;                    vis[to] = 1;                &#125;            &#125;        &#125;        for(int i = 1;i <= k;++i)        &#123;            int tocol = nowcol;            for(int j = 1;j <= n;++j)            &#123;                if(vis[j]) continue;                if(col[j] == i)                &#123;                    tocol |= (1 << (j - 1));                &#125;                else                &#123;                    if(tocol >> (j - 1) & 1)                    &#123;                        tocol ^= (1 << (j - 1));                    &#125;                &#125;            &#125;            // cout << i << " tocol ?? " << tocol << "\n";            if(dis[tocol][nowequ]  > dis[nowcol][nowequ] + 1)            &#123;                dis[tocol][nowequ] = dis[nowcol][nowequ] + 1;                que.push(&#123;tocol,nowequ&#125;);            &#125;        &#125;    &#125;    // cout << (1 << (m)) - 1 << " " << dis[7][0] << " ??\n";    if(dis[(1 << (n)) - 1][0] >= inf) cout << -1 << "\n";    else cout << dis[(1 << (n)) - 1][0] << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flow</title>
      <link href="/2022/09/29/Flow/"/>
      <url>/2022/09/29/Flow/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>网络流时间复杂度大约为$O(n^2m)$</p><p>不过也比较玄学罢了</p><p>将一张图建完之后直接跑$dinic$即可</p><p>接下来有封装之后的版本</p><p>注意这个封装版本的最大流应该有以下的特征：</p><ul><li><p>首先最大流这个点我们是从$1$开始的，因此我们在设置对应的起点和终点的时候，应该注意设置</p></li><li><p>其次是边的标号，因为是从$0$开始的</p></li><li><p>所以我们每次开始的边其实都是$etot$</p></li></ul><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;typedef long long ll;const int V = 1210;const int E = 121000;template<typename T>struct FlowGraph&#123;    int s,t,vtot;    int head[V],etot;    int dis[V],cur[V];    struct edge    &#123;        int v,nxt;        T f;    &#125;e[E * 2];    void addedge(int u,int v,T f)    &#123;        e[etot] = &#123;v,head[u],f&#125;; head[u] = etot++;        e[etot] = &#123;u,head[v],0&#125;; head[v] = etot++;    &#125;    bool bfs()    &#123;        for(int i = 1;i <= vtot;++i)        &#123;            dis[i] = 0;            cur[i] = head[i];        &#125;        queue<int> q;        q.push(s);dis[s] = 1;        while(!q.empty())        &#123;            int u = q.front();q.pop();            for(int i = head[u];~i;i = e[i].nxt)            &#123;                if(e[i].f && !dis[e[i].v])                &#123;                    int v = e[i].v;                    dis[v] = dis[u] + 1;                    if(v == t) return true;                    q.push(v);                &#125;            &#125;        &#125;        return false;    &#125;    T dfs(int u,T m)    &#123;        if(u == t) return m;        T flow = 0;        for(int i = cur[u];~i;cur[u] = i = e[i].nxt)        &#123;            if(e[i].f && dis[e[i].v] == dis[u] + 1)            &#123;                T f = dfs(e[i].v,min(e[i].f,m));                e[i].f -= f;                e[i ^ 1].f += f;                m -= f;                flow += f;                if(!m) break;            &#125;        &#125;        if(!flow) dis[u] = -1;        return flow;    &#125;    T dinic()    &#123;        T flow = 0;        while(bfs()) flow += dfs(s,numeric_limits<T>::max());        return flow;    &#125;    void init(int s_,int t_,int vtot_)    &#123;        s = s_;        t = t_;        vtot = vtot_;        etot = 0;        for(int i = 1;i <= vtot;++i) head[i] = -1;    &#125;&#125;;int n,m,s,t;FlowGraph<ll> g;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m >> s >> t;    g.init(s,t,n);    for(int i = 1,u,v,w;i <= m;++i)    &#123;        cin >> u >> v >> w;        g.addedge(u,v,w);    &#125;    cout << g.dinic() << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方案分配"><a href="#方案分配" class="headerlink" title="方案分配"></a>方案分配</h3><p>方案分配实际上我们可以思考他的<strong>流量</strong>和之前的关系，然后我们判断这个<strong>流量</strong>来输出方案</p><p>题目条件可以是类似于这样子的，给定一些试题类型，其中再给定一些试题，我每个试题是属于不同的试题类型的，求是否可以分配，并且输出方案</p><p>那么其实我们对应的解决方案是把相对应的东西放到一个$vector$中，然后去判断对应的边的流量即可</p><h4 id="P2763"><a href="#P2763" class="headerlink" title="P2763"></a>P2763</h4><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;typedef long long ll;const int V = 1210;const int E = 121000;template<typename T>struct FlowGraph&#123;    int s,t,vtot;    int head[V],etot;    int dis[V],cur[V];    struct edge    &#123;        int v,nxt;        T f;    &#125;e[E * 2];    void addedge(int u,int v,T f)    &#123;        e[etot] = &#123;v,head[u],f&#125;; head[u] = etot++;        e[etot] = &#123;u,head[v],0&#125;; head[v] = etot++;    &#125;    bool bfs()    &#123;        for(int i = 1;i <= vtot;++i)        &#123;            dis[i] = 0;            cur[i] = head[i];        &#125;        queue<int> q;        q.push(s);dis[s] = 1;        while(!q.empty())        &#123;            int u = q.front();q.pop();            for(int i = head[u];~i;i = e[i].nxt)            &#123;                if(e[i].f && !dis[e[i].v])                &#123;                    int v = e[i].v;                    dis[v] = dis[u] + 1;                    if(v == t) return true;                    q.push(v);                &#125;            &#125;        &#125;        return false;    &#125;    T dfs(int u,T m)    &#123;        if(u == t) return m;        T flow = 0;        for(int i = cur[u];~i;cur[u] = i = e[i].nxt)        &#123;            if(e[i].f && dis[e[i].v] == dis[u] + 1)            &#123;                T f = dfs(e[i].v,min(e[i].f,m));                e[i].f -= f;                e[i ^ 1].f += f;                m -= f;                flow += f;                if(!m) break;            &#125;        &#125;        if(!flow) dis[u] = -1;        return flow;    &#125;    T dinic()    &#123;        T flow = 0;        while(bfs()) flow += dfs(s,numeric_limits<T>::max());        return flow;    &#125;    void init(int s_,int t_,int vtot_)    &#123;        s = s_;        t = t_;        vtot = vtot_;        etot = 0;        for(int i = 1;i <= vtot;++i) head[i] = -1;    &#125;&#125;;int n,k,s,t;FlowGraph<ll> g;struct node&#123;    int st,num,id;&#125;;vector<int> prob[100];int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> k >> n;    s = n + k + 1;    t = n + k + 2;    g.init(s,t,t + 10);    int sum = 0;    for(int i = 1,x;i <= k;++i)    &#123;        //1 -> type        cin >> x;        sum += x;        g.addedge(s,i,x);    &#125;    // cout << "sum -> " << sum << "\n";    vector<node> used;    for(int i = 1;i <= n;++i)    &#123;        //type + 1 -> type + n        int num;        cin >> num;        for(int j = 1,bel;j <= num;++j)        &#123;            cin >> bel;            used.push_back(&#123;bel,i,g.etot&#125;);            g.addedge(bel,k + i,1);        &#125;    &#125;    for(int i = 1;i <= n;++i)    &#123;        g.addedge(k + i,t,1);    &#125;    // cout << "??\n";    ll namomo = g.dinic();    if(namomo != sum)    &#123;        cout << "\n";    &#125;    else    &#123;        for(auto now:used)        &#123;            int idd = now.id;            if(g.e[idd].f == 0)            &#123;                prob[now.st].push_back(now.num);            &#125;        &#125;        for(int i = 1;i <= k;++i)        &#123;            cout << i << ":";            for(auto to:prob[i])            &#123;                cout << " " << to;            &#125;            cout << "\n";        &#125;    &#125;    return 0;&#125;/*属于是最大流的方案分配问题，首先显而易见我们可以通过这一条边的流量去判断这个边是否被用过来判断是否属于这一个方案当中那么我们可以这样子，因为我们是把试题库和相对应的试题连接在一起ok，那么这样子我们在建边的时候我们可以把相对应的边的号给放到一个vector里面然后后续我们去检查这个边的流量是否为1即可*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="路径模型"><a href="#路径模型" class="headerlink" title="路径模型"></a>路径模型</h3><p>比如说一个序列，如果可以从$a_i$ 到$a_j$有一条路径，实际上我们也可以映射到一张图上面去考虑，因为我们在做最大流的过程中实际上就是在走一些流的路径</p><p>然后对于一些<strong>流量限制</strong>的情况下我们可以采用<strong>拆点</strong>的方法去限制流量</p><h4 id="P2776"><a href="#P2776" class="headerlink" title="P2776"></a>P2776</h4><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;typedef long long ll;const int V = 101210;const int E = 1210000;const int maxn = 5e2 + 10;template<typename T>struct FlowGraph&#123;    int s,t,vtot;    int head[V],etot;    int dis[V],cur[V];    struct edge    &#123;        int v,nxt;        T f;    &#125;e[E * 2];    void addedge(int u,int v,T f)    &#123;        e[etot] = &#123;v,head[u],f&#125;; head[u] = etot++;        e[etot] = &#123;u,head[v],0&#125;; head[v] = etot++;    &#125;    bool bfs()    &#123;        for(int i = 1;i <= vtot;++i)        &#123;            dis[i] = 0;            cur[i] = head[i];        &#125;        queue<int> q;        q.push(s);dis[s] = 1;        while(!q.empty())        &#123;            int u = q.front();q.pop();            for(int i = head[u];~i;i = e[i].nxt)            &#123;                if(e[i].f && !dis[e[i].v])                &#123;                    int v = e[i].v;                    dis[v] = dis[u] + 1;                    if(v == t) return true;                    q.push(v);                &#125;            &#125;        &#125;        return false;    &#125;    T dfs(int u,T m)    &#123;        if(u == t) return m;        T flow = 0;        for(int i = cur[u];~i;cur[u] = i = e[i].nxt)        &#123;            if(e[i].f && dis[e[i].v] == dis[u] + 1)            &#123;                T f = dfs(e[i].v,min(e[i].f,m));                e[i].f -= f;                e[i ^ 1].f += f;                m -= f;                flow += f;                if(!m) break;            &#125;        &#125;        if(!flow) dis[u] = -1;        return flow;    &#125;    T dinic()    &#123;        T flow = 0;        while(bfs()) flow += dfs(s,numeric_limits<T>::max());        return flow;    &#125;    void init(int s_,int t_,int vtot_)    &#123;        s = s_;        t = t_;        vtot = vtot_;        etot = 0;        for(int i = 1;i <= vtot;++i) head[i] = -1;    &#125;&#125;;int n,m,s,t;int a[maxn],dp[maxn];FlowGraph<ll> g;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n;    for(int i = 1;i <= n;++i)    &#123;        cin >> a[i];        dp[i] = 1;    &#125;    int ans = 1;    for(int i = 2;i <= n;++i)    &#123;        for(int j = 1;j < i;++j)        &#123;            if(a[i] >= a[j])            &#123;                dp[i] = max(dp[i],dp[j] + 1);            &#125;        &#125;        ans = max(ans,dp[i]);    &#125;    cout << ans << "\n";    s = 2 * n + 1;    t = 2 * n + 2;    g.init(s,t,t);    for(int i = 1;i <= n;++i)    &#123;        if(dp[i] == 1) g.addedge(s,i,n);//添加流量为inf的边        if(dp[i] == ans) g.addedge(i + n,t,n);        g.addedge(i,i + n,1);    &#125;    for(int i = 1;i <= n;++i)    &#123;        for(int j = i + 1;j <= n;++j)        &#123;            if(a[j] >= a[i] && dp[j] == dp[i] + 1)            &#123;                g.addedge(i + n,j,1);            &#125;        &#125;    &#125;        cout << g.dinic() << "\n";    g.init(s,t,t);    for(int i = 1;i <= n;++i)    &#123;        if(dp[i] == 1) g.addedge(s,i,n);//添加流量为inf的边        if(dp[i] == ans) g.addedge(i + n,t,n);        if(ans == 1) g.addedge(i,i + n,1);        else g.addedge(i,i + n,n);    &#125;    for(int i = 1;i <= n;++i)    &#123;        for(int j = i + 1;j <= n;++j)        &#123;            if(a[j] >= a[i] && dp[j] == dp[i] + 1)            &#123;                g.addedge(i + n,j,1);            &#125;        &#125;    &#125;    cout << g.dinic() << "\n";&#125;/*题目大意：给定一个序列，需要解决如下的三个问题1.求这个序列的最长非递减子序列2.每个元素只能使用一次的情况下序列的最长非递减子序列3.每个元素使用多次的情况下序列的最长非递减子序列建图思路:首先对于第一个问题来说我们直接dp即可对于第二个问题，我们需要思考以下我们的建图方向因为只需要求方案数目，那么我们可以进行这样子的建图，我们可以从s->dp = 1的值建一条边我们也可以从dp = ans -> t建一条边因为在第一种情况我们只考虑每一个点使用一个那么我们可以使用拆点拆点是为了加一个限制只能流一个1然后因为我们要找第j个数字可能从哪个第i个数字转移过来 那么我们继续找重新建边即可对于第三个问题 实际上我一个点可以使用多次了那么我们先特判考虑最后答案是1的情况 其实实际上下面两个问题的答案就是n然后我们再考虑一个可以使用多次 那么我们拆店的时候对于多个点建n就可以了*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><p><strong>概念:</strong> 给定一张图，删除一些边使得$s$和$t$不连通</p><p>那么其实就是对于每一个点，我去将点划分为两个集合，每一个点要么属于$s$集合，要么属于$t$集合</p><p>那么对于这里割边来说，实际上就是找一条边，对于他的两个端点$u$和$v$，两个点分别属于一个集合</p><p>最小割 $\geq$ 最大流</p><p>接下来我们分析一下建边的过程</p><p>对于无向图建立割边，实际上我们不仅要考虑正向边，我们也要考虑反向边，那么对于无向图的建图方式实际上就是建两条相同边权的边</p><p>具体的建边方式如下图所示可以</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">void addedge(int u,int v,T f,T f2 = 0)&#123;    e[etot] = &#123;v,head[u],f&#125;; head[u] = etot++;    e[etot] = &#123;u,head[v],f2&#125;; head[v] = etot++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么有向图的话实际上还是和之前的类似，我去建一条长度为$c$的边，另外一条是长度为$0$的边</p><p>如何在实际题目中去思考到 <strong>最小割</strong> 这个东西呢？</p><h3 id="最大权独立集"><a href="#最大权独立集" class="headerlink" title="最大权独立集"></a>最大权独立集</h3><p>首先我们可以考虑引入这样子的一个问题</p><p>假设我们有两个集合(假设为一个黑子集合和一个白子集合)，每个集合都有$n$个点，每个点都有一个点权，如果我们取了一些黑子那么我们就不能取白子，要求我们最后取得的权值<strong>最大</strong> ，对于这一个问题我们如何解答呢？</p><p>我们可以考虑这样子的一个解题方向，我们最后的集合一定是分为两个集合，一个集合是取到的棋子，另外一个集合是没有取到的集合。</p><p>那么分为两个集合的操作是不是就是一个求最小割的过程呢？我们只需要把两个集合分别和$S$和$T$集合连边就可以，然后接下来相对应连边的权值就是他们的点权，然后点之间的限制因为无法切割我们可以采用$inf$</p><p>那么其实对应的如果是二维棋盘我们也可以通过这样子的操作</p><h4 id="P2774"><a href="#P2774" class="headerlink" title="P2774"></a>P2774</h4><p>方格取数，每个方格有一定权值，可以取若干个方格，方格之间不能有相互重叠的边</p><p>本质上也就是求一个最大权独立集的问题，行列相对应建边即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">const ll inf = (1ll << 60);int n,m,s,t,x;FlowGraph<ll> g;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m;    s = n * m + 1;    t = n * m + 2;    g.init(s,t,t);    ll ans = 0;    for(int i = 1;i <= n;++i)    &#123;        for(int j = 1;j <= m;++j)        &#123;            cin >> x;            ans += x;            int id = (i - 1) * m + j;            if((i + j) % 2 == 1)             &#123;                g.addedge(s,id,x);                if(i - 1 >= 1) g.addedge(id,id - m,inf);                if(i + 1 <= n) g.addedge(id,id + m,inf);                if(j + 1 <= m) g.addedge(id,id + 1,inf);                if(j - 1 >= 1) g.addedge(id,id - 1,inf);            &#125;            else g.addedge(id,t,x);        &#125;    &#125;    cout << ans - g.dinic() << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h3><p>最大权闭合子图的定义实际上就是我每个点有一定的点权，选定一些点需要使得点权和最大，然后如果我选了一个点我是必须需要选定其他后继点的，然后我们来求这张图最多获得多少的点权</p><p>其实这个也是最小割的一种模型，那么实际上和最大权独立集的本质是一样的，我给$s$和$t$集合一定的意义，然后我去进行相应的连边。</p><p>考虑这样的一件事情，因为我们在求最小割的过程中实际上是求在$S$集合中的最小割，那么实际上也就是我们把一些东西放到了$S$集合上面。</p><p>那么之前我们说了边的方案如何选择，那么如何去进行选择点的方案呢？</p><p>那么我们可以去看$dis$数组里面的东西，因为$dis$刚开始都是$0$的，对于放在$S$集合里面的东西我们都应该选择$dis$不为$0$的点即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">int n,m,s,t;FlowGraph<ll> g;string str;const ll inf = (1ll << 60);int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> m >> n;    s = m + n + 1;    t = m + n + 2;    g.init(s,t,t);    ll ans = 0;    getline(cin,str);    for(int i = 1;i <= m;++i)    &#123;        getline(cin,str);        stringstream ss;        ss << str;        // cout << "str -> " << str << "\n";        int x;        ss >> x;        g.addedge(s,i,x);//第i个实验的费用        ans += x;        while(!ss.eof())        &#123;            ss >> x;            g.addedge(i,x + m,inf);        &#125;    &#125;    for(int i = 1;i <= n;++i)    &#123;        int x;cin >> x;        g.addedge(i + m,t,x);    &#125;    ans -= g.dinic();    vector<int> p1,p2;    for(int i = 1;i <= m;++i)    &#123;        if(g.dis[i] > 0) p1.push_back(i);    &#125;    for(int i = 1;i <= n;++i)    &#123;        if(g.dis[i + m] > 0) p2.push_back(i);    &#125;    for(auto to:p1) cout << to << " ";    cout << "\n";    for(auto to:p2) cout << to << " ";    cout << "\n";    cout << ans << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;typedef long long ll;const int V = 20100;const int E = 201000;template<typename T>struct MinCostGraph&#123;    int s,t,vtot;    int head[V],cur[V],etot;    T dis[V],flow,cost;    int pre[V];    bool vis[V];    struct edge    &#123;        int v,nxt;        T f,c;    &#125;e[E * 2];    void addedge(int u,int v, T f, T c, T f2 = 0)    &#123;        e[etot] = &#123;v, head[u], f, c&#125;; head[u] = etot++;        e[etot] = &#123;u, head[v], f2, -c&#125;; head[v] = etot++;    &#125;    bool spfa()    &#123;        T inf = numeric_limits<T>::max() / 2;//防止溢出        for(int i = 1; i <= vtot; ++i)        &#123;            dis[i] = inf;            vis[i] = false;            pre[i] = -1; //记录一下上一条边,方便增广        &#125;        dis[s] = 0;        vis[s] = true;        queue<int> q;        q.push(s);        while(!q.empty())        &#123;            auto u = q.front();            for(int i = head[u]; ~i; i = e[i].nxt)            &#123;                int v = e[i].v;                if(e[i].f && dis[v] > dis[u] + e[i].c)                &#123;                    dis[v] = dis[u] + e[i].c;                    pre[v] = i;                    if(!vis[v])                    &#123;                        vis[v] = 1;                        q.push(v);                    &#125;                &#125;            &#125;            q.pop();            vis[u] = false;        &#125;        return dis[t] != inf;    &#125;    //增广    void augment()    &#123;        int u = t;        T f = numeric_limits<T>::max();        while(~pre[u])        &#123;            f = min(f, e[pre[u]].f);            u = e[pre[u] ^ 1].v;        &#125;        flow += f;        cost += f * dis[t];        u = t;        while(~pre[u])        &#123;            e[pre[u]].f -= f;            e[pre[u] ^ 1].f += f;            u = e[pre[u] ^ 1].v;        &#125;    &#125;    pair<T, T> solve()    &#123;        flow = 0;        cost = 0;        while(spfa()) augment();        return &#123;flow, cost&#125;;    &#125;    void init(int s_, int t_, int vtot_)    &#123;        s = s_;        t = t_;        vtot = vtot_;        etot = 0;        for(int i = 1; i <= vtot; ++i) head[i] = -1;    &#125;&#125;;MinCostGraph<int> g;int n,m,s,t;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m >> s >> t;    g.init(s,t,n);    for(int i = 1,u,v,f,c;i <= m;++i)    &#123;        cin >> u >> v >> f >> c;        g.addedge(u,v,f,c);    &#125;    auto ans = g.solve();    cout << ans.first << " " << ans.second << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大费用最大流"><a href="#最大费用最大流" class="headerlink" title="最大费用最大流"></a>最大费用最大流</h3><p>因为我们考虑这样子的一件事情，我们在求$MCMF$的时候实际上求的是最小的费用那么我们只需要建负边并且最终答案取反就可以了</p><h4 id="P4015"><a href="#P4015" class="headerlink" title="P4015"></a>P4015</h4><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">MinCostGraph<ll> g1,g2;int n,m,s,t;int main()&#123;    ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);    cin >> n >> m;    s = n + m + 1;    t = n + m + 2;    g1.init(s,t,t);    g2.init(s,t,t);    for(int i = 1,x;i <= n;++i)    &#123;        cin >> x;        g1.addedge(s,i,x,0);        g2.addedge(s,i,x,0);    &#125;    for(int i = 1,x;i <= m;++i)    &#123;        cin >> x;        g1.addedge(i + n,t,x,0);        g2.addedge(i + n,t,x,0);    &#125;    for(int i = 1;i <= n;++i)    &#123;        for(int j = 1;j <= m;++j)        &#123;            int x;            cin >> x;            g1.addedge(i,j + n,1 << 30,x);            g2.addedge(i,j + n,1 << 30,-x);        &#125;    &#125;    auto ans1 = g1.solve();    auto ans2 = g2.solve();    cout << ans1.second << "\n" << -ans2.second << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化建图"><a href="#优化建图" class="headerlink" title="优化建图"></a>优化建图</h3><p><a href="https://codeforces.com/problemset/problem/1525/D">Problem - 1525D - Codeforces</a></p><p><strong>题意:</strong> 给定$n$个座位，每个座位刚开始有两个数字$1$和$0$，题目保证初始给定的$1$的数量少于$0$的数量，将一个$1$移动位置需要$abs(i - j)$的贡献，问让刚开始的$1$全部变成$0$最少需要多少贡献</p><p><strong>解题思路:</strong> 其实刚开始看到题目就想着是裸的费用流，将两种点分在两边，中间连接相对应的边权即可，但是后面发现这样子写的话会有问题。但是考虑反正$1$只会往相邻的$0$移动，那么就相邻的两边建边即可</p><pre class="line-numbers language-line-numbers language-c++"><code class="language-line-numbers language-c++">#include <bits/stdc++.h>using namespace std;typedef long long ll;const int V = 20100;const int E = 521000;template<typename T>struct MinCostGraph&#123;    int s,t,vtot;    int head[V],cur[V],etot;    T dis[V],flow,cost;    int pre[V];    bool vis[V];    struct edge    &#123;        int v,nxt;        T f,c;    &#125;e[E * 2];    void addedge(int u,int v, T f, T c, T f2 = 0)    &#123;        e[etot] = &#123;v, head[u], f, c&#125;; head[u] = etot++;        e[etot] = &#123;u, head[v], f2, -c&#125;; head[v] = etot++;    &#125;    bool spfa()    &#123;        T inf = numeric_limits<T>::max() / 2;//防止溢出        for(int i = 1; i <= vtot; ++i)        &#123;            dis[i] = inf;            vis[i] = false;            pre[i] = -1; //记录一下上一条边,方便增广        &#125;        dis[s] = 0;        vis[s] = true;        queue<int> q;        q.push(s);        while(!q.empty())        &#123;            auto u = q.front();            for(int i = head[u]; ~i; i = e[i].nxt)            &#123;                int v = e[i].v;                if(e[i].f && dis[v] > dis[u] + e[i].c)                &#123;                    dis[v] = dis[u] + e[i].c;                    pre[v] = i;                    if(!vis[v])                    &#123;                        vis[v] = 1;                        q.push(v);                    &#125;                &#125;            &#125;            q.pop();            vis[u] = false;        &#125;        return dis[t] != inf;    &#125;    //增广    void augment()    &#123;        int u = t;        T f = numeric_limits<T>::max();        while(~pre[u])        &#123;            f = min(f, e[pre[u]].f);            u = e[pre[u] ^ 1].v;        &#125;        flow += f;        cost += f * dis[t];        u = t;        while(~pre[u])        &#123;            e[pre[u]].f -= f;            e[pre[u] ^ 1].f += f;            u = e[pre[u] ^ 1].v;        &#125;    &#125;    pair<T, T> solve()    &#123;        flow = 0;        cost = 0;        while(spfa()) augment();        return &#123;flow, cost&#125;;    &#125;    void init(int s_, int t_, int vtot_)    &#123;        s = s_;        t = t_;        vtot = vtot_;        etot = 0;        for(int i = 1; i <= vtot; ++i) head[i] = -1;    &#125;&#125;;MinCostGraph<int> g;int n,m,s,t;int a[V];int main()&#123;    cin >> n;    s = n + 1,t = n + 2;    g.init(s,t,t);    vector<int> pos0,pos1;    int ct = 0;    for(int i = 1;i <= n;++i)    &#123;        cin >> a[i];        if(a[i])        &#123;            // ct++;            g.addedge(s,i,1,0);        &#125;        else        &#123;            g.addedge(i,t,1,0);        &#125;    &#125;    for(int i = 1;i <= n - 1;++i)    &#123;        g.addedge(i,i + 1,1 << 30,1);        g.addedge(i + 1,i,1 << 30,1);    &#125;    auto [f,c] = g.solve();    cout << c << "\n";    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 建图 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
