<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mit6.824 Lab2A</title>
      <link href="/2023/04/24/mit6-824-Lab2A/"/>
      <url>/2023/04/24/mit6-824-Lab2A/</url>
      
        <content type="html"><![CDATA[<h1 id="MIT6-824-Lab-2A"><a href="#MIT6-824-Lab-2A" class="headerlink" title="MIT6.824 Lab-2A"></a>MIT6.824 Lab-2A</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>根据查阅资料以及自己查看之后发现对于$2A$中调用的测试$func$都是调用了$make_config$方法。然后因为测试代码中会调用$raft.go$中的$getstate$方法，判断当前的任期以及是否是领导人，然后我们来实现我们的代码，其中借鉴了以下的资料:</p><p><a href="https://blog.csdn.net/weixin_45938441/article/details/124552447?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124552447-blog-127089117.235%5Ev31%5Epc_relevant_default_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-124552447-blog-127089117.235%5Ev31%5Epc_relevant_default_base3&amp;utm_relevant_index=2">https://blog.csdn.net/weixin_45938441/article/details/124552447?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124552447-blog-127089117.235%5Ev31%5Epc_relevant_default_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124552447-blog-127089117.235%5Ev31%5Epc_relevant_default_base3&amp;utm_relevant_index=2</a></p><p><a href="https://zhuanlan.zhihu.com/p/524341057">https://zhuanlan.zhihu.com/p/524341057</a></p><h2 id="选举思路"><a href="#选举思路" class="headerlink" title="选举思路"></a>选举思路</h2><p>首先选举实际上是可以分为两个部分，一个是首次选举，另外一个是再次选举。</p><h3 id="首次选举"><a href="#首次选举" class="headerlink" title="首次选举"></a>首次选举</h3><p>若定时器超时，说明一段时间内没有收到$Leader$的消息，那么这个节点需要转换为$Candiate$,准备竞选$Leader$</p><p>然后我们让这个$Candiate$向其他发送请求，如果超过半数以上的票发送给他那么他就会成为$Leader$，在成功之后会发送一条心跳消息</p><p>如果没有成功那么会隔一段时间之后选举，直到这个节点成为$Leader$或者其他的节点成为$Leader$</p><h3 id="首次选举代码实现"><a href="#首次选举代码实现" class="headerlink" title="首次选举代码实现"></a>首次选举代码实现</h3><p>仔细阅读$Test$代码之后我们可以发现是通过$Make$函数去调用的，那么首先我们需要先对所有节点进行一个初始化，对于初始的状态都先暂时设定他们为$Candiate$。然后对于每个节点的话我们可以启动一个$go$协程去开始计时并且开始选举。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Make</span><span class="token punctuation">(</span>peers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>labrpc<span class="token punctuation">.</span>ClientEnd<span class="token punctuation">,</span> me <span class="token builtin">int</span><span class="token punctuation">,</span>persister <span class="token operator">*</span>Persister<span class="token punctuation">,</span> applyCh <span class="token keyword">chan</span> ApplyMsg<span class="token punctuation">)</span> <span class="token operator">*</span>Raft <span class="token punctuation">&#123;</span>rf <span class="token operator">:=</span> <span class="token operator">&amp;</span>Raft<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>rf<span class="token punctuation">.</span>peers <span class="token operator">=</span> peersrf<span class="token punctuation">.</span>persister <span class="token operator">=</span> persisterrf<span class="token punctuation">.</span>me <span class="token operator">=</span> me<span class="token comment">// Your initialization code here (2A, 2B, 2C).</span>rf<span class="token punctuation">.</span>applyChan <span class="token operator">=</span> applyCh <span class="token comment">//2B</span>rf<span class="token punctuation">.</span>currentTerm <span class="token operator">=</span> <span class="token number">0</span>rf<span class="token punctuation">.</span>votedFor <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>rf<span class="token punctuation">.</span>logs <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>LogEntry<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>rf<span class="token punctuation">.</span>commitIndex <span class="token operator">=</span> <span class="token number">0</span>rf<span class="token punctuation">.</span>lastApplied <span class="token operator">=</span> <span class="token number">0</span>rf<span class="token punctuation">.</span>nextIndex <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>peers<span class="token punctuation">)</span><span class="token punctuation">)</span>rf<span class="token punctuation">.</span>matchIndex <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>peers<span class="token punctuation">)</span><span class="token punctuation">)</span>rf<span class="token punctuation">.</span>status <span class="token operator">=</span> Candidaterf<span class="token punctuation">.</span>overtime <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span><span class="token number">150</span><span class="token operator">+</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecondrf<span class="token punctuation">.</span>timer <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>overtime<span class="token punctuation">)</span><span class="token comment">// initialize from state persisted before a crash</span>rf<span class="token punctuation">.</span><span class="token function">readPersist</span><span class="token punctuation">(</span>persister<span class="token punctuation">.</span><span class="token function">ReadRaftState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// start ticker goroutine to start elections</span><span class="token keyword">go</span> rf<span class="token punctuation">.</span><span class="token function">ticker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> rf<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先我们这个节点一定是需要还存活的，因此我们可以使用一个$select$语句（因为一个$Raft$的计时器是放在一个$channel$中的,$select$语句专门进行处理这个问题），然后我们对目前如果已经超时的节点我们就将其丢出。然后我们开始进行选举，首先对于每一个已经开始选举的候选人设定一个计时器，当然为了防止出现多个候选人并且投票时间相同的情况，我们可以使用$rand$来控制相对应的时间。然后我们就暴力的去寻找其他的每个节点向他们发送一个投票请求。 </p><p>在这里在进行RPC请求的时候其实还需要两个结构体，一个是$RequestVoteArgs$,另外一个是$RequestVoteReply$，对于这两个部分我们直接按照论文中的定义即可</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// example RequestVote RPC arguments structure.</span><span class="token comment">// field names must start with capital letters!</span><span class="token keyword">type</span> RequestVoteArgs <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your data here (2A, 2B).</span>Term         <span class="token builtin">int</span> <span class="token comment">//需要竞选的人的任期</span>CandidateId  <span class="token builtin">int</span> <span class="token comment">// 需要竞选的人的Id</span>LastLogIndex <span class="token builtin">int</span> <span class="token comment">// 竞选人日志条目最后索引</span>LastLogTerm  <span class="token builtin">int</span> <span class="token comment">// 候选人最后日志条目的任期号</span><span class="token punctuation">&#125;</span><span class="token comment">// example RequestVote RPC reply structure.</span><span class="token comment">// field names must start with capital letters!</span><span class="token comment">// 如果竞选者任期比自己的任期还短，那就不投票，返回false</span><span class="token comment">// 如果当前节点的votedFor为空，且竞选者的日志条目跟收到者的一样新则把票投给该竞选者</span><span class="token keyword">type</span> RequestVoteReply <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your data here (2A).</span>Term        <span class="token builtin">int</span>       <span class="token comment">// 投票方的term，如果竞选者比自己还低就改为这个</span>VoteGranted <span class="token builtin">bool</span>      <span class="token comment">// 是否投票给了该竞选人</span>VoteState   VoteState <span class="token comment">// 投票状态</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们这个节点已经是$Leader$了，那么对于其他节点我们是要去更新剩下的日志数量的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">ticker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> rf<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your code here to check if a leader election should</span><span class="token comment">// be started and to randomize sleeping time using</span><span class="token comment">// time.Sleep().</span><span class="token comment">//当定时器结束进行超时选举</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>rf<span class="token punctuation">.</span>timer<span class="token punctuation">.</span>C<span class="token punctuation">:</span><span class="token keyword">if</span> rf<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span>rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> rf<span class="token punctuation">.</span>status <span class="token operator">==</span> Follower <span class="token punctuation">&#123;</span>rf<span class="token punctuation">.</span>status <span class="token operator">=</span> Candidate<span class="token punctuation">&#125;</span><span class="token keyword">if</span> rf<span class="token punctuation">.</span>status <span class="token operator">==</span> Candidate <span class="token punctuation">&#123;</span>rf<span class="token punctuation">.</span>currentTerm <span class="token operator">+=</span> <span class="token number">1</span>rf<span class="token punctuation">.</span>votedFor <span class="token operator">=</span> rf<span class="token punctuation">.</span>mevotedNums <span class="token operator">:=</span> <span class="token number">1</span>rf<span class="token punctuation">.</span>overtime <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Duration</span><span class="token punctuation">(</span><span class="token number">150</span><span class="token operator">+</span>rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecondrf<span class="token punctuation">.</span>timer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>overtime<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>peers<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> i <span class="token operator">==</span> rf<span class="token punctuation">.</span>me <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>voteArgs <span class="token operator">:=</span> RequestVoteArgs<span class="token punctuation">&#123;</span>Term<span class="token punctuation">:</span>         rf<span class="token punctuation">.</span>currentTerm<span class="token punctuation">,</span>CandidateId<span class="token punctuation">:</span>  rf<span class="token punctuation">.</span>me<span class="token punctuation">,</span>LastLogIndex<span class="token punctuation">:</span> <span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>logs<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span>LastLogTerm<span class="token punctuation">:</span>  <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>logs<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>voteArgs<span class="token punctuation">.</span>LastLogTerm <span class="token operator">=</span> rf<span class="token punctuation">.</span>logs<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>logs<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Term<span class="token punctuation">&#125;</span>voteReply <span class="token operator">:=</span> RequestVoteReply<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">go</span> rf<span class="token punctuation">.</span><span class="token function">sendRequestVote</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>voteArgs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>voteReply<span class="token punctuation">,</span> <span class="token operator">&amp;</span>votedNums<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> rf<span class="token punctuation">.</span>status <span class="token operator">==</span> Leader <span class="token punctuation">&#123;</span>appendNums <span class="token operator">:=</span> <span class="token number">1</span>rf<span class="token punctuation">.</span>timer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>HeartBeatTimeout<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>peers<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> i <span class="token operator">==</span> rf<span class="token punctuation">.</span>me <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">&#125;</span>appendEntriesArgs <span class="token operator">:=</span> AppendEntriesArgs<span class="token punctuation">&#123;</span>Term<span class="token punctuation">:</span>         rf<span class="token punctuation">.</span>currentTerm<span class="token punctuation">,</span>LeaderId<span class="token punctuation">:</span>     rf<span class="token punctuation">.</span>me<span class="token punctuation">,</span>PrevLogTerm<span class="token punctuation">:</span>  <span class="token number">0</span><span class="token punctuation">,</span>PrevLogIndex<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>Entries<span class="token punctuation">:</span>      <span class="token boolean">nil</span><span class="token punctuation">,</span>LeaderCommit<span class="token punctuation">:</span> rf<span class="token punctuation">.</span>commitIndex<span class="token punctuation">,</span><span class="token punctuation">&#125;</span>appendEntriesReply <span class="token operator">:=</span> AppendEntriesReply<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">go</span> rf<span class="token punctuation">.</span><span class="token function">sendAppendEntries</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>appendEntriesArgs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>appendEntriesReply<span class="token punctuation">,</span> <span class="token operator">&amp;</span>appendNums<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们接着来考虑刚刚输送投票请求的函数，我们传递的是三个参数一个是投票的$Args$，一个是投票的$Reply$，另外一个就是当前这个候选人已经收到了多少票，然后我们再次开启一个$go$协程去输送每个投票请求。然后对于每个投票请求，我们先不断使用$RPC$去进行请求，根据论文里面所描述的，如果当前这个节点仍然存在那么我们就一直向他发送请求。</p><p>接下来我们来看一下$RPC$请求，如果当前节点$crash$了之后，那么我们就设置相对应的$Reply$的状态是不可投递的；</p><p>然后如果竞选者的任期实际上是要比这个节点要小的，那么我们也不给他投票，并且在$Reply$中打上一个$Expire$(过期)的标签，这里需要提一嘴的是过期可能是因为出现网络分区或者其他原因导致的；然后考虑还没有投票的情况：然后如果传进来的任期确实比本身这个节点任期要大的话，那么我们就更新这个节点成为$Foller$，并且我们在这里考虑第二个匹配条件判断最后一个$Log$日志是否比候选人的最后一个$Log$日志要大。</p><p>如果这个已经投票了，来自同一轮但是是不同竞选者，告诉她自己已经没票了；要么可能因为网络问题导致的，那就$continue$掉</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// RequestVote</span><span class="token comment">// example RequestVote RPC handler.</span><span class="token comment">// 个人认为定时刷新的地方应该是别的节点与当前节点在数据上不冲突时就要刷新</span><span class="token comment">// 因为如果不是数据冲突那么定时相当于防止自身去选举的一个心跳</span><span class="token comment">// 如果是因为数据冲突，那么这个节点不用刷新定时是为了当前整个raft能尽快有个正确的leader</span><span class="token comment">//</span><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">RequestVote</span><span class="token punctuation">(</span>args <span class="token operator">*</span>RequestVoteArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>RequestVoteReply<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// Your code here (2A, 2B).</span><span class="token comment">//defer fmt.Printf("[    func-RequestVote-rf(%+v)] : return %v\n", rf.me, reply)</span>rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 当前节点crash</span><span class="token keyword">if</span> rf<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>VoteState <span class="token operator">=</span> Killedreply<span class="token punctuation">.</span>Term <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span>reply<span class="token punctuation">.</span>VoteGranted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">//reason: 出现网络分区，该竞选者已经OutOfDate(过时）</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>Term <span class="token operator">&lt;</span> rf<span class="token punctuation">.</span>currentTerm <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>VoteState <span class="token operator">=</span> Expirereply<span class="token punctuation">.</span>Term <span class="token operator">=</span> rf<span class="token punctuation">.</span>currentTermreply<span class="token punctuation">.</span>VoteGranted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>Term <span class="token operator">></span> rf<span class="token punctuation">.</span>currentTerm <span class="token punctuation">&#123;</span><span class="token comment">// 重置自身的状态</span>rf<span class="token punctuation">.</span>status <span class="token operator">=</span> Followerrf<span class="token punctuation">.</span>currentTerm <span class="token operator">=</span> args<span class="token punctuation">.</span>Termrf<span class="token punctuation">.</span>votedFor <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token comment">//fmt.Printf("[    func-RequestVote-rf(%+v)] : rf.voted: %v\n", rf.me, rf.votedFor)</span><span class="token comment">// 此时比自己任期小的都已经把票还原</span><span class="token keyword">if</span> rf<span class="token punctuation">.</span>votedFor <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#123;</span>currentLogIndex <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>logs<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>currentLogTerm <span class="token operator">:=</span> <span class="token number">0</span><span class="token comment">// 如果currentLogIndex下标不是-1就把term赋值过来</span><span class="token keyword">if</span> currentLogIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>currentLogTerm <span class="token operator">=</span> rf<span class="token punctuation">.</span>logs<span class="token punctuation">[</span>currentLogIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>Term<span class="token punctuation">&#125;</span><span class="token comment">//  If votedFor is null or candidateId, and candidate’s log is at least as up-to-date as receiver’s log, grant vote (§5.2, §5.4)</span><span class="token comment">// 论文里的第二个匹配条件，当前peer要符合arg两个参数的预期</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>LastLogIndex <span class="token operator">&lt;</span> currentLogIndex <span class="token operator">||</span> args<span class="token punctuation">.</span>LastLogTerm <span class="token operator">&lt;</span> currentLogTerm <span class="token punctuation">&#123;</span>reply<span class="token punctuation">.</span>VoteState <span class="token operator">=</span> Expirereply<span class="token punctuation">.</span>VoteGranted <span class="token operator">=</span> <span class="token boolean">false</span>reply<span class="token punctuation">.</span>Term <span class="token operator">=</span> rf<span class="token punctuation">.</span>currentTerm<span class="token keyword">return</span><span class="token punctuation">&#125;</span><span class="token comment">// 给票数，并且返回true</span>rf<span class="token punctuation">.</span>votedFor <span class="token operator">=</span> args<span class="token punctuation">.</span>CandidateIdreply<span class="token punctuation">.</span>VoteState <span class="token operator">=</span> Normalreply<span class="token punctuation">.</span>Term <span class="token operator">=</span> rf<span class="token punctuation">.</span>currentTermreply<span class="token punctuation">.</span>VoteGranted <span class="token operator">=</span> <span class="token boolean">true</span>rf<span class="token punctuation">.</span>timer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>overtime<span class="token punctuation">)</span><span class="token comment">//fmt.Printf("[    func-RequestVote-rf(%v)] : voted rf[%v]\n", rf.me, rf.votedFor)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 只剩下任期相同，但是票已经给了，此时存在两种情况</span>reply<span class="token punctuation">.</span>VoteState <span class="token operator">=</span> Votedreply<span class="token punctuation">.</span>VoteGranted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token comment">// 1、当前的节点是来自同一轮，不同竞选者的，但是票数已经给了(又或者它本身自己就是竞选者）</span><span class="token keyword">if</span> rf<span class="token punctuation">.</span>votedFor <span class="token operator">!=</span> args<span class="token punctuation">.</span>CandidateId <span class="token punctuation">&#123;</span><span class="token comment">// 告诉reply票已经没了返回false</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 2. 当前的节点票已经给了同一个人了，但是由于sleep等网络原因，又发送了一次请求</span><span class="token comment">// 重置自身状态</span>rf<span class="token punctuation">.</span>status <span class="token operator">=</span> Follower<span class="token punctuation">&#125;</span>rf<span class="token punctuation">.</span>timer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>overtime<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们继续看$sendVoted$的请求，因为我们已经放出去了，那么实际上返回的可能有如下的结果</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>Normal VoteState <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">//投票过程正常</span>Killed                  <span class="token comment">//Raft节点已终止</span>Expire                  <span class="token comment">//投票(消息\竞选者）过期</span>Voted                   <span class="token comment">//本Term内已经投过票</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们来思考怎么处理这些结果，首先如果是消息已经过期了，那么需要将自己编程追随和并且重新设定时间；如果是正常或者确认投票的话，我们统计相对应的票数，如果最后的票数超过半数的话，那么我们可以清空相对应的票数并且在$nextIndex$中放入接下来需要的日志信息</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">sendRequestVote</span><span class="token punctuation">(</span>server <span class="token builtin">int</span><span class="token punctuation">,</span> args <span class="token operator">*</span>RequestVoteArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>RequestVoteReply<span class="token punctuation">,</span> voteNums <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> rf<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span>ok <span class="token operator">:=</span> rf<span class="token punctuation">.</span>peers<span class="token punctuation">[</span>server<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"Raft.RequestVote"</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> reply<span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span><span class="token comment">// 失败重传</span><span class="token keyword">if</span> rf<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span>ok <span class="token operator">=</span> rf<span class="token punctuation">.</span>peers<span class="token punctuation">[</span>server<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"Raft.RequestVote"</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> reply<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//fmt.Printf("[sendRequestVote(%v) ] : send a election to %v\n", rf.me, server)</span><span class="token comment">// 由于网络分区，请求投票的人的term的比自己的还小，不给予投票</span><span class="token keyword">if</span> args<span class="token punctuation">.</span>Term <span class="token operator">&lt;</span> rf<span class="token punctuation">.</span>currentTerm <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token comment">// 对reply的返回情况进行分支处理</span><span class="token keyword">switch</span> reply<span class="token punctuation">.</span>VoteState <span class="token punctuation">&#123;</span><span class="token comment">// 消息过期有两种情况:</span><span class="token comment">// 1.是本身的term过期了比节点的还小</span><span class="token comment">// 2.是节点日志的条目落后于节点了</span><span class="token keyword">case</span> Expire<span class="token punctuation">:</span><span class="token punctuation">&#123;</span>rf<span class="token punctuation">.</span>status <span class="token operator">=</span> Followerrf<span class="token punctuation">.</span>timer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>overtime<span class="token punctuation">)</span><span class="token keyword">if</span> reply<span class="token punctuation">.</span>Term <span class="token operator">></span> rf<span class="token punctuation">.</span>currentTerm <span class="token punctuation">&#123;</span>rf<span class="token punctuation">.</span>currentTerm <span class="token operator">=</span> reply<span class="token punctuation">.</span>Termrf<span class="token punctuation">.</span>votedFor <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> Normal<span class="token punctuation">,</span> Voted<span class="token punctuation">:</span><span class="token comment">//根据是否同意投票，收集选票数量</span><span class="token keyword">if</span> reply<span class="token punctuation">.</span>VoteGranted <span class="token operator">&amp;&amp;</span> reply<span class="token punctuation">.</span>Term <span class="token operator">==</span> rf<span class="token punctuation">.</span>currentTerm <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>voteNums <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>peers<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>voteNums<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token comment">// 票数超过一半</span><span class="token keyword">if</span> <span class="token operator">*</span>voteNums <span class="token operator">>=</span> <span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>peers<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">&#123;</span><span class="token operator">*</span>voteNums <span class="token operator">=</span> <span class="token number">0</span><span class="token comment">// 本身就是leader在网络分区中更具有话语权的leader</span><span class="token keyword">if</span> rf<span class="token punctuation">.</span>status <span class="token operator">==</span> Leader <span class="token punctuation">&#123;</span><span class="token keyword">return</span> ok<span class="token punctuation">&#125;</span><span class="token comment">// 本身不是leader，那么需要初始化nextIndex数组</span>rf<span class="token punctuation">.</span>status <span class="token operator">=</span> Leaderrf<span class="token punctuation">.</span>nextIndex <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>peers<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token keyword">range</span> rf<span class="token punctuation">.</span>nextIndex <span class="token punctuation">&#123;</span>rf<span class="token punctuation">.</span>nextIndex<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>logs<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>rf<span class="token punctuation">.</span>timer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>HeartBeatTimeout<span class="token punctuation">)</span><span class="token comment">//fmt.Printf("[sendRequestVote-func-rf(%v)] be a leader\n", rf.me)</span><span class="token punctuation">&#125;</span><span class="token keyword">case</span> Killed<span class="token punctuation">:</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> ok<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="再次选举"><a href="#再次选举" class="headerlink" title="再次选举"></a>再次选举</h3><p>再次选举已经是后面的东西啦~</p>]]></content>
      
      
      
        <tags>
            
            <tag> MIT6.824 </tag>
            
            <tag> 分布式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goroutine</title>
      <link href="/2023/03/02/Goroutine/"/>
      <url>/2023/03/02/Goroutine/</url>
      
        <content type="html"><![CDATA[<h1 id="Go协程、通道、同步"><a href="#Go协程、通道、同步" class="headerlink" title="Go协程、通道、同步"></a>Go协程、通道、同步</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>在讲解并发的时候我们总会提及到另外一个概念叫并行。现在我们来理解并发和并行之间的区别</p><ul><li>并发：把任务在不同的时间点交给处理器进行处理，在统一时间点任务并不会同时运行</li><li>并行：把每一个任务分配给每一个处理器独立完成。在统一时间点任务一定是同时进行</li></ul><p>两个概念的区别在于：任务是否同时执行</p><p>$GO$在$GOMAXPROCS$数量和任务相同时，可以左到并行执行，但是一般情况下都是并发执行</p><ul><li>我们可以用<code>runtime.GOMAXPROCS(runtime.NumCPU())</code> 来查看$CPU$的数量</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程是轻量级的执行线程。</p><p>假设我们有一个函数$f(s)$,我们一般会 同步的调用它</p><p>使用$go \ f(s)$在一个协程中调用这个函数的话，这个新的$Go$协程将会并发的执行这个函数</p><p>我们需要注意的是，在使用 $go$ 关键字创建 $go \ routing$的时候，被调用函数的返回值会被忽略</p><p>我们也可以为匿名函数启动一个协程</p><p>现在两个协程在独立的协程中异步的执行，然后等待两个协程完成，我们后面会使用$WaitGroup$方法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">":"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"direct"</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"go routing"</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>msg <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token string">"going"</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"done"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">direct <span class="token punctuation">:</span> <span class="token number">1</span>direct <span class="token punctuation">:</span> <span class="token number">2</span><span class="token keyword">go</span> routing <span class="token punctuation">:</span> <span class="token number">0</span><span class="token keyword">go</span> routing <span class="token punctuation">:</span> <span class="token number">1</span><span class="token keyword">go</span> routing <span class="token punctuation">:</span> <span class="token number">2</span>goingdone<span class="token comment">//</span>direct <span class="token punctuation">:</span> <span class="token number">1</span>direct <span class="token punctuation">:</span> <span class="token number">2</span>going<span class="token keyword">go</span> routing <span class="token punctuation">:</span> <span class="token number">0</span><span class="token keyword">go</span> routing <span class="token punctuation">:</span> <span class="token number">1</span><span class="token keyword">go</span> routing <span class="token punctuation">:</span> <span class="token number">2</span>done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>观察上述结果我们会发现$direct : 0$丢失了，初步推测是与协程有关，于是我又在第一个协程前面加了一个$Sleep$，那么现在就可以正常输出了</p><p>$main$函数也是一个$goroutine$，那么我们可以用如下的代码来说明</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">running</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>now <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>now<span class="token operator">++</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"tick:"</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token function">running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> ipt <span class="token builtin">string</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ipt<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ipt<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面的代码中，$running$是一个无限循环，但是我们在使用协程启动它的时候，我们发现对于下面的输入字符串也可以输入</p><h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p>通道是连接多个协程的管道。我们可以从一个协程将值发到通道，然后再另外一个协程中接收</p><h3 id="通道发送和接收信息"><a href="#通道发送和接收信息" class="headerlink" title="通道发送和接收信息"></a>通道发送和接收信息</h3><p>我们可以使用<code>var 通道变量 chan 通道类型</code> 来声明一个通道的元素类型。</p><ul><li>通道类型：通道内的数据类型</li><li>通道变量：保存通道的变量</li></ul><p>$chan$类型的空值是$nil$，声明后需要配合$make$才能使用</p><p>这里我们看一下通道的语法，使用 <code>通道变量 &lt;- 值</code>语法发送一个新的值到通道中。我们再一个新的协程中发送$ping$到上面创建的$message$管道中</p><p>然后再接收的时候我们可以使用<code>值&lt;-通道变量</code> 语法从通道中接收一个值。这里我们会收到在上面发送的$ping$消息并且将其打印出来</p><p>我们运行程序时，通过通道，成功的将消息$ping$从一个协程传送到了另外一个协程中</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>messages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> messages <span class="token operator">&lt;-</span> <span class="token string">"ping"</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span>messagesfmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T\n"</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token builtin">string</span>ping<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="示例：并发打印"><a href="#示例：并发打印" class="headerlink" title="示例：并发打印"></a>示例：并发打印</h3><p>使用无缓冲通道往里面塞入数据的时候，装入方将被阻塞，直到另外通道在另外一个goroutine中被取出。同样，如果通道中没有放入任何数据，接收方试图从通道中获取数据时，同样也是阻塞。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">printer</span><span class="token punctuation">(</span>c <span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>data <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c<span class="token keyword">if</span> data <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//通知main已经结束循环</span>c <span class="token operator">&lt;-</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">printer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>c <span class="token operator">&lt;-</span> i<span class="token punctuation">&#125;</span><span class="token comment">//通知并发的printer结束循环</span>c <span class="token operator">&lt;-</span> <span class="token number">0</span><span class="token comment">//等待printer结束</span>now <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c<span class="token keyword">if</span> now <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ending!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="通道缓冲"><a href="#通道缓冲" class="headerlink" title="通道缓冲"></a>通道缓冲</h3><p>默认情况下通道是无缓冲的，这意味着对应的接收通道<code>&lt;-chan</code> 准备号接收时，才允许发送<code>chan&lt;-</code> </p><p>有缓冲通道允许再没有对应接收者的情况，缓存一定数量的值，只有当空间被存储满的时候才会发生堵塞。</p><p>那么我们创建带有缓冲通道的方法也是<code>通道实例 :=  make(chan 通道类型，缓冲大小)</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>messages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>messages <span class="token operator">&lt;-</span> <span class="token string">"im first"</span>messages <span class="token operator">&lt;-</span> <span class="token string">"im second"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>messages<span class="token punctuation">)</span><span class="token comment">//fmt.Println(messages)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中我们给$messages$放了两个值，然后我们运行起来发现，欸它死锁了，因为通道需要接收两个数值但是目前有一个在通道中有一个还没有进去。</p><p>那么我们可以把通道加大，这样子两个数值就可以输出来了</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>messages <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>messages <span class="token operator">&lt;-</span> <span class="token string">"im first"</span>messages <span class="token operator">&lt;-</span> <span class="token string">"im second"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>messages<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>messages<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">im firstim second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="阻塞条件"><a href="#阻塞条件" class="headerlink" title="阻塞条件"></a>阻塞条件</h4><p>带缓冲通道仍然会在下面列举的情况下依然会发生阻塞：</p><ul><li>带缓冲通道被填满的时候，尝试再次发送数据会发生堵塞</li><li>带缓冲通道为空的时候，尝试接收数据时会再次发生堵塞</li></ul><p>为什么$Go$语言要限制长度而不提供无限长度的通道</p><p>内存将不断膨胀直到应用崩溃</p><h3 id="循环接收"><a href="#循环接收" class="headerlink" title="循环接收"></a>循环接收</h3><p>通道的数据接收可以借用 $for \ range$ 语句进行多个元素的接收操作</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">running</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>now <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>now<span class="token operator">++</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"tick:"</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">&lt;-</span> itime<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> data <span class="token operator">:=</span> <span class="token keyword">range</span> ch <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token keyword">if</span> data <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">3</span><span class="token number">2</span><span class="token number">1</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这里有一个点就是在管道输出的时候为什么我输出到最后一个的时候我就需要$break$掉呢？</p><p>因为如果继续发送，由于接收的$goroutine$已经退出，没有$goroutine$发送到管道，因此运行时会触发宕机报错</p><h3 id="实例：模拟远程过程调用-RPC"><a href="#实例：模拟远程过程调用-RPC" class="headerlink" title="实例：模拟远程过程调用(RPC)"></a>实例：模拟远程过程调用(RPC)</h3><p>服务器开发中会使用$RPC$来简化进程间通信的过程。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>   <span class="token string">"errors"</span>   <span class="token string">"fmt"</span>   <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">RPCClient</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">,</span> req <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//向服务器发送一个请求</span>   ch <span class="token operator">&lt;-</span> req   <span class="token comment">//等待服务器返回</span>   <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">case</span> ack <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>      <span class="token keyword">return</span> ack<span class="token punctuation">,</span> <span class="token boolean">nil</span>   <span class="token keyword">case</span> <span class="token operator">&lt;-</span>time<span class="token punctuation">.</span><span class="token function">After</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"Time out"</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">RPCServer</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//接收请求</span>      data <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch      <span class="token comment">//打印接收到的数据</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Server receiver:"</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>      <span class="token comment">//反馈给用户自己已经收到</span>      ch <span class="token operator">&lt;-</span> <span class="token string">"haoye"</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token comment">//创建一个无缓冲字符串通道</span>   ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span>   <span class="token comment">//并发执行服务器逻辑</span>   <span class="token keyword">go</span> <span class="token function">RPCServer</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>   <span class="token comment">//客户端请求数据和接收数据</span>   recv<span class="token punctuation">,</span> err <span class="token operator">:=</span> <span class="token function">RPCClient</span><span class="token punctuation">(</span>ch<span class="token punctuation">,</span> <span class="token string">"hi"</span><span class="token punctuation">)</span>   <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//发生打印错误</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token comment">//正常接收到数据</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Client Received"</span><span class="token punctuation">,</span> recv<span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Server receiver: hi  Client Received haoye<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上述代码永远不会发生超时因为处理的很快，因此我们可以在服务器中加一句$sleep$来模拟超时</p><h3 id="关闭通道之后继续使用通道"><a href="#关闭通道之后继续使用通道" class="headerlink" title="关闭通道之后继续使用通道"></a>关闭通道之后继续使用通道</h3><p>我们可以使用<code>close()</code> 来关闭一个通道</p><p>关闭的通道仍然可以被访问，但是访问被关闭的通道将会出现一些问题</p><h4 id="给被关闭的通道发送数据将会触发panic"><a href="#给被关闭的通道发送数据将会触发panic" class="headerlink" title="给被关闭的通道发送数据将会触发panic"></a>给被关闭的通道发送数据将会触发panic</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %d"</span><span class="token punctuation">,</span> <span class="token function">cap</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">)</span>ch <span class="token operator">&lt;-</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">0</span> 0panic<span class="token punctuation">:</span> send on closed channel    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="从已关闭的通道接收数据的时候将不会发生堵塞"><a href="#从已关闭的通道接收数据的时候将不会发生堵塞" class="headerlink" title="从已关闭的通道接收数据的时候将不会发生堵塞"></a>从已关闭的通道接收数据的时候将不会发生堵塞</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>ch <span class="token operator">&lt;-</span> <span class="token number">1</span>ch <span class="token operator">&lt;-</span> <span class="token number">2</span><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">cap</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> <span class="token operator">&lt;-</span>chfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> ok<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们故意设定遍历的值时这个管道的容量+1，然后我们去看输出的数值</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1</span> <span class="token boolean">true</span><span class="token number">2</span> <span class="token boolean">true</span> <span class="token number">0</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们可以发现通道空了的话默认返回$0$,但是获取的时候不会堵塞，取出数据的时候会发生失败的状况。</p><h2 id="同步——保证并发环境下数据访问的正确性"><a href="#同步——保证并发环境下数据访问的正确性" class="headerlink" title="同步——保证并发环境下数据访问的正确性"></a>同步——保证并发环境下数据访问的正确性</h2><p>$Go$程序可以使用通道进行多个$goroutine$间的数据交换，这仅仅时数据同步中的一种方法</p><h3 id="竞态检测"><a href="#竞态检测" class="headerlink" title="竞态检测"></a>竞态检测</h3><p>当多线程并发运行的程序竞争访问和修改同一块资源时，会发生竞争问题</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"sync/atomic"</span><span class="token punctuation">)</span><span class="token keyword">var</span> seq <span class="token builtin">int64</span><span class="token keyword">func</span> <span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int64</span> <span class="token punctuation">&#123;</span><span class="token comment">//尝试原子的增加序列号</span>atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>seq<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> seq<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们在运行的时候加上<code>race</code>参数，使用<code>go run - race demo16.go</code></p><p>然后会发现调用go GetId的时候会存在竞态问题</p><p>那么我们可以这么修改</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">return</span> atomic<span class="token punctuation">.</span><span class="token function">AddInt64</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>seq<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="互斥锁——保证同时只有一个goroutine可以访问共享资源"><a href="#互斥锁——保证同时只有一个goroutine可以访问共享资源" class="headerlink" title="互斥锁——保证同时只有一个goroutine可以访问共享资源"></a>互斥锁——保证同时只有一个goroutine可以访问共享资源</h3><p>加锁，使得当前设置这个count变量以及获取这个变量的时候是安全的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">var</span> <span class="token punctuation">(</span>count      <span class="token builtin">int</span>countGuard sync<span class="token punctuation">.</span>Mutex<span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">GetCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>countGuard<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">defer</span> countGuard<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">return</span> count<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">SetCount</span><span class="token punctuation">(</span>c <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>countGuard<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>count <span class="token operator">=</span> ccountGuard<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">SetCount</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">GetCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读写互斥锁–在读比写多的环境下比互斥锁更加高效"><a href="#读写互斥锁–在读比写多的环境下比互斥锁更加高效" class="headerlink" title="读写互斥锁–在读比写多的环境下比互斥锁更加高效"></a>读写互斥锁–在读比写多的环境下比互斥锁更加高效</h3><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>除了可以使用通道和互斥锁进行两个并发程序的同步以外，还可以使用等待组进行多个任务的同步</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>(wg *WaitGroup) add(delta int)</td><td>等待组的计数器+1</td></tr><tr><td>(wg *WaitGroup) Done()</td><td>等待组的计数器-1</td></tr><tr><td>(wg *WaitGroup) Wait()</td><td>当等待组计数器不等于0时阻塞直到变0</td></tr></tbody></table><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"net/http"</span><span class="token string">"sync"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//声明一个等待组</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token comment">//准备网站地址</span><span class="token keyword">var</span> urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"https://blog.yokito.cn"</span><span class="token punctuation">,</span><span class="token string">"https://www.qiniu.com"</span><span class="token punctuation">,</span><span class="token string">"https://gobyexample-cn.github.io/"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token comment">//遍历这些地址</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> url <span class="token operator">:=</span> <span class="token keyword">range</span> urls <span class="token punctuation">&#123;</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//开启并发</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>url <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//等待所有的任务完成</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>qiniu<span class="token punctuation">.</span>com <span class="token operator">&lt;</span><span class="token boolean">nil</span><span class="token operator">></span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>yokito<span class="token punctuation">.</span>cn <span class="token operator">&lt;</span><span class="token boolean">nil</span><span class="token operator">></span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>gobyexample<span class="token operator">-</span>cn<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token operator">/</span> <span class="token operator">&lt;</span><span class="token boolean">nil</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>还有一个例子我们也可以来看一看</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"sync"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//声明一个等待组</span><span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//开启并发</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>num <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Worker %d starting\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"Worker %d ended\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//等待所有的任务完成</span>wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">Worker <span class="token number">1</span> startingWorker <span class="token number">3</span> startingWorker <span class="token number">4</span> startingWorker <span class="token number">2</span> startingWorker <span class="token number">5</span> startingWorker <span class="token number">5</span> endedWorker <span class="token number">3</span> endedWorker <span class="token number">4</span> endedWorker <span class="token number">1</span> endedWorker <span class="token number">2</span> ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Goroutine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Basic</title>
      <link href="/2023/03/02/Go-Basic/"/>
      <url>/2023/03/02/Go-Basic/</url>
      
        <content type="html"><![CDATA[<h1 id="基础语法学习"><a href="#基础语法学习" class="headerlink" title="基础语法学习"></a>基础语法学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个是个人结合狂神说的视频以及$Go \ By \ Example$来做的结合文件，如果需要学习$Go$的话个人强烈建议去$Go \ Guide$学习</p><p>相关链接如下：</p><p><a href="https://gobyexample-cn.github.io/">Go by Example 中文版 (gobyexample-cn.github.io)</a></p><p><a href="https://github.com/mao888/golang-guide">mao888&#x2F;golang-guide: 「Golang学习+面试指南」一份涵盖大部分 Golang程序员所需要掌握的核心知识。准备 Golang面试，首选 GolangGuide！ (github.com)</a></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">//我是单行注释</span><span class="token comment">/*我是多行注释*/</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello,world"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量是一个没有注释值并且可以随时改变的数值</p><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>在go语言中我们声明一个变量一般使用一个<code>var</code> 关键字:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token keyword">type</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>第一个var是声明变量的关键字，是固定的写法</li><li>第二个name是我们变量的名字</li><li>第三个type是用来代表变量的类型</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"Treasure"</span><span class="token keyword">var</span> age <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">114514</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在对于多个变量进行定义的时候我们可以使用如下的方法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//使用var关键字来定义</span><span class="token keyword">var</span> <span class="token punctuation">(</span>name <span class="token builtin">string</span>age  <span class="token builtin">int</span>addr <span class="token builtin">string</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>整型和浮点型变量的默认值为0 和0.0</li><li>字符串变量的默认值是空字符串</li><li>布尔类型变量默认是false</li><li>切片、函数、指针变量默认是null</li></ul><h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><h4 id="变量初始化的标准格式"><a href="#变量初始化的标准格式" class="headerlink" title="变量初始化的标准格式"></a>变量初始化的标准格式</h4><pre class="line-numbers language-none"><code class="language-none">var 变量名 类型 &#x3D; 值（表达式）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么我们在定义的时候可以这么表示</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">name <span class="token operator">=</span> <span class="token string">"Treasure"</span>age <span class="token operator">=</span> <span class="token number">20</span>addr <span class="token operator">=</span> <span class="token string">"hznu"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="短变量声明并且初始化"><a href="#短变量声明并且初始化" class="headerlink" title="短变量声明并且初始化"></a>短变量声明并且初始化</h4><pre class="line-numbers language-go" data-language="go"><code class="language-go">name <span class="token operator">:=</span> <span class="token string">"treasure"</span>age <span class="token operator">:=</span> <span class="token number">20</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T,%T"</span><span class="token punctuation">,</span> name<span class="token punctuation">,</span> age<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这是go语言中的推导声明写法，编译器会自动根据右值推断出左值的对应类型</p><p>它可以自动推导出一些类型，虽然使用时有限制的：</p><ul><li>定义变量，同时显式初始化</li><li>不能提供数据类型</li><li>只能用在函数内部不能随便导出定义</li></ul><p>但是我们不能定义之后再短变量声明</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token builtin">string</span>name <span class="token operator">:=</span> <span class="token string">"treasure"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样子时错误的捏</p><h3 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> num <span class="token builtin">int</span>num <span class="token operator">=</span> <span class="token number">18</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"num:%d,address:%p\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span> <span class="token comment">//取地址符时&amp;</span>num <span class="token operator">=</span> <span class="token number">114514</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"num:%d,address:%p\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">num:18,address:0xc00001a0a8num:114514,address:0xc00001a0a8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="变量的交换"><a href="#变量的交换" class="headerlink" title="变量的交换"></a>变量的交换</h3><p>go变量交换很快直接交换即可</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">:=</span> <span class="token number">5</span>b <span class="token operator">:=</span> <span class="token number">4</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> b<span class="token punctuation">,</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>匿名变量的特点是一个下划线<code>_</code> ，<code>_</code>本身就是一个特殊的标识符，被称为空白标识符。在赋值的时候我们可以使用下划线<code>_</code> 来去替没有用的一些变量等</p><p>匿名变量是不占用空间的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token boolean">_</span><span class="token punctuation">,</span> b <span class="token operator">:=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>一个变量在程序中都有一定的作用范围，称之为作用域</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>声明在函数体内的，优先使用这个函数体内命名的变量</p><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>声明在外面的可以被所有函数所使用的</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>注意常量实际上不能被修改，使用const前缀即可</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> URL <span class="token operator">=</span> <span class="token string">"acm.hznu.edu.cn"</span><span class="token keyword">const</span> URL2 <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"acm.hznu.edu.cn"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h4><p>特殊常量，可以被认为是一个可以被编译器修改的常量。iota是go语言的常量技术其</p><p>iota在const关键字出现的时候就被重置为0，const每新增一行常量声明将会使得iota计数一次</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">const</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token boolean">iota</span>b <span class="token operator">=</span> <span class="token boolean">iota</span>c <span class="token operator">=</span> <span class="token boolean">iota</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如说对于这一段代码来说输出的a,b,c就是0,1,2</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token boolean">iota</span>bc<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果是这一个部分的话那么其实常量没用定义的情况下会沿用上面这个常量来使用</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">const</span> <span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token boolean">iota</span>   <span class="token comment">//0</span>b          <span class="token comment">//1</span>c          <span class="token comment">//2</span>d <span class="token operator">=</span> <span class="token string">"haha"</span> <span class="token comment">//haha iota3</span>e          <span class="token comment">//haha iota4</span>f <span class="token operator">=</span> <span class="token string">"100"</span>  <span class="token comment">//100 iota 5</span>g          <span class="token comment">// 100 iota6</span>h <span class="token operator">=</span> <span class="token boolean">iota</span>   <span class="token comment">//iota7</span>i          <span class="token comment">//iota8</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">,</span> g<span class="token punctuation">,</span> h<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">0 1 2 haha haha 100 100 7 8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面这一部分代码很显然沿用了iota</p><p>平时使用iota并不多</p><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>布尔类型只有true 或者是false</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> isFlag <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span>isOk <span class="token operator">:=</span> <span class="token boolean">false</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>isFlag<span class="token punctuation">,</span> isOk<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token boolean">true</span> <span class="token boolean">false</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><p>整型int和浮点型float32,float64,Go语言支持整型和浮点型数字并且支持</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//定义一个整型</span><span class="token comment">//byte uint8</span><span class="token comment">//rune int32</span><span class="token comment">//int int64</span><span class="token keyword">var</span> num <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">18</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %d\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token comment">//默认是6为小数打印，保存丢失精度是四舍五入的</span><span class="token keyword">var</span> now <span class="token builtin">float32</span> <span class="token operator">=</span> <span class="token number">1145.14</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %.2f"</span><span class="token punctuation">,</span> now<span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">int 18float32 1145.14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>单引号也就是字符，双引号仍然是一个字符串</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> str <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">"namomo"</span>str <span class="token operator">=</span> <span class="token string">"namo"</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> str<span class="token punctuation">)</span>v1 <span class="token operator">:=</span> <span class="token char">'a'</span>v2 <span class="token operator">:=</span> <span class="token string">"a"</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %c\n"</span><span class="token punctuation">,</span> v1<span class="token punctuation">,</span> v1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T %s\n"</span><span class="token punctuation">,</span> v2<span class="token punctuation">,</span> v2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字符串拼接的话仍然可以使用<code>+</code>来拼接字符</p><pre class="line-numbers language-none"><code class="language-none">fmt.Println(&quot;hello &quot; + str)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于转义字符的话我们可以使用转移符号<code>\</code></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello\" "</span> <span class="token operator">+</span> str<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>go语言并不存在隐式类型转换，因此所有的类型都必须显式的声明</p><pre class="line-numbers language-none"><code class="language-none">valueoftypeB &#x3D; typeB(valueoftypeA) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">// 类型转换</span><span class="token comment">// 转换后的变量 := (要转换的类型)(变量)</span><span class="token comment">// 备注：整型不能转换成为bool</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">:=</span> <span class="token number">3</span>   <span class="token comment">//int</span>b <span class="token operator">:=</span> <span class="token number">5.0</span> <span class="token comment">//float64</span>c <span class="token operator">:=</span> <span class="token function">float32</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//float 32</span>d <span class="token operator">:=</span> <span class="token function">int</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token comment">//整型是不能转换成为bool类型的</span><span class="token comment">//e := bool(a)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%t %f %f %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>我们假设A  &#x3D; 10，B &#x3D; 20</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>相加</td><td>A + B &#x3D; 30</td></tr><tr><td>-</td><td>相减</td><td>A - B &#x3D; -10</td></tr><tr><td>*</td><td>相乘</td><td>A * B &#x3D; 200</td></tr><tr><td>&#x2F;</td><td>相除</td><td>B &#x2F; A &#x3D; 2</td></tr><tr><td>%</td><td>求余</td><td>B % A &#x3D; 0</td></tr><tr><td>++</td><td>自增</td><td>A++ &#x3D; 11</td></tr><tr><td>–</td><td>自减</td><td>A– &#x3D; 9</td></tr></tbody></table><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a<span class="token punctuation">,</span> b <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span>c <span class="token operator">:=</span> a <span class="token operator">+</span> bfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>c <span class="token operator">=</span> a <span class="token operator">-</span> bfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>c <span class="token operator">=</span> a <span class="token operator">*</span> bfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>c <span class="token operator">=</span> a <span class="token operator">/</span> bfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>c <span class="token operator">=</span> a <span class="token operator">%</span> bfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>c<span class="token operator">++</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时注意如果a &lt; b去进行除法的话也是进行整除</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>我们假定A &#x3D; 10,B &#x3D; 20</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td></td><td>False</td></tr><tr><td>!&#x3D;</td><td></td><td>True</td></tr><tr><td>&gt;</td><td></td><td>False</td></tr><tr><td>&lt;</td><td></td><td>True</td></tr><tr><td>&gt;&#x3D;</td><td></td><td>Flase</td></tr><tr><td>&lt;&#x3D;</td><td></td><td>True</td></tr></tbody></table><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">11</span><span class="token keyword">var</span> b <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">>=</span> b<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">&lt;=</span> b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">falsetrue true falsetrue false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>假定A的值为True，B的值为False</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td></td><td>(A &amp;&amp; B)为false</td></tr><tr><td>||</td><td></td><td>(A || B)为True</td></tr><tr><td>!</td><td></td><td>!(A &amp;&amp; B) 为True</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>A 为60 ，B为13</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>双目运算符，都是1结果为1否则为0</td><td></td></tr><tr><td>|</td><td>双目运算符，有1出1，全0出0</td><td></td></tr><tr><td>^</td><td>不同时则为1否则为0</td><td></td></tr><tr><td>&amp;^</td><td>位清空，a &amp;^ b，对于b上的每个数值，如果为0，则取a对应的数值，如果是1，就取0</td><td>(A &amp;^ B &#x3D; 48)</td></tr><tr><td>&lt;&lt;</td><td>左移</td><td></td></tr><tr><td>&gt;&gt;</td><td>右移</td><td></td></tr></tbody></table><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">:=</span> <span class="token number">60</span>b <span class="token operator">:=</span> <span class="token number">13</span><span class="token keyword">var</span> c <span class="token builtin">int</span>c <span class="token operator">=</span> a <span class="token operator">&amp;</span> bfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>c <span class="token operator">=</span> a <span class="token operator">|</span> bfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>c <span class="token operator">=</span> a <span class="token operator">^</span> bfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>c <span class="token operator">=</span> a <span class="token operator">&amp;^</span> bfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">12</span><span class="token number">61</span><span class="token number">49</span><span class="token number">48</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>同c一样</td><td></td></tr><tr><td>+&#x3D;</td><td></td><td></td></tr><tr><td>-&#x3D;</td><td></td><td></td></tr><tr><td>*&#x3D;</td><td></td><td></td></tr><tr><td>&#x2F;&#x3D;</td><td></td><td></td></tr><tr><td>%&#x3D;</td><td></td><td></td></tr><tr><td>&lt;&lt;&#x3D;</td><td></td><td></td></tr><tr><td>&gt;&gt;&#x3D;</td><td></td><td></td></tr><tr><td>&amp;&#x3D;</td><td></td><td></td></tr><tr><td>^&#x3D;</td><td></td><td></td></tr><tr><td>|&#x3D;</td><td></td><td></td></tr></tbody></table><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">:=</span> <span class="token number">21</span><span class="token keyword">var</span> b <span class="token builtin">int</span>b <span class="token operator">=</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>b <span class="token operator">+=</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>b <span class="token operator">-=</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>b <span class="token operator">*=</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>b <span class="token operator">/=</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>b <span class="token operator">%=</span> afmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>b <span class="token operator">=</span> <span class="token number">10</span>b <span class="token operator">>>=</span> <span class="token number">2</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>b <span class="token operator">&lt;&lt;=</span> <span class="token number">2</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="键盘输入输出"><a href="#键盘输入输出" class="headerlink" title="键盘输入输出"></a>键盘输入输出</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> x <span class="token builtin">int</span><span class="token keyword">var</span> y <span class="token builtin">float64</span><span class="token comment">//定义了两个变量，想用键盘来录入</span><span class="token comment">//fmt.Println() 打印并且换行</span><span class="token comment">//fmt.Printf()  格式化输出</span><span class="token comment">//fmt.Print()   打印输出</span>fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token comment">//在换行符上停止</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %f\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token string">"%d %f"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token comment">//和正常的scanf差不多</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %f\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token comment">//一直读取，直到空格或者换行符为止</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %f\n"</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token comment">//fmt.Scan()</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>程序的流程一共有三种：顺序结构、选择结构以及循环结构</p><p>顺序结构：从上到下逐行执行。</p><p>选择结构：条件满足某些代码才会执行</p><ul><li>$if$</li><li>$switch$</li><li>$select$</li></ul><p>循环结构：条件满足某些代码会被反复执行$0 - N$次</p><ul><li>$for$</li></ul><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">:=</span> <span class="token number">100</span><span class="token keyword">if</span> a <span class="token operator">>=</span> <span class="token number">90</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">&lt;=</span> <span class="token number">100</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> a <span class="token operator">>=</span> <span class="token number">80</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> a <span class="token operator">>=</span> <span class="token number">70</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> a <span class="token operator">>=</span> <span class="token number">60</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"E"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>if还可以嵌套一个if</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> a<span class="token punctuation">,</span> b <span class="token builtin">string</span>pwd <span class="token operator">:=</span> <span class="token string">"114514"</span>fmt<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token keyword">if</span> a <span class="token operator">==</span> pwd <span class="token punctuation">&#123;</span><span class="token keyword">if</span> b <span class="token operator">==</span> pwd <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"OK"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"NOT"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"NOT"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>score <span class="token operator">:=</span> <span class="token number">98</span><span class="token keyword">switch</span> score <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token number">90</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token number">80</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体匹配某一个具体的数值但是不是区间</p><p>switch可以使用fallthrough 强制执行后面的case语句</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">:=</span> <span class="token boolean">false</span><span class="token keyword">switch</span> a <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token boolean">false</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"false"</span><span class="token punctuation">)</span><span class="token keyword">fallthrough</span> <span class="token comment">//可以进行case穿透，不管下一个条件是否满足</span><span class="token keyword">case</span> <span class="token boolean">true</span><span class="token punctuation">:</span><span class="token keyword">if</span> a <span class="token operator">==</span> <span class="token boolean">false</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>正常的循环方式</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> i<span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参数是全局变量的时候可以这么写</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">:=</span> <span class="token number">0</span>i <span class="token operator">:=</span> <span class="token number">1</span><span class="token keyword">for</span> i <span class="token operator">&lt;=</span> <span class="token number">10</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>sum <span class="token operator">+=</span> ii<span class="token operator">++</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者我们可以直接写死循环</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">:=</span> <span class="token number">0</span>i <span class="token operator">:=</span> <span class="token number">1</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>i<span class="token operator">++</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>循环实际上和$C!P!P$几乎差不多，同样的我们可以采用$break$和$continue$适度的来结束所有循环或者停止单词循环</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>一般来说我们可以调用各种函数来正常使用除此之外不能直接修改$str$的某个数值</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>str <span class="token operator">:=</span> <span class="token string">"hello"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token comment">//获取字符串的长度为</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"the length of string is "</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//获取对应的字节</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"the first obj is"</span><span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"the first obj is %c\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"the obj is %c\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//输出的对应的是下标和字符,遍历数组以及切片的时候可以使用</span><span class="token comment">// 返回下标以及对应的数值，我们直接使用这个数值即可</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> str <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d %c\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//str不能被修改</span><span class="token comment">//str[2] = 'A'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数是最基本的代码块用于执行一个任务</li><li>$Go$语言至多有一个$main$函数</li></ul><h3 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h3><p>$Go$语言函数定义格式如下：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">function_name</span><span class="token punctuation">(</span><span class="token punctuation">[</span>parameter list<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span>return_types<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>函数体<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>无参无返回值函数</li><li>有一个参数的函数</li><li>有两个参数的函数</li><li>有一个返回值的函数</li><li>有多个返回值的函数</li></ul><p>根据如下代码我们就可以写出一个相加相减的函数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c<span class="token punctuation">,</span> d <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// func 函数名(参数) 函数调用后的返回值 函数体</span><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">,</span> y <span class="token operator">-</span> x<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-django" data-language="django"><code class="language-django">package mainimport "fmt"func main() &#123;//函数的调用printinfo()myprint("namomo")secondprint("namo", "namo")fmt.Println(add(1, 3))fmt.Println(mul(3, 5))&#125;// 无参无返回值函数func printinfo() &#123;fmt.Println("hahahah1")&#125;// 有一个参数的函数func myprint(msg string) &#123;fmt.Println(msg)&#125;// 有两个参数的函数func secondprint(msg1, msg2 string) &#123;fmt.Println(msg1 + msg2)&#125;// 有一个返回值的函数func add(x, y int) int &#123;return x + y&#125;// 有多个返回值的函数func mul(x, y int) (int, int) &#123;return x + y, x * y&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">hahahah1namomo  namonamo<span class="token number">4</span>       <span class="token number">8</span> <span class="token number">15</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数的形参和函数的实参"><a href="#函数的形参和函数的实参" class="headerlink" title="函数的形参和函数的实参"></a>函数的形参和函数的实参</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">:=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// max 两个参数比较大小</span><span class="token comment">// 形式参数就是传进去的x y</span><span class="token comment">// 实际参数就是调用函数时传给形参的实际数据叫做实际参数</span><span class="token keyword">func</span> <span class="token function">max</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> x <span class="token operator">></span> y <span class="token punctuation">&#123;</span><span class="token keyword">return</span> x<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> y<span class="token punctuation">&#125;</span><span class="token comment">// 一个函数定义上有返回值那么函数中必须使用return语句</span><span class="token comment">// 返回值</span><span class="token comment">// 调用处需要使用变量接收该结果</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul><li>可变参数要放在其他参数的后面</li><li>一个函数列表中最多只能有一个可变参数</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">getsum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">getsum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// ...代表可变参数</span><span class="token keyword">func</span> <span class="token function">getsum</span><span class="token punctuation">(</span>nums <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>sum <span class="token operator">:=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> nums <span class="token punctuation">&#123;</span>sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> sum<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>按照数据存储特点来分：</p><ul><li>值类型的数据：操作的是数据本身$int,string,bool,float64,array……$</li><li>引用类型的数据：操作的是数据的地址$slice,map,chan……$</li></ul><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//值传递</span><span class="token comment">//定义一个数组 [个数]类型</span><span class="token comment">//arr2与arr1占用空间不同,arr是数据的副本，修改数据对原始的数据没有影响</span>arr <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token function">update</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">//引用传递</span><span class="token comment">//切片 可以扩容的数组</span>s1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token comment">//s3 := []int&#123;&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"s1"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token comment">//传入的是引用类型的数据，地址，所以在函数中更改这个切片在外面也会更改</span><span class="token function">update2</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">update</span><span class="token punctuation">(</span>arr2 <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>arr2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token comment">//return arr2</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">update2</span><span class="token punctuation">(</span>s2 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token comment">//s2 = append(s2, 10)</span>s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">115414</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数中变量的作用域"><a href="#函数中变量的作用域" class="headerlink" title="函数中变量的作用域"></a>函数中变量的作用域</h3><p>作用域：变量可以使用的范围</p><p>局部变量：函数内部定义的变量，叫做局部变量</p><p>全局变量：函数外部定义的变量，叫做全局变量</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">// 全局变量在哪里使用</span><span class="token keyword">var</span> num <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//函数体内的局部变量</span>temp <span class="token operator">:=</span> <span class="token number">1000</span><span class="token comment">//if for中的都是局部变量只能在自己的循环语句中使用</span><span class="token keyword">if</span> b <span class="token operator">:=</span> <span class="token number">1</span><span class="token punctuation">;</span> b <span class="token operator">&lt;=</span> <span class="token number">10</span> <span class="token punctuation">&#123;</span><span class="token comment">//语句内的局部变量</span>temp <span class="token operator">:=</span> <span class="token number">50</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">//局部变量就近原则</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a <span class="token operator">:=</span> <span class="token number">1</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//不能使用在其他函数中定义的变量</span><span class="token comment">//fmt.Println(a)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>一个函数自己调用自己就叫递归函数</p><p>递归函数要给自己设置一个出口不然最后就会死循环</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">fib</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 0 1 2 3 4 5</span><span class="token comment">// 1 1 2 3 5 8</span><span class="token keyword">func</span> <span class="token function">fib</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> x <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> x <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="defer函数"><a href="#defer函数" class="headerlink" title="defer函数"></a>defer函数</h3><p>$defer$语义:推迟，延迟</p><p>在$go$语言中使用$defer$关键字可以来延迟一个函数或者方法的执行</p><p>结束完所有的东西之后再来$defer$</p><p>如果有多个$defer$语句的话我们可以按照入$defer$栈的顺序去输出</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token keyword">defer</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"5"</span><span class="token punctuation">)</span><span class="token keyword">defer</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="函数的数据类型"><a href="#函数的数据类型" class="headerlink" title="函数的数据类型"></a>函数的数据类型</h3><p>本质都是$func$，像下列代码如果把$f11$赋值给$f5$的话相当于他们两个函数都用同一个地址里面的东西</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">// func 本身就是一个数据类型</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//不加括号是直接看这个函数，输出的是一个func</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%T"</span><span class="token punctuation">,</span> f11<span class="token punctuation">)</span><span class="token keyword">var</span> f5 <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span>f5 <span class="token operator">=</span> f11<span class="token function">f5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">f11</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"namo"</span><span class="token punctuation">)</span><span class="token comment">//return a + b</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>f2 <span class="token operator">:=</span> f1 <span class="token comment">//函数本身也是一个变量</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//匿名函数</span>f3 <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"im f3"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>ha <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"im f4"</span><span class="token punctuation">)</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">//函数本身可以调用自己</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ha<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"im f1"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>高阶函数：根据$go$语言的数据类型特点，可以将一个函数作为另外一个函数的参数</p><p>$fun1(),fun2()$</p><p>将$fun1()$函数作为$fun2()$这个函数的参数</p><p>$fun2$函数：叫做高阶函数。接收了一个函数作为参数的函数</p><p>$fun1$函数：叫做回调函数，作为另外一个函数的参数</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>r2 <span class="token operator">:=</span> <span class="token function">oper</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> add<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r2<span class="token punctuation">)</span>r2 <span class="token operator">=</span> <span class="token function">oper</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> sub<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r2<span class="token punctuation">)</span>r4 <span class="token operator">:=</span> <span class="token function">oper</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> b <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"not 0"</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> a <span class="token operator">/</span> b<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r4<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">oper</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">,</span> fun <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>r <span class="token operator">:=</span> <span class="token function">fun</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token keyword">return</span> r<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">sub</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> a <span class="token operator">-</span> b<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">/*一个外层函数中有内层函数，在内层函数中会操作外层函数的局部变量并且该外层函数的返回值就是这个内层函数那么这个内层函数和外层函数的局部变量就称为闭包结构局部变量的生命周期就会发生改变，正常的局部变量会随着函数的调用而创建，随着函数的结束而销毁但是闭包结构中的外层函数的局部变量并不会随着外层函数的结束而销毁，因为内层函数还在继续使用*/</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>r1 <span class="token operator">:=</span> <span class="token function">incre</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span>v1 <span class="token operator">:=</span> <span class="token function">r1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span>v2 <span class="token operator">:=</span> <span class="token function">r1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">r1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">r1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">r1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//</span>r2 <span class="token operator">:=</span> <span class="token function">incre</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"r2:"</span><span class="token punctuation">,</span> r2<span class="token punctuation">)</span>v3 <span class="token operator">:=</span> <span class="token function">r2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v3<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">r1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">r2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">incre</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>i <span class="token operator">:=</span> <span class="token number">0</span>fun <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span> <span class="token comment">//内层函数并没有执行</span>i<span class="token operator">++</span><span class="token keyword">return</span> i<span class="token punctuation">&#125;</span><span class="token keyword">return</span> fun<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个具有编号并且长度固定的元素序列</p><p>这里我们需要注意几个点，一个是数字通用的从$0$开始，一个是我们可以用内置函数$len$获取$a$的长度</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> a <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"begin:"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"get a_4"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"after:"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">var</span> mp <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">&#123;</span>mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> j<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"mp->"</span><span class="token punctuation">,</span> mp<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go">begin<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">]</span>get a_4 <span class="token number">100</span>                   after<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">100</span><span class="token punctuation">]</span>          <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">0</span><span class="token punctuation">]</span>                   mp<span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>$Slice$ 是$Go$中的一个重要的数据类型</p><p>$Slice$的类型仅仅由它所包含的元素的类型决定，和元素个数无关。</p><p>要创建一个长度不为$0$的空$slice$，我们需要使用 <strong>make</strong> 函数</p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>初始创建的时候我们可以直接开启它的长度然后去赋值</p><p>类似于开一个数组(?)</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hah1"</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ha2"</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"namomo"</span><span class="token comment">//s[3] = "namo3"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//[  ]</span><span class="token comment">//[hah1 ha2 namomo]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>我们可以在一个$Slice$的末尾中插入一个元素</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"namo"</span><span class="token punctuation">)</span>s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"namomo"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//[namo namomo]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>$copy(a,b)$将$b$中的内容复制给$a$</p><h3 id="len"><a href="#len" class="headerlink" title="len"></a>len</h3><p>获取这个$slice$的长度是多少</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hah1"</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ha2"</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"namomo"</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"namomomo"</span>s<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"haha3"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">copy</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> s<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"cpy:"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//[    ]</span><span class="token comment">//[hah1 ha2 namomo namomomo haha3]     </span><span class="token comment">//cpy: [hah1 ha2 namomo namomomo haha3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>类似于$Python$中的切片，也是用$[l:r]$来表示，是指截取一个从$l$ 到 $r - 1$的$slice$内容</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hah1"</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"ha2"</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"namomo"</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"namomomo"</span>s<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"haha3"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//[    ]</span><span class="token comment">//[namomo namomomo]      </span><span class="token comment">//[hah1 ha2]             </span><span class="token comment">//[namomo namomomo haha3]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>$Map$是$Go$中内建的关联数据类型，我们可以类比称为 $cpp$ 中的 $map$</p><p>要创建一个空$Map$，我们需要使用内建函数$make$:</p><p>$make(map[key-type]val-type)$</p><p>然后我们使用典型的$name[key] &#x3D; val$来设置键值对</p><h3 id="定义一个字典"><a href="#定义一个字典" class="headerlink" title="定义一个字典"></a>定义一个字典</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>mp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>mp<span class="token punctuation">[</span><span class="token string">"namo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>mp<span class="token punctuation">[</span><span class="token string">"namomo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"mp->"</span><span class="token punctuation">,</span> mp<span class="token punctuation">)</span><span class="token comment">//这也是一种直接定义的方式</span><span class="token comment">//n := map[string]int&#123;&#125;</span>mp2 <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#123;</span><span class="token string">"namo"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"aa"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>mp2<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//mp-> map[namo:1 namomo:2]</span><span class="token comment">//map[aa:2 namo:1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="遍历一个字典"><a href="#遍历一个字典" class="headerlink" title="遍历一个字典"></a>遍历一个字典</h3><p>我们可以直接采用$range$函数来遍历</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   mp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>   mp<span class="token punctuation">[</span><span class="token string">"namo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>   mp<span class="token punctuation">[</span><span class="token string">"namomo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>   <span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> mp <span class="token punctuation">&#123;</span>      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> v<span class="token punctuation">)</span>      fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> mp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//namo 1</span><span class="token comment">//namo 1  </span><span class="token comment">//namomo 2</span><span class="token comment">//namomo 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除字典中的一个键并且查找字典中是否存在某个键"><a href="#删除字典中的一个键并且查找字典中是否存在某个键" class="headerlink" title="删除字典中的一个键并且查找字典中是否存在某个键"></a>删除字典中的一个键并且查找字典中是否存在某个键</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>mp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>mp<span class="token punctuation">[</span><span class="token string">"namo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>mp<span class="token punctuation">[</span><span class="token string">"namomo"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"notdel"</span><span class="token punctuation">,</span> mp<span class="token punctuation">)</span><span class="token function">delete</span><span class="token punctuation">(</span>mp<span class="token punctuation">,</span> <span class="token string">"namo"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"delete"</span><span class="token punctuation">,</span> mp<span class="token punctuation">)</span><span class="token comment">//返回的数值是mp["namomo"],如果不存在在int中默认是0，res返回是否找到</span><span class="token boolean">_</span><span class="token punctuation">,</span> res <span class="token operator">:=</span> mp<span class="token punctuation">[</span><span class="token string">"namomo"</span><span class="token punctuation">]</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"res"</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//notdel map[namo:1 namomo:2]</span><span class="token comment">//delete map[namomo:2]</span><span class="token comment">//res true      </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h2><p>在上面$map$和数组以及$slice$中都用到过，用法类似$py$的</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>$Go$的结构体是带类型的字段集合。</p><p>我们可以使用$type \ name \ struct$ ${}$来定义一个结构体，其中$name$是这个结构体的名字</p><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><p>定义的时候如果没有给值就会赋值那个类型的初始值</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>name <span class="token builtin">string</span>age  <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>person<span class="token punctuation">&#123;</span><span class="token string">"namomo"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>person<span class="token punctuation">&#123;</span>name<span class="token punctuation">:</span> <span class="token string">"namo2"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>person<span class="token punctuation">&#123;</span>name<span class="token punctuation">:</span> <span class="token string">"ha"</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//&#123;namomo 1&#125;</span><span class="token comment">//&#123;namo2 10&#125;</span><span class="token comment">//&#123;ha 0&#125;  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>我们可以使用<code>&amp;</code> 前缀来生成一个结构体指针，使用<code>.</code>来访问结构体字段</p><p>结构体也是可变的</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>name <span class="token builtin">string</span>age  <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s <span class="token operator">:=</span> person<span class="token punctuation">&#123;</span>name<span class="token punctuation">:</span> <span class="token string">"namo"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">15</span><span class="token punctuation">&#125;</span>s<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"namomo"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>sp <span class="token operator">:=</span> <span class="token operator">&amp;</span>ssp<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">100</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//&#123;namomo 15&#125;</span><span class="token comment">//&#123;namomo 100&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>$Go$支持为结构体类型定义方法</p><p>定义方法的形式为 $func \ (username \ typename) funcname() val {} $</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">type</span> rect <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>width<span class="token punctuation">,</span> height <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>rect<span class="token punctuation">)</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> r<span class="token punctuation">.</span>width <span class="token operator">*</span> r<span class="token punctuation">.</span>height<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r rect<span class="token punctuation">)</span> <span class="token function">perim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">2</span><span class="token operator">*</span>r<span class="token punctuation">.</span>width <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>r<span class="token punctuation">.</span>height<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ret <span class="token operator">:=</span> rect<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ret<span class="token punctuation">.</span><span class="token function">perim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//50</span><span class="token comment">//30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>要在$Go$中实现一个接口，我们只需要实现接口中所有的方法。这里我们为$rect$实现了$geometry$接口</p><p>结构体类型 $circle $和 $rect$都实现了 $geometry$ 接口， 所以我们可以将其实例作为 $measure$ 的参数。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"math"</span><span class="token punctuation">)</span><span class="token keyword">type</span> geometry <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span><span class="token function">perim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> rect <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>width<span class="token punctuation">,</span> height <span class="token builtin">float64</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> circle <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>radius <span class="token builtin">float64</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r rect<span class="token punctuation">)</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> r<span class="token punctuation">.</span>width <span class="token operator">*</span> r<span class="token punctuation">.</span>height<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r rect<span class="token punctuation">)</span> <span class="token function">perim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">2</span><span class="token operator">*</span>r<span class="token punctuation">.</span>width <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>r<span class="token punctuation">.</span>height<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r circle<span class="token punctuation">)</span> <span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> math<span class="token punctuation">.</span>Pi <span class="token operator">*</span> r<span class="token punctuation">.</span>radius <span class="token operator">*</span> r<span class="token punctuation">.</span>radius<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>r circle<span class="token punctuation">)</span> <span class="token function">perim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> math<span class="token punctuation">.</span>Pi <span class="token operator">*</span> r<span class="token punctuation">.</span>radius<span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">measure</span><span class="token punctuation">(</span>g geometry<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span><span class="token function">perim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>r <span class="token operator">:=</span> rect<span class="token punctuation">&#123;</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">&#125;</span>c <span class="token operator">:=</span> circle<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token function">measure</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token function">measure</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token number">12</span>               <span class="token number">14</span>               <span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">&#125;</span>              <span class="token number">78.53981633974483</span><span class="token number">31.41592653589793</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h3><p>$struct$里面套一个$struct$</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">type</span> base <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>num <span class="token builtin">int</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>b base<span class="token punctuation">)</span> <span class="token function">describe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"base with num = %d\n"</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> container <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>basestr <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>co <span class="token operator">:=</span> container<span class="token punctuation">&#123;</span>base<span class="token punctuation">:</span> base<span class="token punctuation">&#123;</span>num<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>str<span class="token punctuation">:</span> <span class="token string">"some name"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"co=&#123;num: %v, str: %v&#125;\n"</span><span class="token punctuation">,</span> co<span class="token punctuation">.</span>num<span class="token punctuation">,</span> co<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>make以及相关操作</title>
      <link href="/2023/01/06/make%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/01/06/make%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="Make命令"><a href="#Make命令" class="headerlink" title="Make命令"></a>Make命令</h1><p>部分转载于:<a href="https://mooc.hznu.edu.cn/#/mooc/Server">https://mooc.hznu.edu.cn/#/mooc/Server</a></p><h2 id="Make概念"><a href="#Make概念" class="headerlink" title="Make概念"></a>Make概念</h2><p>$Make$英文意思为制作，$Make$命令直接使用了这个意思，也就是要做出某个文件，比如我现在要去新建一个文件$a.txt$那么我可以采用以下的命令</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">make a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是由于$make$本身并不知道如何做出$a.txt$，那么我们需要给$make$设置相关的命令才能使他完成这个目标</p><p>假设文件$a.txt$依赖于$b.txt$和$c.txt$，是后面两个文件连接的产物，那么make需要知道以下规则</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">a.txt: b.txt c.txt    cat b.txt c.txt > a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于这一条命令我们实际上是可以分成两步骤，第一步确定$b.txt$和$c.txt$，第二部使用$cat$命令将这两个文件合并并且输出为新文件。这样的规则都写在一个叫$makefile$的文件里面</p><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>$Makefile$文件由一系列规则组成。每条规则的形式如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>target<span class="token operator">></span> <span class="token builtin class-name">:</span> <span class="token operator">&lt;</span>prerequisites<span class="token operator">></span> <span class="token punctuation">[</span>tab<span class="token punctuation">]</span>  <span class="token operator">&lt;</span>commands<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面第一行冒号前面的部分，叫做”目标”（$target$），冒号后面的部分叫做”前置条件”（$prerequisites$）；第二行必须由一个tab键起首，后面跟着”命令”（$commands$）。</p><p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 </p><h3 id="目标（target）"><a href="#目标（target）" class="headerlink" title="目标（target）"></a>目标（target）</h3><ol><li><p>一个目标（$target$）就构成一条规则。 目标通常是文件名，指明Make命令所要构建的对象，比如上文的 $a.txt$ 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p></li><li><p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（$phony target$）。</p><pre class="line-numbers language-none"><code class="language-none">clean:      rm *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面代码的目标是$clean$，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p><pre class="line-numbers language-none"><code class="language-none">make  clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>声明伪目标 但是，如果当前目录中，正好有一个文件叫做$clean$，那么这个命令不会执行。因为$Make$发现$clean$文件已经存在，就认为没有必要重新构建了，就不会执行指定的$rm$命令。为了避免这种情况，可以明确声明$clean$是”伪目标”，写法如下:</p><pre class="line-numbers language-none"><code class="language-none">.PHONY: cleanclean:        rm *.o temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>如果$Make$命令运行时没有指定目标，默认会执行$Makefile$文件的第一个目标。</p><pre class="line-numbers language-none"><code class="language-none">make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="前置条件（prerequisites）"><a href="#前置条件（prerequisites）" class="headerlink" title="前置条件（prerequisites）"></a>前置条件（prerequisites）</h3><h1 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h1><p>Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p><h1 id="Make的概念"><a href="#Make的概念" class="headerlink" title="Make的概念"></a>Make的概念</h1><p>Make这个词，英语的意思是”制作”。Make命令直接用了这个意思，就是要做出某个文件。比如，要做出文件a.txt，就可以执行下面的命令。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是如果你真的输入这条命令，它并不会起作用。因为Make命令本身并不知道，如何做出a.txt，需要有人告诉它，如何调用其他命令完成这个目标。</p><p>比如，假设文件 <code>a.txt</code> 依赖于 <code>b.txt</code> 和 <code>c.txt</code>，是后面两个文件连接（cat命令）的产物。那么，make 需要知道下面的规则。</p><pre class="line-numbers language-none"><code class="language-none">a.txt: b.txt c.txt    cat b.txt c.txt &gt; a.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也就是说，<code>make a.txt</code> 这条命令的背后，实际上分成两步：第一步，确认 <code>b.txt</code> 和 <code>c.txt</code> 必须已经存在，第二步使用 <code>cat</code> 命令 将这个两个文件合并，输出为新文件。 像这样的规则，都写在一个叫做<code>Makefile</code>的文件中，<code>Make</code>命令依赖这个文件进行构建。<code>Makefile</code>文件也可以写为<code>makefile</code>， 或者用命令行参数指定为其他文件名。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> <span class="token parameter variable">-f</span> rules.txt<span class="token comment"># 或者</span>$ <span class="token function">make</span> <span class="token parameter variable">--file</span><span class="token operator">=</span>rules.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码指定<code>make</code>命令依<code>据rules.txt</code>文件中的规则，进行构建。 总之，<code>make</code>只是一个根据指定的Shell命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。</p><h1 id="Makefile格式"><a href="#Makefile格式" class="headerlink" title="Makefile格式"></a>Makefile格式</h1><p>make命令的构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。</p><h1 id="Makefile基本规则"><a href="#Makefile基本规则" class="headerlink" title="Makefile基本规则"></a>Makefile基本规则</h1><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p><pre class="line-numbers language-none"><code class="language-none">&lt;target&gt; : &lt;prerequisites&gt; [tab]  &lt;commands&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p><p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 下面就详细讲解，每条规则的这三个组成部分。</p><p>目标（target） 1 . 一个目标（target）就构成一条规则。 目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p><p>2 . 除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">clean</span><span class="token punctuation">:</span>      rm *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p><pre class="line-numbers language-none"><code class="language-none">make  clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3 . 声明伪目标 但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin-target builtin">.PHONY</span><span class="token punctuation">:</span> clean<span class="token target symbol">clean</span><span class="token punctuation">:</span>        rm *.o temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。</p><p>4 . 如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</p><pre class="line-numbers language-none"><code class="language-none">make<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面代码执行Makefile文件的第一个目标。</p><h1 id="前置条件（prerequisites）-1"><a href="#前置条件（prerequisites）-1" class="headerlink" title="前置条件（prerequisites）"></a>前置条件（prerequisites）</h1><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p><p>1 . 下列代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt已经存在，那么make result.txt可以正常运行，否则必须再写一条规则，来生成source.txt。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">result.txt</span><span class="token punctuation">:</span> source.txt    cp source.txt result.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2 . 下列代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用make source.txt，它都会生成。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">source.txt</span><span class="token punctuation">:</span>    echo <span class="token string">"this is the source"</span> > source.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3 . 下列命令连续执行两次make result.txt。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> result.txt<span class="token function">make</span> result.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4 . 如果需要生成多个文件，往往采用下面的写法。</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">source</span><span class="token punctuation">:</span> file1 file2 file3<span class="token target symbol">file1</span><span class="token punctuation">:</span>        echo <span class="token string">"this is file1"</span> > file1<span class="token target symbol">file2</span><span class="token punctuation">:</span>        echo <span class="token string">"this is file2"</span> > file2<span class="token target symbol">file3</span><span class="token punctuation">:</span>        echo <span class="token string">"this is file3"</span> > file3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后直接命令进行$make$即可</p><h2 id="makefile范例1"><a href="#makefile范例1" class="headerlink" title="makefile范例1"></a>makefile范例1</h2><p>假设我们现在有一个$ex5$文件夹，我们先$tree$看一下这个文件夹的结构</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">ex5├── makefile└── src    ├── client    │   └── ex5_client_server.c    └── socket_server        └── ex5_socket_server.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的目标是使用$makefile$让里面的$cilent$可以连接上$server$</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">SRCPATH <span class="token operator">=</span> srcCLIENT_SRCFILE <span class="token operator">=</span> client/ex5_client_server.cSERVER_SRCFILE <span class="token operator">=</span> socket_server/ex5_socket_server.cCLIENT_OBJFILE <span class="token operator">=</span> ex5_client_server.oSERVER_OBJFILE <span class="token operator">=</span> ex5_socket_server.oCLIENT_TARGET <span class="token operator">=</span> clientSERVER_TARGET <span class="token operator">=</span> server<span class="token target symbol">build</span><span class="token punctuation">:</span>build-client build-server<span class="token target symbol">build-client</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>CLIENT_OBJFILE<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>CLIENT_OBJFILE<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>CLIENT_TARGET<span class="token punctuation">)</span><span class="token target symbol"><span class="token variable">$</span>(CLIENT_OBJFILE)</span><span class="token punctuation">:</span>gcc -c <span class="token variable">$</span><span class="token punctuation">(</span>SRCPATH<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>CLIENT_SRCFILE<span class="token punctuation">)</span><span class="token target symbol">build-server</span><span class="token punctuation">:</span><span class="token variable">$</span><span class="token punctuation">(</span>SERVER_OBJFILE<span class="token punctuation">)</span>gcc <span class="token variable">$</span><span class="token punctuation">(</span>SERVER_OBJFILE<span class="token punctuation">)</span> -o <span class="token variable">$</span><span class="token punctuation">(</span>SERVER_TARGET<span class="token punctuation">)</span><span class="token target symbol"><span class="token variable">$</span>(SERVER_OBJFILE)</span><span class="token punctuation">:</span>gcc -c <span class="token variable">$</span><span class="token punctuation">(</span>SRCPATH<span class="token punctuation">)</span>/<span class="token variable">$</span><span class="token punctuation">(</span>SERVER_SRCFILE<span class="token punctuation">)</span><span class="token target symbol">clean</span><span class="token punctuation">:</span>rm <span class="token variable">$</span><span class="token punctuation">(</span>CLIENT_TARGET<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>SERVER_TARGET<span class="token punctuation">)</span> *.o<span class="token target symbol">run-client</span><span class="token punctuation">:</span>./<span class="token variable">$</span><span class="token punctuation">(</span>CLIENT_TARGET<span class="token punctuation">)</span><span class="token target symbol">run-server</span><span class="token punctuation">:</span>./<span class="token variable">$</span><span class="token punctuation">(</span>SERVER_TARGET<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="makefile范例2"><a href="#makefile范例2" class="headerlink" title="makefile范例2"></a>makefile范例2</h2><p>对于一个$cpp$文件生成所需要的可执行文件</p><pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile"><span class="token target symbol">build</span><span class="token punctuation">:</span>a.og++ a.o -o a<span class="token target symbol">a.o</span><span class="token punctuation">:</span>a.cppg++ -c a.cpp<span class="token target symbol">clean</span><span class="token punctuation">:</span>rm a *.o<span class="token target symbol">run</span><span class="token punctuation">:</span>./a <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> make </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集&amp;最小生成树部分题解及代码</title>
      <link href="/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81/"/>
      <url>/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="并查集-amp-最小生成树题解"><a href="#并查集-amp-最小生成树题解" class="headerlink" title="并查集&amp;最小生成树题解"></a>并查集&amp;最小生成树题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p><strong>解题思路:</strong> 计算几个连通块，并查集一下即可</p><h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p><strong>解题思路:</strong> 计算这片连通森林还需要几条边变成一个连通块，那么需要数量就是连通块数量减去$1$</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p><strong>解题思路:</strong> 最小生成树模板题</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p><strong>解题思路:</strong> $MST$模板题，先加上已经选择的边，再加上没有选择的边即可</p><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p><strong>解题思路:</strong> 判断是否只有一个$MST$，那么我们可以先找到一棵$MST$，记录这一棵$MST$的边，然后我们暴力去枚举去掉这条边之后是否还存在一棵和之前权值一样的$MST$</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn &#x3D; 1e5 + 10;struct node&#123;int x,y,r;&#125;a[maxn];int flag[maxn],n,m;struct DSU&#123;int f[maxn],num;int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;int merge(int x,int y)&#123;int fx &#x3D; getf(x);int fy &#x3D; getf(y);f[fx] &#x3D; fy;if(fx !&#x3D; fy)&#123;num++;return 1;&#125;else return 0;&#125;void init()&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) f[i] &#x3D; i;num &#x3D; 0;&#125;&#125;dsu;struct kruskal&#123;DSU now;int nowres;void init()&#123;now.init();nowres &#x3D; 0;&#125;&#125;kru;int cmp(node A,node B)&#123;return A.r &lt; B.r;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;dsu.init();for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].r;flag[i] &#x3D; 0;&#125;sort(a + 1,a + 1 + m,cmp);int ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;if(dsu.merge(a[i].x,a[i].y))&#123;ans +&#x3D; a[i].r;flag[i] &#x3D; 1;&#125;&#125;int f &#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;if(!flag[i]) continue;kru.init();for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;if(j &#x3D;&#x3D; i) continue;if(kru.now.merge(a[j].x,a[j].y))&#123;kru.nowres +&#x3D; a[j].r;&#125;&#125;if(kru.nowres &#x3D;&#x3D; ans &amp;&amp; kru.now.num &#x3D;&#x3D; n - 1) f &#x3D; 0;&#125;if(f) cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;else cout &lt;&lt; &quot;Not Unique!\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p><strong>解题思路:</strong> 首先先把免费的边连接起来，然后对$n$个点建立点对，排序之后求最小生成树，直接用$Kruskal$记录边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 1e6 + 10;int p[maxn][2],tot,n,m;struct node&#123;int x,y;double r;node()&#123;&#125;;node(int _x,int _y,double _r): x(_x),y(_y),r(_r)&#123;&#125;&#125;a[maxn];struct DSU&#123;int f[maxn];int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y,int op)&#123;int fx &#x3D; getf(x);int fy &#x3D; getf(y);if(fx !&#x3D; fy)&#123;f[fx] &#x3D; fy;if(op) cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;&#125;&#125;void init()&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) f[i] &#x3D; i;&#125;&#125;dsu;int pow2(int x)&#123;return x * x;&#125;double cal(int i,int j)&#123;return sqrt(1.0 * pow2(p[i][0] - p[j][0]) + 1.0 * pow2(p[i][1] - p[j][1]));&#125;int cmp(node A,node B)&#123;return A.r &lt; B.r;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; p[i][0] &gt;&gt; p[i][1];&#125;cin &gt;&gt; m;dsu.init();for(int i &#x3D; 1,u,v;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v;dsu.merge(u,v,0);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;double dis &#x3D; cal(i,j);a[++tot] &#x3D; node(i,j,dis);&#125;&#125;sort(a + 1,a + 1 + tot,cmp);for(int i &#x3D; 1;i &lt;&#x3D; tot;++i)&#123;dsu.merge(a[i].x,a[i].y,1);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p><strong>解题思路:</strong> 和上课讲的基本类似，同时需要注意的是这里存在位置固定的问题，如果位置固定的话那么对于他所存在的连通块只会带来$1$的贡献</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define int long longconst int maxn &#x3D; 5e5 + 10;const int mod &#x3D; 1e9 + 7;int a[maxn],b[maxn],c[maxn],n;struct DSU&#123;int f[maxn],sz[maxn];int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y)&#123;int fx &#x3D; getf(x);int fy &#x3D; getf(y);if(fx !&#x3D; fy)&#123;f[fy] &#x3D; fx;sz[fx] +&#x3D; sz[fy];&#125;&#125;void init()&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) f[i] &#x3D; i,sz[i] &#x3D; 1;&#125;&#125;dsu;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; b[i];for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; c[i];dsu.init();for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;dsu.merge(a[i],b[i]);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(c[i])&#123;dsu.sz[dsu.getf(c[i])] &#x3D; 0;&#125;&#125;int ans &#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(dsu.f[i] &#x3D;&#x3D; i)&#123;if(dsu.sz[i] &gt;&#x3D; 2) ans &#x3D; ans * 2 % mod;&#125;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p><strong>解题思路:</strong> 种族并查集，首先我们先思考如何解决多个种族之间的事情，首先我们先考虑$A$这个位置，因为它可以吃$B$,但是被$C$吃，因此在这里的关系存在的是三种：自己(同族)，食物，敌人。所以我们再开空间的时候可以开$3$倍的空间。</p><p>然后我们考虑这样一件事情，假设$a$可以吃$b,c$，那么$b,c$实际上是同族；同理如果$b,c$可以吃$a$，那么$b,c$也是同族。那么也就是说 <strong>敌人的敌人是朋友</strong></p><p>那么接下来考虑什么时候不合法，首先是在$x$和$y$合并的时候，如果$x$是$y$的敌人或者$y$是$x$的敌人就不行</p><p>然后考虑$x$可以吃$y$的情况下，首先是题目告诉如果相同就不行，然后是如果$x$是$y$的同族或者$y$可以吃$x$不行</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn &#x3D; 1e5 + 10;&#x2F;&#x2F; const int inf &#x3D; 1e18;int f[maxn * 3],n,m,ans;int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y)&#123;int fx &#x3D; getf(x);int fy &#x3D; getf(y);f[fx] &#x3D; fy;&#125;signed main()&#123;&#x2F;&#x2F; ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);&#x2F;&#x2F; cin &gt;&gt; n &gt;&gt; m;scanf(&quot;%d %d&quot;,&amp;n,&amp;m);for(int i &#x3D; 1;i &lt;&#x3D; 3 * n;++i) f[i] &#x3D; i;&#x2F;&#x2F;A -&gt; B -&gt; C -&gt; Afor(int i &#x3D; 1,op,x,y;i &lt;&#x3D; m;++i)&#123;scanf(&quot;%d %d %d&quot;,&amp;op,&amp;x,&amp;y);if(x &gt; n || y &gt; n)&#123;ans++;continue;&#125;if(op &#x3D;&#x3D; 1)&#123;if(getf(x) &#x3D;&#x3D; getf(y + 2 * n) || getf(x + 2 * n) &#x3D;&#x3D; getf(y))&#123;ans++;&#125;else&#123;merge(x,y);merge(x + n,y + n);merge(x + 2 * n,y + 2 * n);&#125;&#125;else&#123;if(x &#x3D;&#x3D; y)&#123;ans++;&#125;else if(getf(x) &#x3D;&#x3D; getf(y) || getf(x + 2 * n) &#x3D;&#x3D; getf(y))&#123;ans++;&#125;else&#123;merge(x,y + 2 * n);merge(x + n,y);merge(x + 2 * n,y + n);&#125;&#125;&#125;printf(&quot;%d\n&quot;,ans);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p><strong>解题思路:</strong> 求一个连通块最大是多少，但是由于标号很大所以我们先需要离散化再进行并查集查找即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 1e6 + 10;int ans,n;struct DSU&#123;unordered_map&lt;int,int&gt; f;unordered_map&lt;int,int&gt; sz;int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y)&#123;int fx &#x3D; getf(x);int fy &#x3D; getf(y);if(fx !&#x3D; fy)&#123;f[fx] &#x3D; fy;sz[fy] +&#x3D; sz[fx];ans &#x3D; max(ans,sz[fy]);&#125;&#125;void init()&#123;f.clear();sz.clear();ans &#x3D; 0;&#125;&#125;dsu;array&lt;int,2&gt; p[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;dsu.init();cin &gt;&gt; n;for(int i &#x3D; 1,u,v;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; u &gt;&gt; v;p[i] &#x3D; &#123;u,v&#125;;dsu.f[u] &#x3D; u,dsu.sz[u] &#x3D; 1;dsu.f[v] &#x3D; v,dsu.sz[v] &#x3D; 1;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;auto [u,v] &#x3D; p[i];dsu.merge(u,v);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><p><strong>题目大意:</strong> 有三个长度为$n$的序列$a,b,c$</p><p>$Alice$和$Bob$玩游戏，一共进行$n$个回合，游戏规则如下：</p><ul><li>选定$a_i,b_i,c_i$</li><li>$Alice$从这三个数字选择一个数字删掉</li><li>$Bob$从这三个数字选择一个数字</li></ul><p>我们让$Bob$每回合选择的数字是$d_i$,如果序列$d$是一个排列那么$Alice$获胜否则$Bob$获胜</p><p>现在给定$a,b$两个数组，问有多少个$c$数组可以使得$Bob$获胜，结果对$998244353$取模</p><p><strong>解题思路:</strong> 首先我们先考虑$Alice$会选择什么数字删掉，假设对于第$i$次操作来说，$a_i &#x3D; b_i$,那么我们可以选择任意的$c_i$并且最终把$c_i$删掉，这样子$Bob$一定取到的是$a_i$这个数字表示的值(因为$a_i &#x3D; b_i$)</p><p>然后我们考虑如果$a_i \neq b_i$那么我们选择的$c_i$就非常重要，因为$c_i$决定着我们可以选择$a_i$或者$b_i$中的哪个数字，只需要让$c_i &#x3D; a_i \ or \ c_i &#x3D; b_i$即可</p><p>那么选择某一个位置的思路就很清晰了，我们只需要考虑构造大于等于两个相同的并且把其中一个不需要的值删掉即可</p><p>接下来我们再考虑位置之间带来的因素</p><p>假设我们没有$a_i &#x3D; b_i$的情况，那么我们现在的问题可以转换为给定两个序列分别是$a,b$，每个位置上面取一个看是否可以构成一个排序</p><p>对于这一个问题来说，因为每一个位置做一个选择，同时也相同与每一个位置的两个数字相互制衡，那么我们可以用图论的语言来表达，在他们之间建一条边</p><p>我们可以发现只有基环树的形式是可以的，而基环树的形式实际上就是点数等于边数</p><p>那么我们最终只需要使用并查集取维护每个环中存在点数和边数即可</p><p>那么最后再思考答案贡献，对于一个基环树来说，如果这个树里面没有自环，那么贡献就是$2$，因为考虑每条边有两个选择，如果里面有自环的话，贡献就是$n$</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 1e6 + 10;const int mod &#x3D; 998244353;int n,m,a[maxn],b[maxn];int f[maxn],szv[maxn],sze[maxn],loop[maxn];void init()&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;f[i] &#x3D; i;szv[i] &#x3D; 1;sze[i] &#x3D; 0;loop[i] &#x3D; 0;&#125;&#125;int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y)&#123;int fx &#x3D; getf(x);int fy &#x3D; getf(y);if(fx !&#x3D; fy)&#123;f[fy] &#x3D; fx;sze[fx] +&#x3D; sze[fy];szv[fx] +&#x3D; szv[fy];loop[fx] +&#x3D; loop[fy];&#125;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;init();for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; b[i];for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;merge(a[i],b[i]);sze[getf(a[i])]++;if(a[i] &#x3D;&#x3D; b[i]) loop[getf(a[i])]++;&#125;int ans &#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(i &#x3D;&#x3D; getf(i))&#123;if(sze[i] !&#x3D; szv[i]) ans &#x3D; 0;                else ans &#x3D; ans * 2 % mod;&#125;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> dsu </tag>
            
            <tag> mst </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythonbasic</title>
      <link href="/2023/01/03/pythonbasic/"/>
      <url>/2023/01/03/pythonbasic/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础语法和基本数据"><a href="#Python基础语法和基本数据" class="headerlink" title="Python基础语法和基本数据"></a>Python基础语法和基本数据</h1><h2 id="标识符号"><a href="#标识符号" class="headerlink" title="标识符号"></a>标识符号</h2><ul><li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li><li>标识符的其他的部分由字母、数字和下划线组成。</li><li>标识符对大小写敏感。</li></ul><h2 id="Python保留字"><a href="#Python保留字" class="headerlink" title="Python保留字"></a>Python保留字</h2><p>保留字即关键字，我们不能把它们用作任何标识符名称。$Python$ 的标准库提供了一个 $keyword$ 模块。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> keyword<span class="token keyword">print</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>$python$中单行注释以 <strong>#</strong> 开头</p><p>多行注释可以用多个 <strong>#</strong> 号，还有 <strong>‘’’</strong> 和 **”””**：</p><h2 id="Python多行语句"><a href="#Python多行语句" class="headerlink" title="Python多行语句"></a>Python多行语句</h2><p>$Python$ 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 *<em>*</em> 来实现多行语句，例如:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">total <span class="token operator">=</span> item_one <span class="token operator">+</span> \        item_two <span class="token operator">+</span> \        item_three<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>用 <code>**</code> 运算符来计算乘方</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment">#25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在交互模式下，可以用变量 <code>_</code> 表示上一次的值</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><p>$Python$中单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用完全相同。</p></li><li><p>使用三引号(<strong>‘’’</strong> 或 <strong>“””</strong>)可以指定一个多行字符串。</p></li><li><p>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong>。</p></li><li><p>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复。</p></li><li><p>$Python$ 中的字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始。</p></li><li><p>$Python$ 中的字符串不能改变。</p></li><li><p>$Python$ 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p></li><li><p>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></p></li></ul><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>$Python$中单引号 <code>&#39;</code> 和双引号 <code>&quot;</code>使用完全相同。</p><p>反斜杠 <code>\</code> 可以用来转义，或者如果我们想要使用单引号我们外面可以加一个双引号</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is test1'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is \' test2'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is test '3 "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">this is test1this is &#39; test2this is test &#39;3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意如果我们不需要使用到转义的话我们可以在字符串前面加一个<code>r</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\hahah\tese'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">r'\hahah\tese'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">\hahahese\hahah\tese<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="跨行连续输入"><a href="#跨行连续输入" class="headerlink" title="跨行连续输入"></a>跨行连续输入</h3><p>使用三引号<code>&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;</code>可以指定一个多行字符串。</p><h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token string">'ha'</span> <span class="token operator">+</span> <span class="token string">'uhuh'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">hahahauhuh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者说可以按照字面意思连接字符串，比如相邻多个字符串会自动连接到一起</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'114514'</span><span class="token string">'1919810'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">1145141919810<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此我们在输出较长字符串的时候我们可以使用按照字面意思连接的方法来输出</p><h3 id="字符串只读"><a href="#字符串只读" class="headerlink" title="字符串只读"></a>字符串只读</h3><p>$python$中的字符串不能被修改，如果我们需要强行修改的话会错掉</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span>test<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Traceback (most recent call last):  File &quot;e:\Sublime Text\code\codeforces\traing\test.py&quot;, line 2, in &lt;module&gt;    test[3] &#x3D; &#39;i&#39;TypeError: &#39;str&#39; object does not support item assignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果需要一个新的字符串我们只能通过新建的方式来，同时我们可以使用$len$来获取字符串的长度</p><h3 id="字符串属性"><a href="#字符串属性" class="headerlink" title="字符串属性"></a>字符串属性</h3><pre class="line-numbers language-none"><code class="language-none">文本序列类型 --- str     字符串是一种 *序列类型* ，因此也支持序列类型的各种操作。  字符串的方法     字符串支持许多变换和查找的方法。  格式化字符串字面值     内嵌表达式的字符串字面值。  格式字符串语法     使用 &quot;str.format()&quot; 进行字符串格式化。  printf 风格的字符串格式化     这里详述了使用 &quot;%&quot; 运算符进行字符串格式化。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>字符串是可以被索引 (下标) 访问的，字符串的第一个字母的索引是 $0$</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">ts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="负索引"><a href="#负索引" class="headerlink" title="负索引"></a>负索引</h3><p>索引使用负数的话说明是从右边往左边开始数，因为我们考虑到0的负数还是本身所以我们从 $-1$开始数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">do<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>索引可以获得单个字符，切片可以获得一个字符串的字串，切片的形式是$[l:r]$，对于切片来说$l$是被包含在输出的字符串当中但是$r$不会</p><p>切片的索引有默认值；省略开始索引时默认为0，省略结束索引时默认为到字符 串的结束:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> test<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">testwtestwordtesord<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以发现一个性质就是对于一个字符串来说$s[:i] + s[i:] &#x3D; s$</p><h3 id="索引越界"><a href="#索引越界" class="headerlink" title="索引越界"></a>索引越界</h3><p>在我们使用过大的索引的时候会出现以下的错误:</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">114514</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Traceback (most recent call last):  File &quot;e:\Sublime Text\code\codeforces\traing\test.py&quot;, line 2, in &lt;module&gt;    print(test[114514])IndexError: string index out of range<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>但是对于切片中的越界索引他会自动去取到相对应的边界</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">114514</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">114514</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">stword<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>列表是写在<code>[]</code>之间用有道分隔开的元素列表，和字符串一样列表也可以被索引和截取，列表被截取后返回一个包含所需元素的新列表，注意列表中的元素类型可以不相同</p><p>我们可以通过和字符串类似的写法$[a:b:c]$来表示从坐标$a$开始到坐标$b - 1$每次相间隔$c$去一个列表中的元素，特别需要注意的是，当$c &lt; 0$的时候，截取字符是从后往前的，那么我们可以采用如下的写法来进行对一个列表逆序</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span>    inputWords <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span>     <span class="token comment"># 翻转字符串</span>    <span class="token comment"># 假设列表 list = [1,2,3,4],  </span>    <span class="token comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span>    <span class="token comment"># inputWords[-1::-1] 有三个参数</span>    <span class="token comment"># 第一个参数 -1 表示最后一个元素</span>    <span class="token comment"># 第二个参数为空，表示移动到列表末尾</span>    <span class="token comment"># 第三个参数为步长，-1 表示逆向</span>    inputWords<span class="token operator">=</span>inputWords<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>     <span class="token comment"># 重新组合字符串</span>    output <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>inputWords<span class="token punctuation">)</span>         <span class="token keyword">return</span> output <span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token builtin">input</span> <span class="token operator">=</span> <span class="token string">'I like runoob'</span>    rw <span class="token operator">=</span> reverseWords<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>列表还可以通过$append$来添加元素</p><h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p><p>像$ if $、$ while $ 、$ def $ 和$ class$ 这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> expression <span class="token punctuation">:</span>    suite<span class="token keyword">elif</span> expression <span class="token punctuation">:</span>    suite <span class="token keyword">else</span> <span class="token punctuation">:</span>    suite<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p><p>元组中的类型也可以不相同</p><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 ${ }$ 或者 $set()$ 函数创建集合，注意：创建一个空集合必须用 $set()$ 而不是 ${ }$，因为 ${ }$ 是用来创建一个空字典。</p><p>创建格式：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">st <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span>a <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">"1234567"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a:"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"st:"</span><span class="token punctuation">,</span>st<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">&#125;</span>st<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然，对于一个已有元素的$set$,如果我们需要往这个里面添加元素的话，我们可以使用$add$函数来进行添加</p><p>注意这里的集合是一个 <strong>没有顺序</strong> 的集合</p><p>对于集合来说我们通常还需要判断一个集合和另外一个集合之间的关系，那么实际上 $python$也为我们提供了这些方法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">print(a - b)     # a 和 b 的差集print(a | b)     # a 和 b 的并集print(a &amp; b)     # a 和 b 的交集print(a ^ b)     # a 和 b 中不同时存在的元素，即只在一个集合中出现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">"145296"</span><span class="token punctuation">)</span>b <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">"256789"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">|</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">^</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">&#123;</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p>字典是一种映射类型，字典用 ${ }$标识，它是一个无序的 键$(key)$ : 值$(value)$ 的集合。</p><p>键$(key)$必须使用不可变类型。</p><p>在同一个字典中，键$(key)$必须是唯一的。</p><p>注意对于字典的构造函数$dict()$也可以直接从键值对序列中构建字典如下</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token string">'Runoob'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Google'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">&#123;</span>x<span class="token punctuation">:</span> x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">:</span> <span class="token number">36</span><span class="token punctuation">&#125;</span><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">dict</span><span class="token punctuation">(</span>Runoob<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> Google<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> Taobao<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token string">'Runoob'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Google'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h3><p>$python$提供$input()$函数从标准输入中读入一行 <strong>文本</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="读取一行中的多个数字"><a href="#读取一行中的多个数字" class="headerlink" title="读取一行中的多个数字"></a>读取一行中的多个数字</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 读取一行中的两个整数</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="读取一行中的数字，两个数字类型不一样"><a href="#读取一行中的数字，两个数字类型不一样" class="headerlink" title="读取一行中的数字，两个数字类型不一样"></a>读取一行中的数字，两个数字类型不一样</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 读取一行中的两个数字</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>a <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>b <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读取一个文件直到末尾"><a href="#读取一个文件直到末尾" class="headerlink" title="读取一个文件直到末尾"></a>读取一个文件直到末尾</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 打开文件</span><span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token comment"># 读取文件的每一行</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>        <span class="token comment"># 在这里处理每一行的数据</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python循环语句"><a href="#Python循环语句" class="headerlink" title="Python循环语句"></a>Python循环语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>$python$中并不存在$do…while$的语法，因此我们可以直接用$while$来写。</p><p>除此之外$python$还存在在一个$while$后面跟着$else$</p><p>一般来说是如果我当前的$while$不执行的话那么我就会直接走后面的$else$</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">10</span>now <span class="token operator">=</span> <span class="token number">0</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> now <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>    <span class="token builtin">sum</span> <span class="token operator">+=</span> now    now <span class="token operator">+=</span> <span class="token number">1</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sum??"</span><span class="token punctuation">,</span><span class="token builtin">sum</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如上面的程序就是先去计算$1…10$的和然后跳出循环之后直接输出这个和是多少</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>我们需要注意的是，对于$python$来说，$for$循环可以遍历任何可以迭代的对象，比如一个列表或者一个字符串</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">:</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Good number"</span><span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"now number is"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"no good number"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"finish"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于上述程序我们跑出来的结果是</p><pre class="line-numbers language-none"><code class="language-none">now number is 1now number is 2Good numberfinish<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>更改成以下内容跑出来的数据相对应的是</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">:</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Good number"</span><span class="token punctuation">)</span>        <span class="token keyword">break</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"now number is"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"no good number"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"finish"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">now number is 1now number is 2now number is 7now number is 4now number is 5no good numberfinish<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h4><p>遍历数字序列的时候我们可以使用内置的$range$函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>end <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">0 1 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何指定区间的话，假设$range(l,r)$，那么我们获得的数字就是从$l$然后一直到$r - 1$</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>end <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">5 6 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然$range$还具有第三个参数步长，可以通过给这个步长一些指定的参数来进行循环</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token builtin">sum</span> <span class="token operator">+=</span> i<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比如上述程序就会从$0 - 8$逐个相加</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token builtin">sum</span> <span class="token operator">+=</span> i<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时我们也可以通过$range$和$len$函数去遍历一个序列的索引</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">666</span><span class="token punctuation">,</span><span class="token number">7777</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">0 11 22 33 44 555 6666 7777<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goodbye2022</title>
      <link href="/2023/01/03/goodbye2022/"/>
      <url>/2023/01/03/goodbye2022/</url>
      
        <content type="html"><![CDATA[<h1 id="Good-Bye-2022"><a href="#Good-Bye-2022" class="headerlink" title="Good Bye 2022"></a>Good Bye 2022</h1><h2 id="A-Koxia-and-Whiteboards"><a href="#A-Koxia-and-Whiteboards" class="headerlink" title="A.Koxia and Whiteboards"></a>A.Koxia and Whiteboards</h2><p>**题目大意: ** 给定一个长度为$n$的序列，接下来进行$m$次操作，问操作之后序列值最大是多少</p><p><strong>解题思路:</strong> 数量级很小考虑暴力即可，每次把$a$序列中最小的元素换下来</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 1e6 + 10;int n,m,a[maxn],b[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;multiset&lt;int&gt; st;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i],st.insert(a[i]);for(int i &#x3D; 1;i &lt;&#x3D; m;++i) cin &gt;&gt; b[i];for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;st.erase(st.begin());st.insert(b[i]);&#125;int sum &#x3D; 0;for(auto to:st) sum +&#x3D; to;cout &lt;&lt; sum &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Koxia-and-Permutation"><a href="#B-Koxia-and-Permutation" class="headerlink" title="B. Koxia and Permutation"></a>B. Koxia and Permutation</h2><p><strong>题目大意:</strong> 构造一个长度为$n$的序列，进行$n - k + 1$次划分，第$i$次划分获得的是从$i$开始$k$个数字的最大值和最小值相加，一个排列$p$的代价是划分中的值的最大值，问这个最大值最小的序列是什么样的</p><p><strong>解题思路:</strong> 因为最后要让我们的最大值最小，考虑值的构成是一个区域内的最大值加上最小值，如果一段区域里面都是连续的大数是肯定不行的，因此我们可以从$1-n$的数字头尾顺序取即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 1e6 + 10;int n,m,a[maxn],b[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;vector&lt;int&gt; ans;for(int i &#x3D; 1,j &#x3D; n;i &lt; j;++i,--j)&#123;ans.push_back(j);ans.push_back(i);&#x2F;&#x2F; cout &lt;&lt; &quot;??? &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;&#125;if(n &amp; 1) ans.push_back((n + 1) &#x2F; 2);for(auto to:ans)&#123;cout &lt;&lt; to &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Koxia-and-Number-Theory"><a href="#C-Koxia-and-Number-Theory" class="headerlink" title="C. Koxia and Number Theory"></a>C. Koxia and Number Theory</h2><p><strong>题目大意:</strong> 给定一个长度为$n$的序列,问是否存在一个$x$使得每一对$gcd(a_i+ x ,a_j + x) &#x3D; 1$</p><p><strong>解题思路:</strong> 不懂数学，感觉可以看严格鸽的</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 1e6 + 10;int n,m,a[maxn],b[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;set&lt;int&gt; st;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i],st.insert(a[i]);if(st.size() !&#x3D; n)&#123;cout &lt;&lt; &quot;No\n&quot;;continue;&#125;int f &#x3D; 1;for(int p &#x3D; 2;p &lt;&#x3D; n;++p)&#123;map&lt;int,int&gt; mp;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) mp[a[i] % p]++;int mi &#x3D; n + n;int ha &#x3D; 0;for(auto to:mp)&#123;if(to.second &gt;&#x3D; 2) ha++;&#125;if(ha &gt;&#x3D; p) f &#x3D; 0;&#125;if(f) cout &lt;&lt; &quot;Yes\n&quot;;else cout &lt;&lt; &quot;No\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Koxia-and-Game"><a href="#D-Koxia-and-Game" class="headerlink" title="D. Koxia and Game"></a>D. Koxia and Game</h2><p><strong>题目大意:</strong> 有三个长度为$n$的序列$a,b,c$</p><p>$Alice$和$Bob$玩游戏，一共进行$n$个回合，游戏规则如下：</p><ul><li>选定$a_i,b_i,c_i$</li><li>$Alice$从这三个数字选择一个数字删掉</li><li>$Bob$从这三个数字选择一个数字</li></ul><p>我们让$Bob$每回合选择的数字是$d_i$,如果序列$d$是一个排列那么$Alice$获胜否则$Bob$获胜</p><p>现在给定$a,b$两个数组，问有多少个$c$数组可以使得$Bob$获胜，结果对$998244353$取模</p><p><strong>解题思路:</strong> 首先我们先考虑$Alice$会选择什么数字删掉，假设对于第$i$次操作来说，$a_i &#x3D; b_i$,那么我们可以选择任意的$c_i$并且最终把$c_i$删掉，这样子$Bob$一定取到的是$a_i$这个数字表示的值(因为$a_i &#x3D; b_i$)</p><p>然后我们考虑如果$a_i \neq b_i$那么我们选择的$c_i$就非常重要，因为$c_i$决定着我们可以选择$a_i$或者$b_i$中的哪个数字，只需要让$c_i &#x3D; a_i \ or \ c_i &#x3D; b_i$即可</p><p>那么选择某一个位置的思路就很清晰了，我们只需要考虑构造大于等于两个相同的并且把其中一个不需要的值删掉即可</p><p>接下来我们再考虑位置之间带来的因素</p><p>假设我们没有$a_i &#x3D; b_i$的情况，那么我们现在的问题可以转换为给定两个序列分别是$a,b$，每个位置上面取一个看是否可以构成一个排序</p><p>对于这一个问题来说，因为每一个位置做一个选择，同时也相同与每一个位置的两个数字相互制衡，那么我们可以用图论的语言来表达，在他们之间建一条边</p><p>我们可以发现只有基环树的形式是可以的，而基环树的形式实际上就是点数等于边数</p><p>那么我们最终只需要使用并查集取维护每个环中存在点数和边数即可</p><p>那么最后再思考答案贡献，对于一个基环树来说，如果这个树里面没有自环，那么贡献就是$2$，因为考虑每条边有两个选择，如果里面有自环的话，贡献就是$n$</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 1e6 + 10;const int mod &#x3D; 998244353;int n,m,a[maxn],b[maxn];int f[maxn],szv[maxn],sze[maxn],loop[maxn];void init()&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;f[i] &#x3D; i;szv[i] &#x3D; 1;sze[i] &#x3D; 0;loop[i] &#x3D; 0;&#125;&#125;int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y)&#123;int fx &#x3D; getf(x);int fy &#x3D; getf(y);if(fx !&#x3D; fy)&#123;f[fy] &#x3D; fx;sze[fx] +&#x3D; sze[fy];szv[fx] +&#x3D; szv[fy];loop[fx] +&#x3D; loop[fy];&#125;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;init();for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; b[i];for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;merge(a[i],b[i]);sze[getf(a[i])]++;if(a[i] &#x3D;&#x3D; b[i]) loop[getf(a[i])]++;&#125;int ans &#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(i &#x3D;&#x3D; getf(i))&#123;if(sze[i] !&#x3D; szv[i]) ans &#x3D; 0;                else ans &#x3D; ans * 2 % mod;&#125;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICPC-2021-EC-J</title>
      <link href="/2022/11/11/ICPC-2021-EC-J/"/>
      <url>/2022/11/11/ICPC-2021-EC-J/</url>
      
        <content type="html"><![CDATA[<h1 id="J-Elden-Ring"><a href="#J-Elden-Ring" class="headerlink" title="J. Elden Ring"></a>J. Elden Ring</h1><p><a href="https://codeforces.com/gym/103861/problem/J">https://codeforces.com/gym/103861/problem/J</a></p><p><strong>题目大意:</strong> 给定一个规模为$2e5$的无向图，每个点除了起始点都有一个怪物在那里，第$i$个点的怪物的战力值为$l_i$，我们初始的战力值为$l_1$</p><p>我们可以打败怪物当且仅当我们的战力值比怪物的高。怪物每天的战力值会增加$B$，我们杀掉一只怪物增加的战力值为$A$，问我们是否可以到达最终点</p><p><strong>解题思路:</strong> 考虑这道题和别的题目不一样的地方也就是引入了战力值这个概念，首先我们假设我们的战力值永远不会改变，那么起始也就是对于$A &#x3D; B$的这一种情况，我们直接$BFS$，并且看当前这个点的战力值是否比起始点要小，符合条件的那么我们就可以加入相对应的队列即可。</p><p>然后我们考虑$A &lt; B$的这一种情况，因为我们的战力值是不断减少的，那么我们仍然可以直接$BFS$去找我们可以到达的点，并且比较到达当前点消耗的数值是否比原来的战力值小即可。</p><p>最后我们来分析$A &gt; B$的情况，因为$A &gt; B$，所以我们的战力值是在不断增加的。在不断增加的时候我们实际上是可以开放很多点的，那么对于原来的跑图来说我们处理的要么是本身可以到达的，要么是处理因为一些条件不能到达的，因此对于这一张新图来说我们先跑一遍最短路来处理什么点在这种情况下可以先到达。</p><p>对于处理这一张新图来说我们首先先把$1$号节点给放进去，然后我们再跑$dij$，优先队列里面放的是当前点的权值和这个点，维护一个小数字在前面的队列。因为小数字在前面，那么我们可以不断增加自己的战力值，因此最后有可能达到一些权值更大的情况。</p><p>然后在跑实际天数的时候我们可以直接跑$dij$，但是这里的话使用的是从$1$号节点到当前这个$now$节点所需要的天数,然后对当前的值进行分析，如果比转移点要小的话直接$+1$即可，否则计算以下从$1$号节点转移过来的权值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int maxn &#x3D; 2e5 + 10;const ll inf &#x3D; 1e18;vector&lt;int&gt; edge[maxn];ll n,m,A,B;ll dis[maxn],vis[maxn],val[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;for(int Case &#x3D; 1;Case &lt;&#x3D; T;++Case)&#123;cin &gt;&gt; n &gt;&gt; m &gt;&gt; A &gt;&gt; B;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;edge[i].clear();dis[i] &#x3D; inf;vis[i] &#x3D; 0;&#125;for(int i &#x3D; 1,u,v;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v;edge[u].push_back(v);edge[v].push_back(u);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; val[i],val[i] +&#x3D; B;val[1] -&#x3D; B;if(A &#x3D;&#x3D; B)&#123;queue&lt;int&gt; que;que.push(1);dis[1] &#x3D; 0;while(!que.empty())&#123;auto now &#x3D; que.front();que.pop();for(auto to:edge[now])&#123;if(val[to] &lt; val[1] &amp;&amp; dis[to] &gt; dis[now])&#123;que.push(to);dis[to] &#x3D; dis[now] + 1;&#125;&#125;&#125;cout &lt;&lt; (dis[n] &#x3D;&#x3D; inf ? -1 : dis[n]) &lt;&lt; &quot;\n&quot;;&#125;else if(A &lt; B)&#123;queue&lt;int&gt; que;que.push(1);dis[1] &#x3D; 0;while(!que.empty())&#123;auto now &#x3D; que.front();que.pop();for(auto to:edge[now])&#123;if(1ll * val[to] + dis[now] * (B - A) * 1ll &lt; val[1] &amp;&amp; dis[to] &gt; dis[now])&#123;dis[to] &#x3D; dis[now] + 1;que.push(to);&#125;&#125;&#125;cout &lt;&lt; (dis[n] &#x3D;&#x3D; inf ? -1 : dis[n]) &lt;&lt; &quot;\n&quot;;&#125;else&#123;priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; que;int day &#x3D; -1;que.push(&#123;0,1&#125;);while(!que.empty())&#123;auto [nowd,now] &#x3D; que.top();que.pop();if(vis[now]) continue;if(day !&#x3D; -1 &amp;&amp; val[now] &gt;&#x3D; val[1] + (A - B) * day)&#123;break;&#125;vis[now] &#x3D; 1;day++;for(auto to:edge[now])&#123;if(!vis[to]) que.push(&#123;val[to],to&#125;);&#125;&#125;dis[1] &#x3D; 0;while(!que.empty()) que.pop();que.push(&#123;dis[1],1&#125;);while(!que.empty())&#123;auto [nowd,now] &#x3D; que.top();que.pop();if(nowd &gt; dis[now]) continue;for(auto to:edge[now])&#123;if(!vis[to]) continue;if(val[to] &lt; val[now] &amp;&amp; dis[to] &gt; nowd + 1)&#123;dis[to] &#x3D; nowd + 1;que.push(&#123;dis[to],to&#125;);continue;&#125;if(dis[to] &gt; max(nowd + 1ll,(val[to] - val[1]) &#x2F; (A - B) + 2))&#123;dis[to] &#x3D; max(nowd + 1ll,(val[to] - val[1]) &#x2F; (A - B) + 2);que.push(&#123;dis[to],to&#125;);&#125;&#125;&#125;cout &lt;&lt; (dis[n] &#x3D;&#x3D; inf ? -1 : dis[n]) &lt;&lt; &quot;\n&quot;;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 831 A - E</title>
      <link href="/2022/11/01/Codeforces-Round-831-A-E/"/>
      <url>/2022/11/01/Codeforces-Round-831-A-E/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-831-A-E"><a href="#Codeforces-Round-831-A-E" class="headerlink" title="Codeforces Round 831 A - E"></a>Codeforces Round 831 A - E</h1><h2 id="A-Factorise-N-M"><a href="#A-Factorise-N-M" class="headerlink" title="A. Factorise N+M"></a>A. Factorise N+M</h2><p><strong>题目大意:</strong> 给定一个质数$n$，找到一个质数$m$ ，使得$n + m$是一个非质数</p><p><strong>解题思路:</strong> 对于非$2$的质数来说其他质数全部都是奇数，那么我们可以对于这些质数加上一个$3$，然后对于$2$特判加上$5$即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;if(n &#x3D;&#x3D; 2)&#123;cout &lt;&lt; 7 &lt;&lt; &quot;\n&quot;;&#125;else cout &lt;&lt; 3 &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Jumbo-Extra-Cheese-2"><a href="#B-Jumbo-Extra-Cheese-2" class="headerlink" title="B. Jumbo Extra Cheese 2"></a>B. Jumbo Extra Cheese 2</h2><p><strong>题目大意:</strong> 给定$n$个矩阵，我们需要把矩阵放到$x$轴上面，一个矩阵不能放在另外一个矩阵的上面，问这个矩阵的形成的一个图形的周长是多少</p><p><strong>解题思路:</strong> 将这个图形拿出来在颅内思考一下，发现因为很多个矩形会贴在一起，那么对于形成的这个图形的 <strong>高</strong> 实际上就是最长的矩形的高，同时对于每个矩形来说他们的宽都要计算两边，那么我们对于每一个矩形来说我们可以选定较小的那一部分作为宽，较高的那一部分作为高，然后找一个最长的高即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pair&lt;int,int&gt; a[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;for(int i &#x3D; 1,u,v;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; u &gt;&gt; v;if(u &lt; v) swap(u,v);a[i] &#x3D; &#123;u,v&#125;;&#125;sort(a + 1,a + 1 + n);int ans &#x3D; 2 * a[n].first;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;ans +&#x3D; a[i].second * 2;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Bricks-and-Bags"><a href="#C-Bricks-and-Bags" class="headerlink" title="C. Bricks and Bags"></a>C. Bricks and Bags</h2><p><strong>题目大意:</strong> 给定$n(1 \leq n \leq 10^5)$个数字，将他们放在$a,b,c$三个背包中，玩家需要从这三个背包中各选择一个数字，并且计算$|w_1 - w_2| + |w_2 - w_3|$ $(w_1 \in a,w_2 \in b,w_3 \in c)$的值是多少，然后玩家想要让值尽可能的小，放置者想要让值尽可能的大，问如何放置才能使得这个值最大</p><p><strong>解题思路:</strong> 首先先放在数轴上面考虑这个问题，我们假设$w_3 &gt; w_1$，如果$w_2$在$w_1$和$w_3$之间，那么值就是$w_3 - w_1$，如果$w_2 &lt; w_1$，那么对应的值就是$w_1 - w_2 + w_3 - w_2$，若$w_2 &gt; w_3$，那么对应的值就是$w_2 - w_3 + w_2 - w_1$</p><p>对于夹在中间的情况，我们可以直接计算，也就是整个序列的最大值减去整个序列的最小值</p><p>如果是第一种情况$w_2 &lt; w_1$，那么实际上我们是去取若干个小值给放在$b$中，为了让权值最大我们可以把$a_n$给单独拉出来当作$w_3$，假设目前取到的小值已经到了第$i$位，那么权值就是$a_n - a_i + a_{i + 1} - a_i$</p><p>如果是第二种情况$w_2 &gt; w_3$，那么实际上我们就是去取若干个大值给放在$b$中，为了让权值最大我们可以把$a_1$给单独拉出来当作$w_1$，假设目前取到的大值已经到了第$i$位，那么权值实际上就是$a_i - a_1 + a_i - a_{i - 1}$</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];sort(a + 1,a + 1 + n);int ans &#x3D; 0;for(int i &#x3D; 1;i &lt; n - 1;++i)&#123;chkmax(ans,a[n] - a[i] + a[i + 1] - a[i]);&#125;for(int i &#x3D; n;i &gt; 2;--i)&#123;chkmax(ans,a[i] - a[i - 1] + a[i] - a[1]);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Knowledge-Cards"><a href="#D-Knowledge-Cards" class="headerlink" title="D. Knowledge Cards"></a>D. Knowledge Cards</h2><p><strong>题目大意:</strong> 给定一个$n * m(n * m \leq 10^6)$的矩阵，刚开始在矩阵$(1,1)$堆积着$k$张牌，从顶部到底部分别是$a_1,a_2,…,a_k$，接下来我们可以把牌移动到别的格子中，注意除了$(1,1)$和$(n,m)$这两个格子其他格子放置的牌数不能超过一张，然后$(1,1)$不能被重复放置牌，也不能从$(n,m)$移出去一张牌，问堆在$(n,m)$上面的牌从顶部到底部牌的排列是否可以是$1,2,3,…k$</p><p><strong>解题思路:</strong> 直接移动牌即可，因为我们在移动牌的时候肯定需要给当前一张牌留出一点位置的，所以除了$(1,1)$和$(n,m)$我们另外留出一个位置就能随便移动了，否则就是不能构成的情况</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;for(int i &#x3D; 1;i &lt;&#x3D; k;++i) cin &gt;&gt; a[i];int nowcnt &#x3D; k;priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;int f &#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;    q.push(a[i]);    if(q.size() &gt;&#x3D; n * m - 2)    &#123;        f &#x3D; 0;        break;    &#125;    while(!q.empty() &amp;&amp; q.top() &#x3D;&#x3D; nowcnt)    &#123;        q.pop();        nowcnt--;    &#125;&#125;if(f) cout &lt;&lt; &quot;YA\n&quot;;else cout &lt;&lt; &quot;TIDAK\n&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Hanging-Hearts"><a href="#E-Hanging-Hearts" class="headerlink" title="E. Hanging Hearts"></a>E. Hanging Hearts</h2><p><strong>题目大意:</strong> 给定一棵树，我们需要给这棵树分配一些权值，这些权值属于一个排列。然后我们从叶子开始取，取的时候会构成一个序列。我们每次取叶子的时候判断他的父节点是否大于叶子结点如果大于叶子结点那么父节点的权值也变成叶子结点的权值，问构成的序列中形成的最大非递减子序列长度是多少</p><p><strong>解题思路:</strong> 考虑拿取叶子的性质实际上我们将小的权值放在下面更好一点，因为小的权值会把权值赋值给上面的父亲节点，那么对于一个节点来说她下面可能有很多条链，我这个节点要么作为子序列的终点要么作为子序列的中转点。如果作为终点的话那么也需要从下面的终点转移过来，如果作为中转点的话就可以将下面的节点选择他们的中转点或者是终点取最大然后把权值全部加起来</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n,m,k;int dp[maxn][2];vector&lt;int&gt; edge[maxn];void dfs(int s,int fa)&#123;dp[s][0] &#x3D; dp[s][1] &#x3D; 0;int mx &#x3D; 0;for(auto to:edge[s])&#123;if(to &#x3D;&#x3D; fa) continue;dfs(to,s);dp[s][0] +&#x3D; max(dp[to][0],dp[to][1]);chkmax(mx,dp[to][1]);&#125;dp[s][1] &#x3D; mx + 1;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 2,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;edge[i].push_back(x);edge[x].push_back(i);&#125;dfs(1,0);cout &lt;&lt; max(dp[1][0],dp[1][1]) &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computational Geometry</title>
      <link href="/2022/10/29/Computational-Geometry/"/>
      <url>/2022/10/29/Computational-Geometry/</url>
      
        <content type="html"><![CDATA[<h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;using point_t&#x3D;long double;  &#x2F;&#x2F;全局数据类型，可修改为 long long 等constexpr point_t eps&#x3D;1e-8;constexpr long double PI&#x3D;3.1415926535897932384l;&#x2F;&#x2F; 点与向量template&lt;typename T&gt; struct point&#123;    T x,y;    bool operator&#x3D;&#x3D;(const point &amp;a) const &#123;return (abs(x-a.x)&lt;&#x3D;eps &amp;&amp; abs(y-a.y)&lt;&#x3D;eps);&#125;    bool operator&lt;(const point &amp;a) const &#123;if (abs(x-a.x)&lt;&#x3D;eps) return y&lt;a.y-eps; return x&lt;a.x-eps;&#125;    bool operator&gt;(const point &amp;a) const &#123;return !(*this&lt;a || *this&#x3D;&#x3D;a);&#125;    point operator+(const point &amp;a) const &#123;return &#123;x+a.x,y+a.y&#125;;&#125;    point operator-(const point &amp;a) const &#123;return &#123;x-a.x,y-a.y&#125;;&#125;    point operator-() const &#123;return &#123;-x,-y&#125;;&#125;    point operator*(const T k) const &#123;return &#123;k*x,k*y&#125;;&#125;    point operator&#x2F;(const T k) const &#123;return &#123;x&#x2F;k,y&#x2F;k&#125;;&#125;    T operator*(const point &amp;a) const &#123;return x*a.x+y*a.y;&#125;  &#x2F;&#x2F; 点积    T operator^(const point &amp;a) const &#123;return x*a.y-y*a.x;&#125;  &#x2F;&#x2F; 叉积，注意优先级    int toleft(const point &amp;a) const &#123;const auto t&#x3D;(*this)^a; return (t&gt;eps)-(t&lt;-eps);&#125;  &#x2F;&#x2F; to-left 测试    T len2() const &#123;return (*this)*(*this);&#125;  &#x2F;&#x2F; 向量长度的平方    T dis2(const point &amp;a) const &#123;return (a-(*this)).len2();&#125;  &#x2F;&#x2F; 两点距离的平方    &#x2F;&#x2F; 涉及浮点数    long double len() const &#123;return sqrtl(len2());&#125;  &#x2F;&#x2F; 向量长度    long double dis(const point &amp;a) const &#123;return sqrtl(dis2(a));&#125;  &#x2F;&#x2F; 两点距离    long double ang(const point &amp;a) const &#123;return acosl(max(-1.0l,min(1.0l,((*this)*a)&#x2F;(len()*a.len()))));&#125;  &#x2F;&#x2F; 向量夹角    point rot(const long double rad) const &#123;return &#123;x*cos(rad)-y*sin(rad),x*sin(rad)+y*cos(rad)&#125;;&#125;  &#x2F;&#x2F; 逆时针旋转（给定角度）    point rot(const long double cosr,const long double sinr) const &#123;return &#123;x*cosr-y*sinr,x*sinr+y*cosr&#125;;&#125;  &#x2F;&#x2F; 逆时针旋转（给定角度的正弦与余弦）&#125;;using Point&#x3D;point&lt;point_t&gt;;&#x2F;&#x2F; 极角排序struct argcmp&#123;    bool operator()(const Point &amp;a,const Point &amp;b) const    &#123;        const auto quad&#x3D;[](const Point &amp;a)        &#123;            if (a.y&lt;-eps) return 1;            if (a.y&gt;eps) return 4;            if (a.x&lt;-eps) return 5;            if (a.x&gt;eps) return 3;            return 2;        &#125;;        const int qa&#x3D;quad(a),qb&#x3D;quad(b);        if (qa!&#x3D;qb) return qa&lt;qb;        const auto t&#x3D;a^b;        &#x2F;&#x2F; if (abs(t)&lt;&#x3D;eps) return a*a&lt;b*b-eps;  &#x2F;&#x2F; 不同长度的向量需要分开        return t&gt;eps;    &#125;&#125;;&#x2F;&#x2F; 直线template&lt;typename T&gt; struct line&#123;    point&lt;T&gt; p,v;  &#x2F;&#x2F; p 为直线上一点，v 为方向向量    bool operator&#x3D;&#x3D;(const line &amp;a) const &#123;return v.toleft(a.v)&#x3D;&#x3D;0 &amp;&amp; v.toleft(p-a.p)&#x3D;&#x3D;0;&#125;    int toleft(const point&lt;T&gt; &amp;a) const &#123;return v.toleft(a-p);&#125;  &#x2F;&#x2F; to-left 测试    bool operator&lt;(const line &amp;a) const  &#x2F;&#x2F; 半平面交算法定义的排序    &#123;        if (abs(v^a.v)&lt;&#x3D;eps &amp;&amp; v*a.v&gt;&#x3D;-eps) return toleft(a.p)&#x3D;&#x3D;-1;        return argcmp()(v,a.v);    &#125;    &#x2F;&#x2F; 涉及浮点数    point&lt;T&gt; inter(const line &amp;a) const &#123;return p+v*((a.v^(p-a.p))&#x2F;(v^a.v));&#125;  &#x2F;&#x2F; 直线交点    long double dis(const point&lt;T&gt; &amp;a) const &#123;return abs(v^(a-p))&#x2F;v.len();&#125;  &#x2F;&#x2F; 点到直线距离    point&lt;T&gt; proj(const point&lt;T&gt; &amp;a) const &#123;return p+v*((v*(a-p))&#x2F;(v*v));&#125;  &#x2F;&#x2F; 点在直线上的投影&#125;;using Line&#x3D;line&lt;point_t&gt;;&#x2F;&#x2F;线段template&lt;typename T&gt; struct segment&#123;    point&lt;T&gt; a,b;    bool operator&lt;(const segment &amp;s) const &#123;return make_pair(a,b)&lt;make_pair(s.a,s.b);&#125;    &#x2F;&#x2F; 判定性函数建议在整数域使用    &#x2F;&#x2F; 判断点是否在线段上    &#x2F;&#x2F; -1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上    int is_on(const point&lt;T&gt; &amp;p) const      &#123;        if (p&#x3D;&#x3D;a || p&#x3D;&#x3D;b) return -1;        return (p-a).toleft(p-b)&#x3D;&#x3D;0 &amp;&amp; (p-a)*(p-b)&lt;-eps;    &#125;    &#x2F;&#x2F; 判断线段直线是否相交    &#x2F;&#x2F; -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交    int is_inter(const line&lt;T&gt; &amp;l) const    &#123;        if (l.toleft(a)&#x3D;&#x3D;0 || l.toleft(b)&#x3D;&#x3D;0) return -1;        return l.toleft(a)!&#x3D;l.toleft(b);    &#125;        &#x2F;&#x2F; 判断两线段是否相交    &#x2F;&#x2F; -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交    int is_inter(const segment&lt;T&gt; &amp;s) const    &#123;        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;        const line&lt;T&gt; l&#123;a,b-a&#125;,ls&#123;s.a,s.b-s.a&#125;;        return l.toleft(s.a)*l.toleft(s.b)&#x3D;&#x3D;-1 &amp;&amp; ls.toleft(a)*ls.toleft(b)&#x3D;&#x3D;-1;    &#125;    &#x2F;&#x2F; 点到线段距离    long double dis(const point&lt;T&gt; &amp;p) const    &#123;        if ((p-a)*(b-a)&lt;-eps || (p-b)*(a-b)&lt;-eps) return min(p.dis(a),p.dis(b));        const line&lt;T&gt; l&#123;a,b-a&#125;;        return l.dis(p);    &#125;    &#x2F;&#x2F; 两线段间距离    long double dis(const segment&lt;T&gt; &amp;s) const    &#123;        if (is_inter(s)) return 0;        return min(&#123;dis(s.a),dis(s.b),s.dis(a),s.dis(b)&#125;);    &#125;&#125;;using Segment&#x3D;segment&lt;point_t&gt;;&#x2F;&#x2F;----------------------------必打-----------------------&#x2F;&#x2F;&#x2F;&#x2F; 多边形template&lt;typename T&gt; struct polygon&#123;    vector&lt;point&lt;T&gt;&gt; p;  &#x2F;&#x2F; 以逆时针顺序存储    size_t nxt(const size_t i) const &#123;return i&#x3D;&#x3D;p.size()-1?0:i+1;&#125;    size_t pre(const size_t i) const &#123;return i&#x3D;&#x3D;0?p.size()-1:i-1;&#125;        &#x2F;&#x2F; 回转数    &#x2F;&#x2F; 返回值第一项表示点是否在多边形边上    &#x2F;&#x2F; 对于狭义多边形，回转数为 0 表示点在多边形外，否则点在多边形内    pair&lt;bool,int&gt; winding(const point&lt;T&gt; &amp;a) const    &#123;        int cnt&#x3D;0;        for (size_t i&#x3D;0;i&lt;p.size();i++)        &#123;            const point&lt;T&gt; u&#x3D;p[i],v&#x3D;p[nxt(i)];            if (abs((a-u)^(a-v))&lt;&#x3D;eps &amp;&amp; (a-u)*(a-v)&lt;&#x3D;eps) return &#123;true,0&#125;;            if (abs(u.y-v.y)&lt;&#x3D;eps) continue;            const Line uv&#x3D;&#123;u,v-u&#125;;            if (u.y&lt;v.y-eps &amp;&amp; uv.toleft(a)&lt;&#x3D;0) continue;            if (u.y&gt;v.y+eps &amp;&amp; uv.toleft(a)&gt;&#x3D;0) continue;            if (u.y&lt;a.y-eps &amp;&amp; v.y&gt;&#x3D;a.y-eps) cnt++;            if (u.y&gt;&#x3D;a.y-eps &amp;&amp; v.y&lt;a.y-eps) cnt--;        &#125;        return &#123;false,cnt&#125;;    &#125;    &#x2F;&#x2F; 多边形面积的两倍    &#x2F;&#x2F; 可用于判断点的存储顺序是顺时针或逆时针    T area() const    &#123;        T sum&#x3D;0;        for (size_t i&#x3D;0;i&lt;p.size();i++) sum+&#x3D;p[i]^p[nxt(i)];        return sum;    &#125;    &#x2F;&#x2F; 多边形的周长    long double circ() const    &#123;        long double sum&#x3D;0;        for (size_t i&#x3D;0;i&lt;p.size();i++) sum+&#x3D;p[i].dis(p[nxt(i)]);        return sum;    &#125;&#125;;using Polygon&#x3D;polygon&lt;point_t&gt;;&#x2F;&#x2F;凸多边形template&lt;typename T&gt; struct convex: polygon&lt;T&gt;&#123;    &#x2F;&#x2F; 闵可夫斯基和    convex operator+(const convex &amp;c) const      &#123;        const auto &amp;p&#x3D;this-&gt;p;        vector&lt;Segment&gt; e1(p.size()),e2(c.p.size()),edge(p.size()+c.p.size());        vector&lt;point&lt;T&gt;&gt; res; res.reserve(p.size()+c.p.size());        const auto cmp&#x3D;[](const Segment &amp;u,const Segment &amp;v) &#123;return argcmp()(u.b-u.a,v.b-v.a);&#125;;        for (size_t i&#x3D;0;i&lt;p.size();i++) e1[i]&#x3D;&#123;p[i],p[this-&gt;nxt(i)]&#125;;        for (size_t i&#x3D;0;i&lt;c.p.size();i++) e2[i]&#x3D;&#123;c.p[i],c.p[c.nxt(i)]&#125;;        rotate(e1.begin(),min_element(e1.begin(),e1.end(),cmp),e1.end());        rotate(e2.begin(),min_element(e2.begin(),e2.end(),cmp),e2.end());        merge(e1.begin(),e1.end(),e2.begin(),e2.end(),edge.begin(),cmp);        const auto check&#x3D;[](const vector&lt;point&lt;T&gt;&gt; &amp;res,const point&lt;T&gt; &amp;u)        &#123;            const auto back1&#x3D;res.back(),back2&#x3D;*prev(res.end(),2);            return (back1-back2).toleft(u-back1)&#x3D;&#x3D;0 &amp;&amp; (back1-back2)*(u-back1)&gt;&#x3D;-eps;        &#125;;        auto u&#x3D;e1[0].a+e2[0].a;        for (const auto &amp;v:edge)        &#123;            while (res.size()&gt;1 &amp;&amp; check(res,u)) res.pop_back();            res.push_back(u);            u&#x3D;u+v.b-v.a;        &#125;        if (res.size()&gt;1 &amp;&amp; check(res,res[0])) res.pop_back();        return &#123;res&#125;;    &#125;    &#x2F;&#x2F; 旋转卡壳    &#x2F;&#x2F; func 为更新答案的函数，可以根据题目调整位置    template&lt;typename F&gt; void rotcaliper(const F &amp;func) const    &#123;        const auto &amp;p&#x3D;this-&gt;p;        const auto area&#x3D;[](const point&lt;T&gt; &amp;u,const point&lt;T&gt; &amp;v,const point&lt;T&gt; &amp;w)&#123;return (w-u)^(w-v);&#125;;        for (size_t i&#x3D;0,j&#x3D;1;i&lt;p.size();i++)        &#123;            const auto nxti&#x3D;this-&gt;nxt(i);            func(p[i],p[nxti],p[j]);            while (area(p[this-&gt;nxt(j)],p[i],p[nxti])&gt;&#x3D;area(p[j],p[i],p[nxti]))            &#123;                j&#x3D;this-&gt;nxt(j);                func(p[i],p[nxti],p[j]);            &#125;        &#125;    &#125;    &#x2F;&#x2F; 凸多边形的直径的平方    T diameter2() const    &#123;        const auto &amp;p&#x3D;this-&gt;p;        if (p.size()&#x3D;&#x3D;1) return 0;        if (p.size()&#x3D;&#x3D;2) return p[0].dis2(p[1]);        T ans&#x3D;0;        auto func&#x3D;[&amp;](const point&lt;T&gt; &amp;u,const point&lt;T&gt; &amp;v,const point&lt;T&gt; &amp;w)&#123;ans&#x3D;max(&#123;ans,w.dis2(u),w.dis2(v)&#125;);&#125;;        rotcaliper(func);        return ans;    &#125;        &#x2F;&#x2F; 判断点是否在凸多边形内    &#x2F;&#x2F; 复杂度 O(logn)    &#x2F;&#x2F; -1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内    int is_in(const point&lt;T&gt; &amp;a) const    &#123;        const auto &amp;p&#x3D;this-&gt;p;        if (p.size()&#x3D;&#x3D;1) return a&#x3D;&#x3D;p[0]?-1:0;        if (p.size()&#x3D;&#x3D;2) return segment&lt;T&gt;&#123;p[0],p[1]&#125;.is_on(a)?-1:0;         if (a&#x3D;&#x3D;p[0]) return -1;        if ((p[1]-p[0]).toleft(a-p[0])&#x3D;&#x3D;-1 || (p.back()-p[0]).toleft(a-p[0])&#x3D;&#x3D;1) return 0;        const auto cmp&#x3D;[&amp;](const Point &amp;u,const Point &amp;v)&#123;return (u-p[0]).toleft(v-p[0])&#x3D;&#x3D;1;&#125;;        const size_t i&#x3D;lower_bound(p.begin()+1,p.end(),a,cmp)-p.begin();        if (i&#x3D;&#x3D;1) return segment&lt;T&gt;&#123;p[0],p[i]&#125;.is_on(a)?-1:0;        if (i&#x3D;&#x3D;p.size()-1 &amp;&amp; segment&lt;T&gt;&#123;p[0],p[i]&#125;.is_on(a)) return -1;        if (segment&lt;T&gt;&#123;p[i-1],p[i]&#125;.is_on(a)) return -1;        return (p[i]-p[i-1]).toleft(a-p[i-1])&gt;0;    &#125;    &#x2F;&#x2F; 凸多边形关于某一方向的极点    &#x2F;&#x2F; 复杂度 O(logn)    &#x2F;&#x2F; 参考资料：https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;48868    template&lt;typename F&gt; size_t extreme(const F &amp;dir) const    &#123;        const auto &amp;p&#x3D;this-&gt;p;        const auto check&#x3D;[&amp;](const size_t i)&#123;return dir(p[i]).toleft(p[this-&gt;nxt(i)]-p[i])&gt;&#x3D;0;&#125;;        const auto dir0&#x3D;dir(p[0]); const auto check0&#x3D;check(0);        if (!check0 &amp;&amp; check(p.size()-1)) return 0;        const auto cmp&#x3D;[&amp;](const Point &amp;v)        &#123;            const size_t vi&#x3D;&amp;v-p.data();            if (vi&#x3D;&#x3D;0) return 1;            const auto checkv&#x3D;check(vi);            const auto t&#x3D;dir0.toleft(v-p[0]);            if (vi&#x3D;&#x3D;1 &amp;&amp; checkv&#x3D;&#x3D;check0 &amp;&amp; t&#x3D;&#x3D;0) return 1;            return checkv^(checkv&#x3D;&#x3D;check0 &amp;&amp; t&lt;&#x3D;0);        &#125;;        return partition_point(p.begin(),p.end(),cmp)-p.begin();    &#125;    &#x2F;&#x2F; 过凸多边形外一点求凸多边形的切线，返回切点下标    &#x2F;&#x2F; 复杂度 O(logn)    &#x2F;&#x2F; 必须保证点在多边形外    pair&lt;size_t,size_t&gt; tangent(const point&lt;T&gt; &amp;a) const    &#123;        const size_t i&#x3D;extreme([&amp;](const point&lt;T&gt; &amp;u)&#123;return u-a;&#125;);        const size_t j&#x3D;extreme([&amp;](const point&lt;T&gt; &amp;u)&#123;return a-u;&#125;);        return &#123;i,j&#125;;    &#125;    &#x2F;&#x2F; 求平行于给定直线的凸多边形的切线，返回切点下标    &#x2F;&#x2F; 复杂度 O(logn)    pair&lt;size_t,size_t&gt; tangent(const line&lt;T&gt; &amp;a) const    &#123;        const size_t i&#x3D;extreme([&amp;](...)&#123;return a.v;&#125;);        const size_t j&#x3D;extreme([&amp;](...)&#123;return -a.v;&#125;);        return &#123;i,j&#125;;    &#125;&#125;;using Convex&#x3D;convex&lt;point_t&gt;;&#x2F;&#x2F; 圆struct Circle&#123;    Point c;    long double r;    bool operator&#x3D;&#x3D;(const Circle &amp;a) const &#123;return c&#x3D;&#x3D;a.c &amp;&amp; abs(r-a.r)&lt;&#x3D;eps;&#125;    long double circ() const &#123;return 2*PI*r;&#125;  &#x2F;&#x2F; 周长    long double area() const &#123;return PI*r*r;&#125;  &#x2F;&#x2F; 面积    &#x2F;&#x2F; 点与圆的关系    &#x2F;&#x2F; -1 圆上 | 0 圆外 | 1 圆内    int is_in(const Point &amp;p) const &#123;const long double d&#x3D;p.dis(c); return abs(d-r)&lt;&#x3D;eps?-1:d&lt;r-eps;&#125;    &#x2F;&#x2F; 直线与圆关系    &#x2F;&#x2F; 0 相离 | 1 相切 | 2 相交    int relation(const Line &amp;l) const    &#123;        const long double d&#x3D;l.dis(c);        if (d&gt;r+eps) return 0;        if (abs(d-r)&lt;&#x3D;eps) return 1;        return 2;    &#125;    &#x2F;&#x2F; 圆与圆关系    &#x2F;&#x2F; -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含    int relation(const Circle &amp;a) const    &#123;        if (*this&#x3D;&#x3D;a) return -1;        const long double d&#x3D;c.dis(a.c);        if (d&gt;r+a.r+eps) return 0;        if (abs(d-r-a.r)&lt;&#x3D;eps) return 1;        if (abs(d-abs(r-a.r))&lt;&#x3D;eps) return 3;        if (d&lt;abs(r-a.r)-eps) return 4;        return 2;    &#125;    &#x2F;&#x2F; 直线与圆的交点    vector&lt;Point&gt; inter(const Line &amp;l) const    &#123;        const long double d&#x3D;l.dis(c);        const Point p&#x3D;l.proj(c);        const int t&#x3D;relation(l);        if (t&#x3D;&#x3D;0) return vector&lt;Point&gt;();        if (t&#x3D;&#x3D;1) return vector&lt;Point&gt;&#123;p&#125;;        const long double k&#x3D;sqrt(r*r-d*d);        return vector&lt;Point&gt;&#123;p-(l.v&#x2F;l.v.len())*k,p+(l.v&#x2F;l.v.len())*k&#125;;    &#125;    &#x2F;&#x2F; 圆与圆交点    vector&lt;Point&gt; inter(const Circle &amp;a) const    &#123;        const long double d&#x3D;c.dis(a.c);        const int t&#x3D;relation(a);        if (t&#x3D;&#x3D;-1 || t&#x3D;&#x3D;0 || t&#x3D;&#x3D;4) return vector&lt;Point&gt;();        Point e&#x3D;a.c-c; e&#x3D;e&#x2F;e.len()*r;        if (t&#x3D;&#x3D;1 || t&#x3D;&#x3D;3)         &#123;            if (r*r+d*d-a.r*a.r&gt;&#x3D;-eps) return vector&lt;Point&gt;&#123;c+e&#125;;            return vector&lt;Point&gt;&#123;c-e&#125;;        &#125;        const long double costh&#x3D;(r*r+d*d-a.r*a.r)&#x2F;(2*r*d),sinth&#x3D;sqrt(1-costh*costh);        return vector&lt;Point&gt;&#123;c+e.rot(costh,-sinth),c+e.rot(costh,sinth)&#125;;    &#125;    &#x2F;&#x2F; 圆与圆交面积    long double inter_area(const Circle &amp;a) const    &#123;        const long double d&#x3D;c.dis(a.c);        const int t&#x3D;relation(a);        if (t&#x3D;&#x3D;-1) return area();        if (t&lt;2) return 0;        if (t&gt;2) return min(area(),a.area());        const long double costh1&#x3D;(r*r+d*d-a.r*a.r)&#x2F;(2*r*d),costh2&#x3D;(a.r*a.r+d*d-r*r)&#x2F;(2*a.r*d);        const long double sinth1&#x3D;sqrt(1-costh1*costh1),sinth2&#x3D;sqrt(1-costh2*costh2);        const long double th1&#x3D;acos(costh1),th2&#x3D;acos(costh2);        return r*r*(th1-costh1*sinth1)+a.r*a.r*(th2-costh2*sinth2);    &#125;    &#x2F;&#x2F; 过圆外一点圆的切线    vector&lt;Line&gt; tangent(const Point &amp;a) const    &#123;        const int t&#x3D;is_in(a);        if (t&#x3D;&#x3D;1) return vector&lt;Line&gt;();        if (t&#x3D;&#x3D;-1)        &#123;            const Point v&#x3D;&#123;-(a-c).y,(a-c).x&#125;;            return vector&lt;Line&gt;&#123;&#123;a,v&#125;&#125;;        &#125;        Point e&#x3D;a-c; e&#x3D;e&#x2F;e.len()*r;        const long double costh&#x3D;r&#x2F;c.dis(a),sinth&#x3D;sqrt(1-costh*costh);        const Point t1&#x3D;c+e.rot(costh,-sinth),t2&#x3D;c+e.rot(costh,sinth);        return vector&lt;Line&gt;&#123;&#123;a,t1-a&#125;,&#123;a,t2-a&#125;&#125;;    &#125;    &#x2F;&#x2F; 两圆的公切线    vector&lt;Line&gt; tangent(const Circle &amp;a) const    &#123;        const int t&#x3D;relation(a);        vector&lt;Line&gt; lines;        if (t&#x3D;&#x3D;-1 || t&#x3D;&#x3D;4) return lines;        if (t&#x3D;&#x3D;1 || t&#x3D;&#x3D;3)        &#123;            const Point p&#x3D;inter(a)[0],v&#x3D;&#123;-(a.c-c).y,(a.c-c).x&#125;;            lines.push_back(&#123;p,v&#125;);        &#125;        const long double d&#x3D;c.dis(a.c);        const Point e&#x3D;(a.c-c)&#x2F;(a.c-c).len();        if (t&lt;&#x3D;2)        &#123;            const long double costh&#x3D;(r-a.r)&#x2F;d,sinth&#x3D;sqrt(1-costh*costh);            const Point d1&#x3D;e.rot(costh,-sinth),d2&#x3D;e.rot(costh,sinth);            const Point u1&#x3D;c+d1*r,u2&#x3D;c+d2*r,v1&#x3D;a.c+d1*a.r,v2&#x3D;a.c+d2*a.r;            lines.push_back(&#123;u1,v1-u1&#125;); lines.push_back(&#123;u2,v2-u2&#125;);        &#125;        if (t&#x3D;&#x3D;0)        &#123;            const long double costh&#x3D;(r+a.r)&#x2F;d,sinth&#x3D;sqrt(1-costh*costh);            const Point d1&#x3D;e.rot(costh,-sinth),d2&#x3D;e.rot(costh,sinth);            const Point u1&#x3D;c+d1*r,u2&#x3D;c+d2*r,v1&#x3D;a.c-d1*a.r,v2&#x3D;a.c-d2*a.r;            lines.push_back(&#123;u1,v1-u1&#125;); lines.push_back(&#123;u2,v2-u2&#125;);        &#125;        return lines;    &#125;    &#x2F;&#x2F; 圆的反演    tuple&lt;int,Circle,Line&gt; inverse(const Line &amp;l) const    &#123;        const Circle null_c&#x3D;&#123;&#123;0.0,0.0&#125;,0.0&#125;;        const Line null_l&#x3D;&#123;&#123;0.0,0.0&#125;,&#123;0.0,0.0&#125;&#125;;        if (l.toleft(c)&#x3D;&#x3D;0) return &#123;2,null_c,l&#125;;        const Point v&#x3D;l.toleft(c)&#x3D;&#x3D;1?Point&#123;l.v.y,-l.v.x&#125;:Point&#123;-l.v.y,l.v.x&#125;;        const long double d&#x3D;r*r&#x2F;l.dis(c);        const Point p&#x3D;c+v&#x2F;v.len()*d;        return &#123;1,&#123;(c+p)&#x2F;2,d&#x2F;2&#125;,null_l&#125;;    &#125;        tuple&lt;int,Circle,Line&gt; inverse(const Circle &amp;a) const    &#123;        const Circle null_c&#x3D;&#123;&#123;0.0,0.0&#125;,0.0&#125;;        const Line null_l&#x3D;&#123;&#123;0.0,0.0&#125;,&#123;0.0,0.0&#125;&#125;;        const Point v&#x3D;a.c-c;        if (a.is_in(c)&#x3D;&#x3D;-1)        &#123;            const long double d&#x3D;r*r&#x2F;(a.r+a.r);            const Point p&#x3D;c+v&#x2F;v.len()*d;            return &#123;2,null_c,&#123;p,&#123;-v.y,v.x&#125;&#125;&#125;;        &#125;        if (c&#x3D;&#x3D;a.c) return &#123;1,&#123;c,r*r&#x2F;a.r&#125;,null_l&#125;;        const long double d1&#x3D;r*r&#x2F;(c.dis(a.c)-a.r),d2&#x3D;r*r&#x2F;(c.dis(a.c)+a.r);        const Point p&#x3D;c+v&#x2F;v.len()*d1,q&#x3D;c+v&#x2F;v.len()*d2;        return &#123;1,&#123;(p+q)&#x2F;2,p.dis(q)&#x2F;2&#125;,null_l&#125;;    &#125;&#125;;&#x2F;&#x2F; 圆与多边形面积交long double area_inter(const Circle &amp;circ,const Polygon &amp;poly)&#123;    const auto cal&#x3D;[](const Circle &amp;circ,const Point &amp;a,const Point &amp;b)    &#123;        if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;0) return 0.0l;        const auto ina&#x3D;circ.is_in(a),inb&#x3D;circ.is_in(b);        const Line ab&#x3D;&#123;a,b-a&#125;;        if (ina &amp;&amp; inb) return ((a-circ.c)^(b-circ.c))&#x2F;2;        if (ina &amp;&amp; !inb)        &#123;            const auto t&#x3D;circ.inter(ab);            const Point p&#x3D;t.size()&#x3D;&#x3D;1?t[0]:t[1];            const long double ans&#x3D;((a-circ.c)^(p-circ.c))&#x2F;2;            const long double th&#x3D;(p-circ.c).ang(b-circ.c);            const long double d&#x3D;circ.r*circ.r*th&#x2F;2;            if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;1) return ans+d;            return ans-d;        &#125;        if (!ina &amp;&amp; inb)        &#123;            const Point p&#x3D;circ.inter(ab)[0];            const long double ans&#x3D;((p-circ.c)^(b-circ.c))&#x2F;2;            const long double th&#x3D;(a-circ.c).ang(p-circ.c);            const long double d&#x3D;circ.r*circ.r*th&#x2F;2;            if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;1) return ans+d;            return ans-d;        &#125;        const auto p&#x3D;circ.inter(ab);        if (p.size()&#x3D;&#x3D;2 &amp;&amp; Segment&#123;a,b&#125;.dis(circ.c)&lt;&#x3D;circ.r+eps)        &#123;            const long double ans&#x3D;((p[0]-circ.c)^(p[1]-circ.c))&#x2F;2;            const long double th1&#x3D;(a-circ.c).ang(p[0]-circ.c),th2&#x3D;(b-circ.c).ang(p[1]-circ.c);            const long double d1&#x3D;circ.r*circ.r*th1&#x2F;2,d2&#x3D;circ.r*circ.r*th2&#x2F;2;            if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;1) return ans+d1+d2;            return ans-d1-d2;        &#125;        const long double th&#x3D;(a-circ.c).ang(b-circ.c);        if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;1) return circ.r*circ.r*th&#x2F;2;        return -circ.r*circ.r*th&#x2F;2;    &#125;;    long double ans&#x3D;0;    for (size_t i&#x3D;0;i&lt;poly.p.size();i++)    &#123;        const Point a&#x3D;poly.p[i],b&#x3D;poly.p[poly.nxt(i)];        ans+&#x3D;cal(circ,a,b);    &#125;    return ans;&#125;&#x2F;&#x2F; 点集的凸包&#x2F;&#x2F; Andrew 算法，复杂度 O(nlogn)Convex convexhull(vector&lt;Point&gt; p)&#123;    vector&lt;Point&gt; st;    if (p.empty()) return Convex&#123;st&#125;;    sort(p.begin(),p.end());    const auto check&#x3D;[](const vector&lt;Point&gt; &amp;st,const Point &amp;u)    &#123;        const auto back1&#x3D;st.back(),back2&#x3D;*prev(st.end(),2);        return (back1-back2).toleft(u-back1)&lt;&#x3D;0;    &#125;;    for (const Point &amp;u:p)    &#123;        while (st.size()&gt;1 &amp;&amp; check(st,u)) st.pop_back();        st.push_back(u);    &#125;    size_t k&#x3D;st.size();    p.pop_back(); reverse(p.begin(),p.end());    for (const Point &amp;u:p)    &#123;        while (st.size()&gt;k &amp;&amp; check(st,u)) st.pop_back();        st.push_back(u);    &#125;    st.pop_back();    return Convex&#123;st&#125;;&#125;&#x2F;&#x2F; 半平面交&#x2F;&#x2F; 排序增量法，复杂度 O(nlogn)&#x2F;&#x2F; 输入与返回值都是用直线表示的半平面集合vector&lt;Line&gt; halfinter(vector&lt;Line&gt; l, const point_t lim&#x3D;1e9)&#123;    const auto check&#x3D;[](const Line &amp;a,const Line &amp;b,const Line &amp;c)&#123;return a.toleft(b.inter(c))&lt;0;&#125;;    &#x2F;&#x2F; 无精度误差的方法，但注意取值范围会扩大到三次方    &#x2F;*const auto check&#x3D;[](const Line &amp;a,const Line &amp;b,const Line &amp;c)    &#123;        const Point p&#x3D;a.v*(b.v^c.v),q&#x3D;b.p*(b.v^c.v)+b.v*(c.v^(b.p-c.p))-a.p*(b.v^c.v);        return p.toleft(q)&lt;0;    &#125;;*&#x2F;    l.push_back(&#123;&#123;-lim,0&#125;,&#123;0,-1&#125;&#125;); l.push_back(&#123;&#123;0,-lim&#125;,&#123;1,0&#125;&#125;);    l.push_back(&#123;&#123;lim,0&#125;,&#123;0,1&#125;&#125;); l.push_back(&#123;&#123;0,lim&#125;,&#123;-1,0&#125;&#125;);    sort(l.begin(),l.end());    deque&lt;Line&gt; q;    for (size_t i&#x3D;0;i&lt;l.size();i++)    &#123;        if (i&gt;0 &amp;&amp; l[i-1].v.toleft(l[i].v)&#x3D;&#x3D;0 &amp;&amp; l[i-1].v*l[i].v&gt;eps) continue;        while (q.size()&gt;1 &amp;&amp; check(l[i],q.back(),q[q.size()-2])) q.pop_back();        while (q.size()&gt;1 &amp;&amp; check(l[i],q[0],q[1])) q.pop_front();        if (!q.empty() &amp;&amp; q.back().v.toleft(l[i].v)&lt;&#x3D;0) return vector&lt;Line&gt;();        q.push_back(l[i]);    &#125;    while (q.size()&gt;1 &amp;&amp; check(q[0],q.back(),q[q.size()-2])) q.pop_back();    while (q.size()&gt;1 &amp;&amp; check(q.back(),q[0],q[1])) q.pop_front();    return vector&lt;Line&gt;(q.begin(),q.end());&#125;&#x2F;&#x2F; 点集形成的最小最大三角形&#x2F;&#x2F; 极角序扫描线，复杂度 O(n^2logn)&#x2F;&#x2F; 最大三角形问题可以使用凸包与旋转卡壳做到 O(n^2)pair&lt;point_t,point_t&gt; minmax_triangle(const vector&lt;Point&gt; &amp;vec)&#123;    if (vec.size()&lt;&#x3D;2) return &#123;0,0&#125;;    vector&lt;pair&lt;int,int&gt;&gt; evt;    evt.reserve(vec.size()*vec.size());    point_t maxans&#x3D;0,minans&#x3D;numeric_limits&lt;point_t&gt;::max();    for (size_t i&#x3D;0;i&lt;vec.size();i++)    &#123;        for (size_t j&#x3D;0;j&lt;vec.size();j++)        &#123;            if (i&#x3D;&#x3D;j) continue;            if (vec[i]&#x3D;&#x3D;vec[j]) minans&#x3D;0;            else evt.push_back(&#123;i,j&#125;);        &#125;    &#125;    sort(evt.begin(),evt.end(),[&amp;](const pair&lt;int,int&gt; &amp;u,const pair&lt;int,int&gt; &amp;v)    &#123;        const Point du&#x3D;vec[u.second]-vec[u.first],dv&#x3D;vec[v.second]-vec[v.first];        return argcmp()(&#123;du.y,-du.x&#125;,&#123;dv.y,-dv.x&#125;);    &#125;);    vector&lt;size_t&gt; vx(vec.size()),pos(vec.size());    for (size_t i&#x3D;0;i&lt;vec.size();i++) vx[i]&#x3D;i;    sort(vx.begin(),vx.end(),[&amp;](int x,int y)&#123;return vec[x]&lt;vec[y];&#125;);    for (size_t i&#x3D;0;i&lt;vx.size();i++) pos[vx[i]]&#x3D;i;    for (auto [u,v]:evt)    &#123;        const size_t i&#x3D;pos[u],j&#x3D;pos[v];        const size_t l&#x3D;min(i,j),r&#x3D;max(i,j);        const Point vecu&#x3D;vec[u],vecv&#x3D;vec[v];        if (l&gt;0) minans&#x3D;min(minans,abs((vec[vx[l-1]]-vecu)^(vec[vx[l-1]]-vecv)));        if (r&lt;vx.size()-1) minans&#x3D;min(minans,abs((vec[vx[r+1]]-vecu)^(vec[vx[r+1]]-vecv)));        maxans&#x3D;max(&#123;maxans,abs((vec[vx[0]]-vecu)^(vec[vx[0]]-vecv)),abs((vec[vx.back()]-vecu)^(vec[vx.back()]-vecv))&#125;);        if (i&lt;j) swap(vx[i],vx[j]),pos[u]&#x3D;j,pos[v]&#x3D;i;    &#125;    return &#123;minans,maxans&#125;;&#125;&#x2F;&#x2F; 判断多条线段是否有交点&#x2F;&#x2F; 扫描线，复杂度 O(nlogn)bool segs_inter(const vector&lt;Segment&gt; &amp;segs)&#123;    if (segs.empty()) return false;    using seq_t&#x3D;tuple&lt;point_t,int,Segment&gt;;    const auto seqcmp&#x3D;[](const seq_t &amp;u, const seq_t &amp;v)    &#123;        const auto [u0,u1,u2]&#x3D;u;        const auto [v0,v1,v2]&#x3D;v;        if (abs(u0-v0)&lt;&#x3D;eps) return make_pair(u1,u2)&lt;make_pair(v1,v2);        return u0&lt;v0-eps;    &#125;;    vector&lt;seq_t&gt; seq;    for (auto seg:segs)    &#123;        if (seg.a.x&gt;seg.b.x+eps) swap(seg.a,seg.b);        seq.push_back(&#123;seg.a.x,0,seg&#125;);        seq.push_back(&#123;seg.b.x,1,seg&#125;);    &#125;    sort(seq.begin(),seq.end(),seqcmp);    point_t x_now;    auto cmp&#x3D;[&amp;](const Segment &amp;u, const Segment &amp;v)    &#123;        if (abs(u.a.x-u.b.x)&lt;&#x3D;eps || abs(v.a.x-v.b.x)&lt;&#x3D;eps) return u.a.y&lt;v.a.y-eps;        return ((x_now-u.a.x)*(u.b.y-u.a.y)+u.a.y*(u.b.x-u.a.x))*(v.b.x-v.a.x)&lt;((x_now-v.a.x)*(v.b.y-v.a.y)+v.a.y*(v.b.x-v.a.x))*(u.b.x-u.a.x)-eps;    &#125;;    multiset&lt;Segment,decltype(cmp)&gt; s&#123;cmp&#125;;    for (const auto [x,o,seg]:seq)    &#123;        x_now&#x3D;x;        const auto it&#x3D;s.lower_bound(seg);        if (o&#x3D;&#x3D;0)        &#123;            if (it!&#x3D;s.end() &amp;&amp; seg.is_inter(*it)) return true;            if (it!&#x3D;s.begin() &amp;&amp; seg.is_inter(*prev(it))) return true;            s.insert(seg);        &#125;        else        &#123;            if (next(it)!&#x3D;s.end() &amp;&amp; it!&#x3D;s.begin() &amp;&amp; (*prev(it)).is_inter(*next(it))) return true;            s.erase(it);        &#125;    &#125;    return false;&#125;&#x2F;&#x2F; 多边形面积并&#x2F;&#x2F; 轮廓积分，复杂度 O(n^2logn)，n为边数&#x2F;&#x2F; ans[i] 表示被至少覆盖了 i+1 次的区域的面积vector&lt;long double&gt; area_union(const vector&lt;Polygon&gt; &amp;polys)&#123;    const size_t siz&#x3D;polys.size();    vector&lt;vector&lt;pair&lt;Point,Point&gt;&gt;&gt; segs(siz);    const auto check&#x3D;[](const Point &amp;u,const Segment &amp;e)&#123;return !((u&lt;e.a &amp;&amp; u&lt;e.b) || (u&gt;e.a &amp;&amp; u&gt;e.b));&#125;;    auto cut_edge&#x3D;[&amp;](const Segment &amp;e,const size_t i)    &#123;        const Line le&#123;e.a,e.b-e.a&#125;;        vector&lt;pair&lt;Point,int&gt;&gt; evt;        evt.push_back(&#123;e.a,0&#125;); evt.push_back(&#123;e.b,0&#125;);        for (size_t j&#x3D;0;j&lt;polys.size();j++)        &#123;            if (i&#x3D;&#x3D;j) continue;            const auto &amp;pj&#x3D;polys[j];            for (size_t k&#x3D;0;k&lt;pj.p.size();k++)            &#123;                const Segment s&#x3D;&#123;pj.p[k],pj.p[pj.nxt(k)]&#125;;                if (le.toleft(s.a)&#x3D;&#x3D;0 &amp;&amp; le.toleft(s.b)&#x3D;&#x3D;0)                &#123;                    evt.push_back(&#123;s.a,0&#125;);                    evt.push_back(&#123;s.b,0&#125;);                &#125;                else if (s.is_inter(le))                &#123;                    const Line ls&#123;s.a,s.b-s.a&#125;;                    const Point u&#x3D;le.inter(ls);                    if (le.toleft(s.a)&lt;0 &amp;&amp; le.toleft(s.b)&gt;&#x3D;0) evt.push_back(&#123;u,-1&#125;);                    else if (le.toleft(s.a)&gt;&#x3D;0 &amp;&amp; le.toleft(s.b)&lt;0) evt.push_back(&#123;u,1&#125;);                &#125;            &#125;        &#125;        sort(evt.begin(),evt.end());        if (e.a&gt;e.b) reverse(evt.begin(),evt.end());        int sum&#x3D;0;        for (size_t i&#x3D;0;i&lt;evt.size();i++)        &#123;            sum+&#x3D;evt[i].second;            const Point u&#x3D;evt[i].first,v&#x3D;evt[i+1].first;            if (!(u&#x3D;&#x3D;v) &amp;&amp; check(u,e) &amp;&amp; check(v,e)) segs[sum].push_back(&#123;u,v&#125;);            if (v&#x3D;&#x3D;e.b) break;        &#125;    &#125;;        for (size_t i&#x3D;0;i&lt;polys.size();i++)    &#123;        const auto &amp;pi&#x3D;polys[i];        for (size_t k&#x3D;0;k&lt;pi.p.size();k++)        &#123;            const Segment ei&#x3D;&#123;pi.p[k],pi.p[pi.nxt(k)]&#125;;            cut_edge(ei,i);        &#125;    &#125;    vector&lt;long double&gt; ans(siz);    for (size_t i&#x3D;0;i&lt;siz;i++)    &#123;        long double sum&#x3D;0;        sort(segs[i].begin(),segs[i].end());        int cnt&#x3D;0;        for (size_t j&#x3D;0;j&lt;segs[i].size();j++)        &#123;            if (j&gt;0 &amp;&amp; segs[i][j]&#x3D;&#x3D;segs[i][j-1]) segs[i+(++cnt)].push_back(segs[i][j]);            else cnt&#x3D;0,sum+&#x3D;segs[i][j].first^segs[i][j].second;        &#125;        ans[i]&#x3D;sum&#x2F;2;    &#125;    return ans;&#125;&#x2F;&#x2F; 圆面积并&#x2F;&#x2F; 轮廓积分，复杂度 O(n^2logn)&#x2F;&#x2F; ans[i] 表示被至少覆盖了 i+1 次的区域的面积vector&lt;long double&gt; area_union(const vector&lt;Circle&gt; &amp;circs)&#123;    const size_t siz&#x3D;circs.size();    using arc_t&#x3D;tuple&lt;Point,long double,long double,long double&gt;;    vector&lt;vector&lt;arc_t&gt;&gt; arcs(siz);    const auto eq&#x3D;[](const arc_t &amp;u,const arc_t &amp;v)    &#123;        const auto [u1,u2,u3,u4]&#x3D;u;        const auto [v1,v2,v3,v4]&#x3D;v;        return u1&#x3D;&#x3D;v1 &amp;&amp; abs(u2-v2)&lt;&#x3D;eps &amp;&amp; abs(u3-v3)&lt;&#x3D;eps &amp;&amp; abs(u4-v4)&lt;&#x3D;eps;    &#125;;    auto cut_circ&#x3D;[&amp;](const Circle &amp;ci,const size_t i)    &#123;        vector&lt;pair&lt;long double,int&gt;&gt; evt;        evt.push_back(&#123;-PI,0&#125;); evt.push_back(&#123;PI,0&#125;);        int init&#x3D;0;        for (size_t j&#x3D;0;j&lt;circs.size();j++)        &#123;            if (i&#x3D;&#x3D;j) continue;            const Circle &amp;cj&#x3D;circs[j];            if (ci.r&lt;cj.r-eps &amp;&amp; ci.relation(cj)&gt;&#x3D;3) init++;            const auto inters&#x3D;ci.inter(cj);            if (inters.size()&#x3D;&#x3D;1) evt.push_back(&#123;atan2l((inters[0]-ci.c).y,(inters[0]-ci.c).x),0&#125;);            if (inters.size()&#x3D;&#x3D;2)            &#123;                const Point dl&#x3D;inters[0]-ci.c,dr&#x3D;inters[1]-ci.c;                long double argl&#x3D;atan2l(dl.y,dl.x),argr&#x3D;atan2l(dr.y,dr.x);                if (abs(argl+PI)&lt;&#x3D;eps) argl&#x3D;PI;                if (abs(argr+PI)&lt;&#x3D;eps) argr&#x3D;PI;                if (argl&gt;argr+eps)                &#123;                    evt.push_back(&#123;argl,1&#125;); evt.push_back(&#123;PI,-1&#125;);                    evt.push_back(&#123;-PI,1&#125;); evt.push_back(&#123;argr,-1&#125;);                &#125;                else                &#123;                    evt.push_back(&#123;argl,1&#125;);                    evt.push_back(&#123;argr,-1&#125;);                &#125;            &#125;        &#125;        sort(evt.begin(),evt.end());        int sum&#x3D;init;        for (size_t i&#x3D;0;i&lt;evt.size();i++)        &#123;            sum+&#x3D;evt[i].second;            if (abs(evt[i].first-evt[i+1].first)&gt;eps) arcs[sum].push_back(&#123;ci.c,ci.r,evt[i].first,evt[i+1].first&#125;);            if (abs(evt[i+1].first-PI)&lt;&#x3D;eps) break;        &#125;    &#125;;    const auto oint&#x3D;[](const arc_t &amp;arc)    &#123;        const auto [cc,cr,l,r]&#x3D;arc;        if (abs(r-l-PI-PI)&lt;&#x3D;eps) return 2.0l*PI*cr*cr;        return cr*cr*(r-l)+cc.x*cr*(sin(r)-sin(l))-cc.y*cr*(cos(r)-cos(l));    &#125;;    for (size_t i&#x3D;0;i&lt;circs.size();i++)    &#123;        const auto &amp;ci&#x3D;circs[i];        cut_circ(ci,i);    &#125;    vector&lt;long double&gt; ans(siz);    for (size_t i&#x3D;0;i&lt;siz;i++)    &#123;        long double sum&#x3D;0;        sort(arcs[i].begin(),arcs[i].end());        int cnt&#x3D;0;        for (size_t j&#x3D;0;j&lt;arcs[i].size();j++)        &#123;            if (j&gt;0 &amp;&amp; eq(arcs[i][j],arcs[i][j-1])) arcs[i+(++cnt)].push_back(arcs[i][j]);            else cnt&#x3D;0,sum+&#x3D;oint(arcs[i][j]);        &#125;        ans[i]&#x3D;sum&#x2F;2;    &#125;    return ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>abc274.md</title>
      <link href="/2022/10/25/abc274-md/"/>
      <url>/2022/10/25/abc274-md/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-Beginner-Contest-274-C-E"><a href="#Atcoder-Beginner-Contest-274-C-E" class="headerlink" title="Atcoder Beginner Contest 274 ( C - E )"></a>Atcoder Beginner Contest 274 ( C - E )</h1><h2 id="C-Ameba"><a href="#C-Ameba" class="headerlink" title="C - Ameba"></a>C - Ameba</h2><p><strong>题目大意:</strong> 刚开始有一个生物序号为$1$，有$n$次记录，在第$i$次记录中第$a_i$个生物消失会生成第$2i$和$2i+1$个生物，问对于生物从$1$到$2N+1$他们距离$1$有多少代</p><p><strong>解题思路:</strong> 按照题意模拟即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int to1 &#x3D; i * 2;int to2 &#x3D; i * 2 + 1;dis[to1] &#x3D; dis[to2] &#x3D; dis[a[i]] + 1;&#125;for(int i &#x3D; 1;i &lt;&#x3D; 2 * n + 1;++i)&#123;cout &lt;&lt; dis[i] &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Robot-Arms-2"><a href="#D-Robot-Arms-2" class="headerlink" title="D - Robot Arms 2"></a>D - Robot Arms 2</h2><p><strong>题目大意:</strong> 给定一个长度为$n$的序列以及$x,y$,问是否存在$n + 1$个点$p_1,p_2,…,p_n,p_{n + 1}$在二维坐标系中满足$p_1 &#x3D; (0,0),p_2 &#x3D; (a_1,0),p_{n + 1} &#x3D; (x,y)$相邻两个点距离是$a_i$并且是$90$度</p><p><strong>解题思路:</strong> 分析后发现实际上$x$和$y$是相互不干扰的，那么我们可以分开来处理，注意到$a$的范围很小那么我们可以枚举遍历到的数值是多少</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 4e5 + 10;int n,x,y;int a[maxn],dis[maxn];int dp[2][maxn],pre[2][maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];int midp &#x3D; 10000;pre[1][midp + a[1]] &#x3D; 1;pre[0][midp] &#x3D; 1;for(int i &#x3D; 2;i &lt;&#x3D; n;++i)&#123;int now &#x3D; i &amp; 1;for(int j &#x3D; 0;j &lt;&#x3D; 20000;++j)&#123;if(pre[now][j])&#123;dp[now][j + a[i]] &#x3D; 1;if(j - a[i] &gt;&#x3D; 0) dp[now][j - a[i]] &#x3D; 1;&#x2F;&#x2F; cout &lt;&lt; &quot;?? now-&gt; &quot; &lt;&lt; now &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;&#125;&#125;for(int j &#x3D; 0;j &lt;&#x3D; 20000;++j) pre[now][j] &#x3D; dp[now][j],dp[now][j] &#x3D; 0;&#125;if(pre[1][midp + x] &amp;&amp; pre[0][midp + y]) cout &lt;&lt; &quot;Yes\n&quot;;else cout &lt;&lt; &quot;No\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Booster"><a href="#E-Booster" class="headerlink" title="E - Booster"></a>E - Booster</h2><p><strong>题目大意:</strong> 给定一个二维平面其中有$n$个城镇和$m$个加速点$(1 \leq n + m \leq 17)$，初始点在$(0,0)$，问必须经理过所有城镇点需要的时间最短是多少，没必要经过所有加速点但是我们每经过一次加速点我们当前的速度就会翻倍</p><p><strong>解题思路:</strong> 看到题目数据的时候我们就会自然而然的考虑到状态压缩，如何存在当前的状态呢？我们可以用$dp[i][j]$来表示$i$的二进制位状态表示经过了哪些点，然后末尾点是$j$</p><p>那么我们思考转移的过程，假设我们当前位置$j$存在$1$,并且当前$k$也是$1$</p><p>那么我们可以从$k$点转移到$j$点，那么相对应的方程就是$dp[i][j] &#x3D; min(dp[i][j],dp[i - (1 &lt;&lt; j)][k] + d &#x2F; v)$</p><p>然后我们可以在最后枚举从哪个点最后来以及最后的状态获得答案</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;double dp[1 &lt;&lt; 18][20];pair&lt;double,double&gt; p[20];double getdis(int i,int j)&#123;return sqrt((p[i].first - p[j].first) * (p[i].first - p[j].first) + (p[i].second - p[j].second) * (p[i].second - p[j].second));&#125;int n,m;int countx(int x)&#123;int now &#x3D; 0;for(int i &#x3D; n;i &lt; n + m;++i)&#123;if(x &gt;&gt; i &amp; 1) now++;&#125;return now;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;p[0] &#x3D; &#123;0,0&#125;;n++;for(int i &#x3D; 1;i &lt; n + m;++i)&#123;cin &gt;&gt; p[i].first &gt;&gt; p[i].second;&#125;for(int i &#x3D; 0;i &lt; (1 &lt;&lt; (n + m));++i)&#123;for(int j &#x3D; 0;j &lt; n + m;++j) dp[i][j] &#x3D; 1e18;&#125;dp[1][0] &#x3D; 0;cout &lt;&lt; fixed &lt;&lt; setprecision(10);for(int i &#x3D; 0;i &lt; (1 &lt;&lt; (n + m));++i)&#123;for(int j &#x3D; 0;j &lt; (n + m);++j)&#123;if(i &gt;&gt; j &amp; 1)&#123;for(int k &#x3D; 0;k &lt; (n + m);++k)&#123;if((i - (1 &lt;&lt; j)) &gt;&gt; k &amp; 1)&#123;double d &#x3D; getdis(j,k);int nowcnt &#x3D; countx(i - (1 &lt;&lt; j));int v &#x3D; (1 &lt;&lt; nowcnt);dp[i][j] &#x3D; min(dp[i][j],dp[i - (1 &lt;&lt; j)][k] + d &#x2F; (1.0 * v));&#125;&#125;&#125;&#125;&#125;double ans &#x3D; 1e18;for(int i &#x3D; (1 &lt;&lt; n) - 1;i &lt; (1 &lt;&lt; (n + m));i +&#x3D; (1 &lt;&lt; n))&#123;for(int j &#x3D; 0;j &lt; n + m;++j)&#123;double d &#x3D; getdis(0,j);int v &#x3D; 1 &lt;&lt; countx(i);ans &#x3D; min(ans,dp[i][j] + d &#x2F; (1.0 * v));&#125;&#125;cout &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> abc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 825 A-C1 D</title>
      <link href="/2022/10/11/cf825/"/>
      <url>/2022/10/11/cf825/</url>
      
        <content type="html"><![CDATA[<h1 id="Codeforces-Round-825-Div-2-A-C1-D"><a href="#Codeforces-Round-825-Div-2-A-C1-D" class="headerlink" title="Codeforces Round #825 (Div. 2) A-C1 D"></a>Codeforces Round #825 (Div. 2) A-C1 D</h1><h2 id="A-Make-A-Equal-to-B"><a href="#A-Make-A-Equal-to-B" class="headerlink" title="A. Make A Equal to B"></a>A. Make A Equal to B</h2><p><strong>题目大意:</strong>  给定两个$01$序列$a$,$b$长度为$n(1\leq n\leq 1e2)$，现在有两种操作，第一种操作是选择一个位置进行反转，第二个操作是任意排序$a$序列，问最少需要几次操作能让序列$a$等于序列$b$</p><p><strong>解题思路:</strong> 首先我们先思考一下，我们刚开始一定要让序列$a$和$b$中的$01$个数相同，然后在这个前提下，如果两个序列在增加$1$的过程中相同了，就不进行二操作，否则就进行二操作。如何判断两个序列是否在过程中就相同了呢？我们可以考虑将序列中的$0$变成$1$，然后看哪个序列中原本的$1$多，如果$b$中多就变$a$，$a$中多实际上就是变$b$</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;int na,nb;na &#x3D; nb &#x3D; 0;cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];if(a[i]) na++;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; b[i];if(b[i]) nb++;&#125;int f &#x3D; 1;int ck &#x3D; 0;if(na &gt; nb) ck &#x3D; 1;if(na &lt; nb)&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(!a[i]) continue;if(a[i] !&#x3D; b[i]) f &#x3D; 0;&#125;&#125;else&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(!b[i]) continue;if(a[i] !&#x3D; b[i]) f &#x3D; 0;&#125;&#125;cout &lt;&lt; abs(na - nb) + (1 - f) &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Playing-with-GCD"><a href="#B-Playing-with-GCD" class="headerlink" title="B. Playing with GCD"></a>B. Playing with GCD</h2><p><strong>题目大意:</strong> 给定一个长度为$n(1\leq n \leq 2e5)$的序列，问是否存在一个长度为$n + 1$的序列$b$，满足$a_i &#x3D; gcd(b_i,b_{i + 1})$</p><p><strong>解题思路:</strong> 观察样例可得我们可以对原序列中的$a_{i - 1}$,$a_i$和$a_{i + 1}$进行分析，这三个数字分别由$b_{i - 1}$,$b_i$,$b_{i + 1}$,$b_{i + 2}$</p><p>考虑$b_i$和$b_{i + 1}$实际上还在$a_{i - 1}$和$a_{i + 1}$中，我们考虑$gcd$的性质实际上是去求若干个数字的质因子取$min$</p><p>那么我们可以对$a_{i- 1}$和$a_{i + 1}$取$gcd$，如果$a_i$不能和他们的$gcd$取余获得$0$的话，那么实际上就是不可以的，说明还有其他的质因子存在</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];int f &#x3D; 1;for(int i &#x3D; 2;i &lt;&#x3D; n - 1;++i)&#123;int gd &#x3D; __gcd(a[i - 1],a[i + 1]);if(a[i] % gd) f &#x3D; 0;&#125;if(f) cout &lt;&lt; &quot;YES\n&quot;;else cout &lt;&lt; &quot;NO\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C1-Good-Subarrays-Easy-Version"><a href="#C1-Good-Subarrays-Easy-Version" class="headerlink" title="C1. Good Subarrays (Easy Version)"></a>C1. Good Subarrays (Easy Version)</h2><p><strong>题目大意:</strong> 给定一个长度为$n(1\leq n \leq 2e5)$的序列，找出这个序列中有多少个序列满足好序列，好序列的要求是对于一段序列第$i$个元素大于等于$i$</p><p><strong>解题思路:</strong> 固定左端点取计算右端点在哪里。我们可以发现这样一件事情，如果我在当前这个位置$i$右端点到达$j$,那么我到$i + 1$的话，我可以继续从$j$往右边移动，满足双指针的性质，直接写就可以。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];int ans &#x3D; 0;int j &#x3D; 1;int now &#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(j &lt; i)&#123;j &#x3D; i;now &#x3D; 1;&#125;while(a[j] &gt;&#x3D; now &amp;&amp; j &lt;&#x3D; n)&#123;&#x2F;&#x2F; cout &lt;&lt; &quot;i -&gt; &quot;&lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; now&lt;&lt; &quot;\n&quot;;j++;now++;&#125;j--,now--;int num &#x3D; j - i + 1;ans +&#x3D; num;now--;&#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Equal-Binary-Subsequences"><a href="#D-Equal-Binary-Subsequences" class="headerlink" title="D. Equal Binary Subsequences"></a>D. Equal Binary Subsequences</h2><p><strong>题目大意:</strong> 给定一个长度为$2n(1\leq n \leq 1e5)$的$01$串，可以进行以下的操作一次，选择一个子序列，并且把这个子序列中的数字往前移动一个，如果是第一个就移动到最后一个，问是否能够将这个$01$串分割成两个子序列，使得这两个子序列相同</p><p><strong>解题思路:</strong> 首先我们先考虑无法构成的情况，如果$0$的个数或者$1$的个数是奇数，那么这个序列肯定就无法构成</p><p>做一个大胆的猜想，假设目前剩下的情况下所有情况都是有解的，那么剩下的串可能是由若干个$00$ $01$ $10$ $11$组成的</p><p>我们从前往后对于一个子序列来说$00$和$11$肯定是可以直接放进去的，那么对于$01$和$10$呢？</p><p>我们可以考虑把他们放到操作里面去变换，那么实际上我们只需要把奇数位置上面的$1$放到偶数位置上去，把偶数位置上面的$1$放到奇数位置上去</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;cin &gt;&gt; str;str &#x3D; &quot; &quot; + str;int num &#x3D; 0;n &lt;&lt;&#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;num +&#x3D; (str[i] &#x3D;&#x3D; &#39;1&#39;);&#125;if(num &amp; 1)&#123;cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;continue;&#125;vector&lt;int&gt; pos;for(int i &#x3D; 1;i &lt;&#x3D; n;i +&#x3D; 2)&#123;if(str[i] &#x3D;&#x3D; str[i + 1]) continue;pos.push_back(i);&#125;vector&lt;int&gt; ans;for(int i &#x3D; 0;i &lt; pos.size();++i)&#123;int now &#x3D; pos[i];if((i &amp; 1) &#x3D;&#x3D; str[now] - &#39;0&#39;)&#123;ans.push_back(now);&#125;else ans.push_back(now + 1);&#125;cout &lt;&lt; ans.size() &lt;&lt; &quot;\n&quot;;for(auto to:ans)&#123;cout &lt;&lt; to &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;i +&#x3D; 2) cout &lt;&lt; i &lt;&lt; &quot; \n&quot;[i &#x3D;&#x3D; n - 1];&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> cf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DailyTraing</title>
      <link href="/2022/10/09/DailyTraing/"/>
      <url>/2022/10/09/DailyTraing/</url>
      
        <content type="html"><![CDATA[<h1 id="每日思维题"><a href="#每日思维题" class="headerlink" title="每日思维题"></a>每日思维题</h1><h2 id="Graph-and-String"><a href="#Graph-and-String" class="headerlink" title="Graph and String"></a>Graph and String</h2><p><a href="https://codeforces.com/contest/623/problem/A">Problem - A - Codeforces</a></p><p>题目大意：</p><p>给出一个由字符串s<em>s</em>建图的过程。</p><ul><li>字符仅有$a,b,c$三种，建出的图中第$i$个顶点表示原来的第$i$个字符。</li><li>$i$与$j$有连边，当且仅当$s[i]$与$s[j]$相同或$s[i]$和$s[j]$是相邻的字符（$a$与$b$相邻，$b$与$c$相邻）</li></ul><p>现给出由某个字符串$s$建出的图，构造一个字符串使其符合上面的要求要求，或者回答不存在这样的字符串。</p><p>解题思路：首先分析题目可以发现这样一件事情，对于出现的$b$来说他是需要连接所有点的，$a$只需要连接相邻的$a$以及$b$即可，$c$的话和$a$同理，那么其实这样子的话我们可以在刚开始的时候处理以下所有和其他点连接的点，赋值为$b$，然后我们可以考虑一件事情，对于$a$和$c$来说相对应的边是不相连的，那么对于原图的补图来说一定是一张二分图，然后我们可以判断二分图并且染色之后再去根据颜色判断，如果两个相邻的边是$a$以及$c$那么就是不行的</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 5e2 + 10;int mp[maxn][maxn],n,m;int deg[maxn],col[maxn];char ans[maxn];vector&lt;int&gt; edge[maxn];int flag &#x3D; 1;void dfs(int s,int fa)&#123;for(auto to:edge[s])&#123;if(to &#x3D;&#x3D; fa) continue;if(col[to] &#x3D;&#x3D; -1)&#123;col[to] &#x3D; col[s] ^ 1;dfs(to,s);&#125;else if(col[to] &#x3D;&#x3D; col[s]) flag &#x3D; 0;&#125;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) mp[i][i] &#x3D; 1,col[i] &#x3D; -1;for(int i &#x3D; 1,u,v;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v;mp[u][v] &#x3D; mp[v][u] &#x3D; 1;deg[u]++;deg[v]++;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(mp[i][j]) continue;edge[i].emplace_back(j);edge[j].emplace_back(i);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(deg[i] &#x3D;&#x3D; n - 1) ans[i] &#x3D; &#39;b&#39;;else&#123;if(col[i] &#x3D;&#x3D; -1) col[i] &#x3D; 0,dfs(i,0);&#125;&#125;if(!flag)&#123;cout &lt;&lt; &quot;No\n&quot;;return 0;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(mp[i][j] &amp;&amp; col[i] + col[j] &#x3D;&#x3D; 1)&#123;cout &lt;&lt; &quot;No\n&quot;;return 0;&#125;&#125;&#125;cout &lt;&lt; &quot;Yes\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(deg[i] &#x3D;&#x3D; n - 1)&#123;cout &lt;&lt; &quot;b&quot;;&#125;else if(col[i] &#x3D;&#x3D; 0) cout &lt;&lt; &quot;a&quot;;else cout &lt;&lt; &quot;c&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Carousel"><a href="#Carousel" class="headerlink" title="Carousel"></a>Carousel</h2><p><a href="https://www.luogu.com.cn/problem/CF1328D">CF1328D Carousel - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a> </p><p><strong>题目大意:</strong> 有$q$组询问,每组询问如下:</p><p>已知一个有$n(3\le n\le 2<em>10^5)$个点的*<em>环</em></em>,点$i$的类型为$a_i$,现在需要给每个点进行染色,要求<strong>相邻</strong>不同类型的点的颜色不同且所用颜色数最小.输出颜色数及一种染色方案即可.(颜色从1开始)</p><p>注意: $n ≤2*10^5$</p><p><strong>解题思路:</strong></p><p>其实很容易想到环的颜色种类不多，至多只有$3$</p><p>那么我们可以进行这样子的讨论，首先我们可以把这个环分成奇环和偶环，对于偶环来说他有比较好的性质我们直接赋值$1$ $2$交替即可</p><p>那奇环呢？分析样例我们可以得出对于两两之间不一样的都是$3$种，反之就是$2$种</p><p>同时我们需要特判以下情况，在这个序列中只存在$1$种或者$2$种数字的情况</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 2e5 + 10;int a[maxn],num[maxn],n;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;int cnt &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];num[a[i]]++;if(num[a[i]] &#x3D;&#x3D; 1) cnt++;&#125;if(cnt &#x3D;&#x3D; 1)&#123;cout &lt;&lt; &quot;1\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cout &lt;&lt; &quot;1 &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;else if(cnt &#x3D;&#x3D; 2)&#123;cout &lt;&lt; 2 &lt;&lt; &quot;\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(a[i] &#x3D;&#x3D; a[1]) cout &lt;&lt; &quot;1 &quot;;else cout &lt;&lt; &quot;2 &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;else if(n % 2 &#x3D;&#x3D; 0)&#123;cout &lt;&lt; 2 &lt;&lt; &quot;\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cout &lt;&lt; (i &amp; 1)  + 1&lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;else&#123;int flag &#x3D; -1;for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;if(a[i] &#x3D;&#x3D; a[i + 1]) flag &#x3D; i;&#125;if(a[n] &#x3D;&#x3D; a[1]) flag &#x3D; n;if(flag &#x3D;&#x3D; -1)&#123;cout &lt;&lt; &quot;3\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;cout &lt;&lt; (i &amp; 1) + 1 &lt;&lt; &quot; &quot;; &#125;cout &lt;&lt; &quot;3\n&quot;;&#125;else&#123;cout &lt;&lt; &quot;2\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; flag;++i)&#123;if(i % 2) cout &lt;&lt; 1 &lt;&lt; &quot; &quot;;else cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;&#125;for(int i &#x3D; flag + 1;i &lt;&#x3D; n;++i)&#123;if(i % 2) cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;else cout &lt;&lt; 1 &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) num[a[i]] &#x3D; 0;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="What-a-Colorful-Wall"><a href="#What-a-Colorful-Wall" class="headerlink" title="What a Colorful Wall"></a>What a Colorful Wall</h2><p><a href="https://codeforces.com/group/MKpYqfAQQQ/contest/393177/problem/F">Problem - F - Codeforces</a></p><p><strong>题目大意:</strong> 给定$n$个矩形，每个矩形有一定的颜色，矩形之间可以相互覆盖，问在$n$个矩形覆盖之后整个坐标系中最多存在着多少种颜色</p><p><strong>解题思路:</strong> 首先先思考这样子的一件事情，因为矩形具有覆盖性，因此我们可以从后往前去放置矩形，因为后面的矩形总是不会被前面的矩形所覆盖，首先对于相同的$x$坐标的一个区域来说，如果一个矩形的高度小于另外一个的高度并且它的，那么它在这个$x$轴影响的$y$上面是被覆盖的，那么对于其他的$x$呢？我们可以利用一个类似于扫描线的做法，遍历相对应的$x$轴遍历过去即可，然后用并查集维护相对应的$y$是否已经是在同一条线上面</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 4e3 + 10;int fa[maxn * 2],n,ans[maxn];vector&lt;int&gt; posx,posy;vector&lt;array&lt;int,5&gt;&gt; pos;void init()&#123;for(int i &#x3D; 0;i &lt;&#x3D; 8010;++i) fa[i] &#x3D; i;&#125;int getf(int x)&#123;if(x &#x3D;&#x3D; fa[x]) return x;fa[x] &#x3D; getf(fa[x]);return fa[x];&#125;void merge(int x,int y)&#123;x &#x3D; getf(x);y &#x3D; getf(y);fa[x] &#x3D; y;&#125;int getx(int x)&#123;int px &#x3D; lower_bound(posx.begin(),posx.end(),x) - posx.begin();return px;&#125;int gety(int y)&#123;int py &#x3D; lower_bound(posy.begin(),posy.end(),y) - posy.begin();return py;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1,x1,y1,x2,y2,col;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; col;posx.push_back(x1),posx.push_back(x2);posy.push_back(y1),posy.push_back(y2);pos.push_back(&#123;x1,y1,x2,y2,col&#125;);&#125;sort(posx.begin(),posx.end());sort(posy.begin(),posy.end());posx.erase(unique(posx.begin(),posx.end()),posx.end());posy.erase(unique(posy.begin(),posy.end()),posy.end());for(auto &amp;now:pos)&#123;now[0] &#x3D; getx(now[0]),now[2] &#x3D; getx(now[2]);now[1] &#x3D; gety(now[1]),now[3] &#x3D; gety(now[3]); &#x2F;&#x2F; cout &lt;&lt; now[0] &lt;&lt; &quot; &quot;&#125;int tot &#x3D; posx.size();for(int i &#x3D; 0;i &lt;&#x3D; tot;++i)&#123;init();for(int j &#x3D; n - 1;j &gt;&#x3D; 0;--j)&#123;auto now &#x3D; pos[j];if(now[0] &lt;&#x3D; i &amp;&amp; now[2] &gt; i)&#123;int ny &#x3D; getf(now[1]);while(ny &gt; now[3])&#123;merge(ny,ny - 1);ans[now[4]] &#x3D; 1;ny &#x3D; getf(ny);&#125;&#125;&#125;&#125;int res &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) res +&#x3D; ans[i];cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Chemical-table"><a href="#Chemical-table" class="headerlink" title="Chemical table"></a>Chemical table</h2><p><a href="https://codeforces.com/contest/1013/problem/D">Problem - D - Codeforces</a></p><p><strong>题意:</strong> 给定一个$n * m$的棋盘，给定$q$个元素，这些元素在棋盘的上面，如果对于一个$2 * 2$的矩形来说，这个矩形中的三个值都存在但是还有一个值不存在，那么这个值也会自动生成，问最多要加多少个值才能使得这个棋盘最后是满的</p><p><strong>解题思路:</strong> 首先我们先分析最后的棋盘的状态，最后棋盘的状态是一个满的形式，对于棋盘来说我们可以把它看成一个二分图的形式，左边是列右边是行，然后我们去分析最终态，最终态是行和列的点都在一个连通块中；然后我们分析题目给定的条件，每次对于一个行和列连边，然后对于生成那个新点来说，实际上并不会影响当前连通块的情况，那么我们只需要连接所有的边，然后找出连通块的数量是多少，最后再加上相对应的边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 4e5 + 10;int f[maxn],n,m,q;int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y)&#123;x &#x3D; getf(x);y &#x3D; getf(y);f[x] &#x3D; y;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;for(int i &#x3D; 1;i &lt;&#x3D; n + m;++i)&#123;f[i] &#x3D; i;&#125;for(int i &#x3D; 1,x,y;i &lt;&#x3D; q;++i)&#123;cin &gt;&gt; x &gt;&gt; y;merge(x,y + n);&#125;int ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n + m;++i)&#123;if(getf(i) &#x3D;&#x3D; i)&#123;ans++;&#125;&#125;cout &lt;&lt; ans - 1 &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Cross-Swapping"><a href="#Cross-Swapping" class="headerlink" title="Cross Swapping"></a>Cross Swapping</h2><p><a href="https://codeforces.com/contest/1713/problem/E">Problem - E - Codeforces</a></p><p><strong>题意:</strong> 给定一个$n * n$的矩阵，可以选定一个$k$，交换所有的$mp[i][k]$和$mp[k][i]$，可以进行这样子的操作若干次，问在进行操作<br>之后这个矩阵字典序最小是什么样子的<br><strong>解题思路:</strong> 模拟每一次交换的过程，我们发现实际上$mp[i][j]$只会和$mp[j][i]$交换，既然这样那么实际上我们就很好去操作了<br>如果我们要交换$mp[i][j]$和$mp[j][i]$，我们只需要选定$k &#x3D; i$ $or$ $k &#x3D; j$,如果不交换我们可以两个都不选或者两个都选偶数次<br>然后的话我们可以用并查集来维护相对应的关系，用类似于敌人朋友的并查集来维护这个东西。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 2e3 + 10;int mp[maxn][maxn],n;int f[maxn];int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void merge(int x,int y)&#123;x &#x3D; getf(x);y &#x3D; getf(y);f[x] &#x3D; y;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;cin &gt;&gt; mp[i][j];&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; 2 * n;++i) f[i] &#x3D; i;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i;j &lt;&#x3D; n;++j)&#123;if(mp[i][j] &lt; mp[j][i])&#123;&#x2F;&#x2F;not changeif(getf(i) &#x3D;&#x3D; getf(j + n)) continue;merge(i,j),merge(i + n,j + n);&#125;else if(mp[i][j] &gt; mp[j][i])&#123;&#x2F;&#x2F;changeif(getf(i) &#x3D;&#x3D; getf(j)) continue;merge(i,j + n),merge(i + n,j);&#125;&#125;&#125;for(int k &#x3D; 1;k &lt;&#x3D; n;++k)&#123;if(getf(k) &gt; n) continue;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;swap(mp[i][k],mp[k][i]);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;cout &lt;&lt; mp[i][j] &lt;&lt; &quot; \n&quot;[j &#x3D;&#x3D; n];&#125;&#125;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Mikasa"><a href="#Mikasa" class="headerlink" title="Mikasa"></a>Mikasa</h2><p><a href="https://codeforces.com/contest/1554/problem/C">Problem - C - Codeforces</a></p><p><strong>题意:</strong> 给定$T$组数据，每组数据有一个$n$和$m$,给定一个序列从$n \bigoplus 0,n \bigoplus 1,…,n \bigoplus m$问这个序列中没有出现过的最小数字是多少</p><p><strong>解题思路:</strong> 考虑再这个序列中出现过的数字$k$,那么存在$x$使得式子$n \bigoplus x &#x3D; k,x ∈ [0,m]$成立,那么对于上面的式子其实可以等价于$n \bigoplus k &#x3D; x, 0 \leq n \bigoplus k \leq m$，那么我们要求的答案也就是去找一个最小的$k$使得$n \bigoplus k \geq m + 1$，那么这样子的话我们就可以进行按位考虑，假设$p &#x3D; m + 1$,我们从高位开始考虑，如果这个位置上面$n_i &#x3D; 1,p_i &#x3D; 0$,那么直接break掉，如果$n_i &#x3D; 0,p_i &#x3D; 1$,则需要加上这一位的贡献</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longint n,m;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;int p &#x3D; m + 1;int ans &#x3D; 0;for(int i &#x3D; 30;i &gt;&#x3D; 0;--i)&#123;int ni &#x3D; (n &gt;&gt; i &amp; 1);int pi &#x3D; (p &gt;&gt; i &amp; 1);if(ni &#x3D;&#x3D; 1 &amp;&amp; pi &#x3D;&#x3D; 0) break;if(ni &#x3D;&#x3D; 0 &amp;&amp; pi &#x3D;&#x3D; 1) ans +&#x3D; (1 &lt;&lt; i);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Count-Triangles"><a href="#Count-Triangles" class="headerlink" title="Count Triangles"></a>Count Triangles</h2><p><a href="https://codeforces.com/problemset/problem/1355/C">Problem - 1355C - Codeforces</a></p><p><strong>题意:</strong> 给定四个数字$A,B,C,D$使得三角形的三个边$a,b,c$分别满足$A \leq a \leq B, B\leq b \leq C,C \leq c \leq D$,问这样子的三元组$a,b,c$有多少</p><p><strong>解题思路:</strong> 其实拿到题目的时候我们可以直接考虑枚举，但是直接分别枚举$a,b$是否在区间里面时间肯定是有点问题的，但是既然是三角形我们其实如果知道$a + b$是多少我们就能找到对应的第三条边是多少，既然这样的话那么我们只需要枚举$a + b$中有多少个就可以了，然后通过差分数组去维护相对应的数量，那么对应的$a + b$在数据范围中对应的第三条边可能是啥呢？其实是在一个范围中，我们在$a + b - C$和$D + C - 1$中取小的就可以了，当然需要特判一下$a + b - C$小于$0$的情况</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longtypedef long long ll;vector&lt;int&gt; pa,pb,pc;int A,B,C,D;const int maxn &#x3D; 2e6 + 10;int sum[maxn];signed  main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;for(int i &#x3D; A;i &lt;&#x3D; B;++i) sum[i + B]++,sum[i + C + 1]--;for(int i &#x3D; 1;i &lt;&#x3D; 3 * D;++i) sum[i] +&#x3D; sum[i - 1];int ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; 3 * D;++i)&#123;ans +&#x3D; sum[i] * max(0ll,min(i - C,D - C + 1));&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Integers-Have-Friends"><a href="#Integers-Have-Friends" class="headerlink" title="Integers Have Friends"></a>Integers Have Friends</h2><p><a href="https://codeforces.com/problemset/problem/1548/B">Problem - 1548B - Codeforces</a></p><p><strong>题意:</strong> 给定一个长度为$n$的序列，序列中每个元素的数值各不相同，找一个最长的子序列使得这个子序列中$mod $ $m$都是相同的数字</p><p><strong>解题思路:</strong> 因为题目中需要找到$a[i]$  $mod$ $m$ $&#x3D;$ $a[j]$ $mod$ $m$,那么对于这样子的式子我们可以先进行一个化简，那么就是$(a[i] - a[j])  $ $ mod $</p><p> $m &#x3D; 0$,然后我们可以对这个序列进行一个处理，处理之后二分找最长的即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longtypedef long long ll;const int maxn &#x3D; 2e5 + 10;int a[maxn],n;int b[maxn],tree[maxn &lt;&lt; 2];inline void build(int k,int l,int r)&#123;if(l &#x3D;&#x3D; r)&#123;tree[k] &#x3D; b[l];return;&#125;int mid &#x3D; (l + r) &gt;&gt; 1;build(k &lt;&lt; 1,l,mid);build(k &lt;&lt; 1 | 1,mid + 1,r);tree[k] &#x3D; __gcd(tree[k &lt;&lt; 1],tree[k &lt;&lt; 1 | 1]);return;&#125;inline int query(int k,int l,int r,int lx,int rx)&#123;if(l &#x3D;&#x3D; lx &amp;&amp; r &#x3D;&#x3D; rx)&#123;return tree[k];&#125;int mid &#x3D; (l + r) &gt;&gt; 1;int ans &#x3D; 0;if(rx &lt;&#x3D; mid) ans &#x3D; __gcd(ans,query(k &lt;&lt; 1,l,mid,lx,rx));else&#123;if(lx &gt; mid) ans &#x3D; __gcd(ans,query(k &lt;&lt; 1 | 1,mid + 1,r,lx,rx));else ans &#x3D;__gcd(ans,__gcd(query(k &lt;&lt; 1,l,mid,lx,mid),query(k &lt;&lt; 1 | 1,mid + 1,r,mid + 1,rx)));&#125;return ans;&#125;int check(int x)&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(i + x - 1 &gt; n) break;if(abs(query(1,1,n,i + 1,i + x - 1)) !&#x3D; 1)&#123;return 1;&#125;&#125;return 0;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;b[i] &#x3D; a[i] - a[i - 1];&#125;build(1,1,n);int ans &#x3D; 1;int L &#x3D; 2;int R &#x3D; n;while(L &lt;&#x3D; R)&#123;int mid &#x3D; (L + R) &gt;&gt; 1;if(check(mid))&#123;L &#x3D; mid + 1;ans &#x3D; max(ans,mid);&#125;else&#123;R &#x3D; mid - 1;&#125;&#125;cout &lt;&lt; ans&lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Distance-in-Tree"><a href="#Distance-in-Tree" class="headerlink" title="Distance in Tree"></a>Distance in Tree</h2><p><a href="https://codeforces.com/contest/161/problem/D">Problem - D - Codeforces</a></p><p><strong>题意:</strong> 给定一棵$n$个结点的树，需要找出这个树上面距离严格为$k$的点对有多少个<br><strong>解题思路:</strong> 拿到题目之后看$k$的范围实际上不大，有$500$左右，那么其实$nk$时间复杂度的算法是可以过的<br>那么接下来去思考如何用$nk$的时间复杂度去求<br>那么我们可以考虑这样子的一件事情，假设我们已经知道当前这里的一个点距离它距离为$x$的点都已知道<br>那么对于答案的贡献实际上可以是$ans +&#x3D; dp[now][i] * dp[to][k - i - 1]$<br>然后我们再更新相对应的数量即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longconst int maxn &#x3D; 5e4 + 10;int dp[maxn][520];int n,ans,k;vector&lt;int&gt; edge[maxn];void dfs(int s,int fa)&#123;dp[s][0] &#x3D; 1;for(auto to:edge[s])&#123;if(to &#x3D;&#x3D; fa) continue;dfs(to,s);for(int i &#x3D; 0;i &lt; k;++i) ans +&#x3D; dp[s][i] * dp[to][k - i - 1];for(int i &#x3D; 0;i &lt; k;++i) dp[s][i + 1] +&#x3D; dp[to][i];&#125;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; k;for(int i &#x3D; 1,u,v;i &lt;&#x3D; n - 1;++i)&#123;cin &gt;&gt; u &gt;&gt; v;edge[u].emplace_back(v);edge[v].emplace_back(u);&#125;dfs(1,0);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="The-Sports-Festival"><a href="#The-Sports-Festival" class="headerlink" title="The Sports Festival"></a>The Sports Festival</h2><p><a href="https://codeforces.com/problemset/problem/1509/C">Problem - 1509C - Codeforces</a></p><h2 id="Three-Bags"><a href="#Three-Bags" class="headerlink" title="Three Bags"></a>Three Bags</h2><p><a href="https://codeforces.com/problemset/problem/1467/C">Problem - 1467C - Codeforces</a></p><p><strong>题目大意:</strong> 给定$3$个集合，可以选定任意两个集合中的元素$a,b$,移走$b$并且让$a$变成$a - b$</p><p>问最后剩下的元素最大值是多少</p><p><strong>解题思路:</strong> 首先考虑如果在没有集合限制的情况下，其实我们进行这样子的操作就会使得一个数字没有取到，那么其实对应到集合来说，就是两个不同集合的数字的最小值没有取到是最优的；还有一种取法，就是另外两个集合全部取完，还有一个集合全部不取</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longconst int maxn &#x3D; 1e6 + 10;int n,m,k;int sum;int a[maxn],b[maxn],c[maxn],sa,sb,sc;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;int ma,mb,mc;ma &#x3D; mb &#x3D; mc &#x3D; 1e9 + 7;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];sum +&#x3D; a[i];sa +&#x3D; a[i];ma &#x3D; min(ma,a[i]);&#125;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; b[i];sum +&#x3D; b[i];sb +&#x3D; b[i];mb &#x3D; min(mb,b[i]);&#125;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;cin &gt;&gt; c[i];sum +&#x3D; c[i];sc +&#x3D; c[i];mc &#x3D; min(mc,c[i]);&#125;int ans &#x3D; max(&#123;sum - 2 * (ma + mb),sum - 2 * (mb + mc),sum - 2 * (mc + ma),sum - 2 * sa,sum - 2 * sb,sum - 2 * sc&#125;);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dr-Evil-Underscores"><a href="#Dr-Evil-Underscores" class="headerlink" title="Dr. Evil Underscores"></a>Dr. Evil Underscores</h2><p><a href="https://codeforces.com/contest/1285/problem/D">Problem - D - Codeforces</a></p><p><strong>题意:</strong> 给定$n$个数字，需要找到一个数字$x$使得这些数字$\bigoplus x$的最大值最小</p><p><strong>解题思路:</strong> 拿到题目之后我们可以想到拆位去思考，首先我们考虑这样子的一件事情，对于高位来说肯定是能消掉尽可能消掉，不能消掉再看接下来这个高位所带来的影响，然后对于一位来说，如果这一位在所有数字上面都是相同的，那么其实它就可以最后消掉；如果有存在不相同的，对于最终答案来说这一位肯定是取$1$的，但是对于后面的位数还是不确定什么是更优的，因此还是需要找下去</p><p>所以我们可以建立一棵$tire$树，在$tire$树上面跑$dfs$即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 2e6 + 10;int tire[maxn][2],cnt,n;void insert(int x)&#123;int root &#x3D; 0;for(int i &#x3D; 30;i &gt;&#x3D; 0;--i)&#123;int id &#x3D; (x &gt;&gt; i &amp; 1);if(!tire[root][id]) tire[root][id] &#x3D; ++cnt;root &#x3D; tire[root][id];&#125;&#125;int dfs(int pos,int now)&#123;if(now &lt; 0) return 0;int ans &#x3D; 0;if(tire[pos][0] &amp;&amp; tire[pos][1])&#123;ans +&#x3D; (1 &lt;&lt; now);ans +&#x3D; min(dfs(tire[pos][0],now - 1),dfs(tire[pos][1],now - 1)); &#125;else if(tire[pos][0])&#123;ans +&#x3D; dfs(tire[pos][0],now - 1);&#125;else if(tire[pos][1])&#123;ans +&#x3D; dfs(tire[pos][1],now - 1);&#125;return ans;&#125;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;insert(x);&#125;cout &lt;&lt; dfs(0,30) &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="New-Year’s-Problem"><a href="#New-Year’s-Problem" class="headerlink" title="New Year’s Problem"></a>New Year’s Problem</h2><p><a href="https://codeforces.com/contest/1619/problem/D">Problem - D - Codeforces</a></p><p><strong>题目大意:</strong> 给定$m$个商店，有$n$个人，最多可以在$n - 1$个商店中买东西，第$i$个人收到第$j$个物品的数值是$A{i,j}$</p><p>问如何选择能够让所有人的最小开心值最高</p><p><strong>解题思路:</strong> 其实题目有两个$trick$点，一个是最小的开心值最大，对于这一个点我们可以使用二分来解决，还有一个就是$n - 1$个商店，那么对于$n - 1$来说我们可以思考的一个点也就是鸽巢原理。那么我们在写二分$check$的时候可以这样子，因为我们是选定$n - 1$个，如果对于当前选定的$x$来说，存在对应的人的最大值没有，那么就直接返回$0$，然后对于第二个部分的话我们可以考虑这样子的一个东西，至少要有一个商店带来两个人的贡献，否则就无法使用$n - 1$个</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 1e5 + 10;int n,m;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;vector&lt;vector&lt;int&gt;&gt; mp(n + 1,vector&lt;int&gt;(m + 1));for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;cin &gt;&gt; mp[i][j];&#125;&#125;auto check &#x3D; [](int x,vector&lt;vector&lt;int&gt;&gt; &amp;mp)&#123;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;int f &#x3D; 0;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;if(mp[j][i] &gt;&#x3D; x) f &#x3D; 1;&#125;if(!f) return 0;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int ct &#x3D; 0;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;ct +&#x3D; (mp[i][j] &gt;&#x3D; x);&#125;if(ct &gt;&#x3D; 2) return 1;&#125;return 0;&#125;;int L &#x3D; 0;int R &#x3D; 1000000000;int ans &#x3D; 0;while(L &lt;&#x3D; R)&#123;int mid &#x3D; (L + R) &gt;&gt; 1;if(check(mid,mp))&#123;L &#x3D; mid + 1;ans &#x3D; max(ans,mid);&#125;else R &#x3D; mid - 1;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Left-Right-Operation"><a href="#Left-Right-Operation" class="headerlink" title="Left Right Operation"></a><strong>Left Right Operation</strong></h2><p><a href="https://atcoder.jp/contests/abc263/tasks/abc263_d">D - Left Right Operation (atcoder.jp)</a></p><h2 id="Zuma"><a href="#Zuma" class="headerlink" title="Zuma"></a>Zuma</h2><p><a href="https://codeforces.com/contest/607/problem/B">Problem - B - Codeforces</a></p><p><strong>题目大意:</strong> 给定$n$个东西，每个东西有一个颜色，每次可以消除颜色是回文串的一个字串，消除一个字串之后会自动拼接回去，问最少需要几次可以消除完</p><p><strong>解题思路:</strong> 数据很小只有$500$，考虑区间$dp$</p><p>然后接下来我们来思考转移过程，因为每次消去的都是一个回文串，那么对于我们枚举的$l$和$r$来说可以放到上一个回文串中一起删除掉，如果$l &#x3D;&#x3D; r$</p><p>那么$dp[l][r] &#x3D; dp[l - 1][r + 1]$</p><p>否则我们需要考虑一个断点，在这个断点的两边进行$dp$</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 5e2 + 10;int dp[maxn][maxn];int a[maxn],n;int check(int l,int r)&#123;string s &#x3D; &quot;&quot;;for(int i &#x3D; l;i &lt;&#x3D; r;++i)&#123;char id &#x3D; &#39;0&#39; + a[i];s.push_back(id);&#125;string ss &#x3D; s;reverse(ss.begin(),ss.end());return ss &#x3D;&#x3D; s;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];dp[i][i] &#x3D; 1;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int r &#x3D; i + 2 - 1;if(r &gt; n) break;if(a[i] !&#x3D; a[r])&#123;dp[i][r] &#x3D; 2;&#125;else dp[i][r] &#x3D; 1;&#125;for(int len &#x3D; 3;len &lt;&#x3D; n;++len)&#123;for(int l &#x3D; 1;l &lt;&#x3D; n;++l)&#123;int r &#x3D; l + len - 1;if(r &gt; n) break;if(a[l] &#x3D;&#x3D; a[r]) dp[l][r] &#x3D; dp[l + 1][r - 1];else dp[l][r] &#x3D; min(dp[l + 1][r],dp[l][r - 1]) + 1;for(int mid &#x3D; l;mid &lt;&#x3D; r;++mid)&#123;chkmin(dp[l][r],dp[l][mid] + dp[mid + 1][r]);&#125;&#125;&#125;cout &lt;&lt; dp[1][n] &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Book-of-Evil"><a href="#Book-of-Evil" class="headerlink" title="Book of Evil"></a>Book of Evil</h2><p><a href="https://codeforces.com/problemset/problem/337/D">Problem - 337D - Codeforces</a></p><h2 id="Empty-Graph"><a href="#Empty-Graph" class="headerlink" title="Empty Graph"></a>Empty Graph</h2><p><a href="https://codeforces.com/problemset/problem/1712/D">https://codeforces.com/problemset/problem/1712/D</a></p><p><strong>题目大意:</strong> 给定一个长度为$n(1\leq n \leq 2e5)$的序列,对于任意的$(l,r),1 \leq l &lt; r \leq n$存在一条边连接$l$以及$r$，边权是$min(a_l,a_{l + 1},…,a_r)$</p><p>我们有$k$次操作机会可以将一个位置上的数字变成任意数字$x(1\leq x \leq 1e9)$,问这张图的直径是多少</p><p>一张图的直径定义如下所示: $max_{1 \leq u &lt; v \leq n}d(u,v)$,$d(u,v)$是从$u$到$v$的最短路</p><p><strong>解题思路:</strong>  首先我们先分析一下$d(u,v)$在这种情况下可能由什么组成，要么我是走两条最小的从$u$到$v$，如果是两个相邻的情况，那么我实际上$u$到$v$是只需要取$min(a_u,a_v)$</p><p>然后考虑这$k$次操作我们怎么使用，因为次数肯定是使用越多我最后的答案趋向于越大，具有一定的单调性，因此我们可以使用二分来写</p><p>我们去遍历整个序列，对于我们当前$check$的$x$来说，如果当前的数字小于$\frac{x}{2}$，那么我们需要一次机会将其变大</p><p>如果当前所需要的次数大于$k$的话，那么是不行的，我们就不要这一种情况</p><p>如果相同的话，我们看一下整个序列最大的$d$是多少，看看是否大于等于$x$即可</p><p>如果小于$k$次的话，找序列中最大的数字即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longconst int maxn &#x3D; 2e5 + 10;int a[maxn],n,k,use[maxn];int cal()&#123;int now1 &#x3D; min(use[1],use[2]);for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;now1 &#x3D; max(now1,min(use[i],use[i + 1]));&#125;int mi &#x3D; use[1];for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;chkmin(mi,use[i]);&#125;return min(2 * mi,now1);&#125;int check(int x)&#123;int cs &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) use[i] &#x3D; a[i];for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(use[i] * 2 &lt; x)&#123;cs++;use[i] &#x3D; 1e9;&#125;&#125;if(cs &gt; k) return 0;else if(cs &#x3D;&#x3D; k)&#123;int now &#x3D; cal();&#x2F;&#x2F; cout &lt;&lt; &quot;??? &quot; &lt;&lt; now &lt;&lt; &quot;\n&quot;;if(now &gt;&#x3D; x) return 1;return 0;&#125;else&#123;&#x2F;&#x2F; cout &lt;&lt; 33 &lt;&lt; &quot;\n&quot;;if(k &#x3D;&#x3D; 1)&#123;int now &#x3D; use[1];for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;chkmax(now,use[i]);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;now -&gt; &quot; &lt;&lt; now &lt;&lt; &quot; x -&gt; &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;if(now &gt;&#x3D; x) return 1;return 0;&#125;return 1;&#125;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; k;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];int L &#x3D; 1,R &#x3D; 1e9;int ans &#x3D; 0;&#x2F;&#x2F; cout &lt;&lt; &quot;?? &quot; &lt;&lt; check(4) &lt;&lt; &quot;\n&quot;;while(L &lt;&#x3D; R)&#123;int mid &#x3D; (L + R) &gt;&gt; 1;if(check(mid))&#123;L &#x3D; mid + 1;ans &#x3D; mid;&#125;else R &#x3D; mid - 1;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在异或运算中，若$x \bigoplus y &#x3D; z$则有$x \bigoplus z &#x3D; y$</li><li>在两个数字取余需要相等的时候，可以转移一下位置变成一个等式</li><li>注意模拟样例的时候样例给定的特殊性质</li><li>对于$n - 1$这个数字我们要特殊考虑一下$trick$点</li><li>边着色考虑特殊情况比如有一些情况只需要两种颜色即可$(CF1217D)$</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dytechlab Cup 2022</title>
      <link href="/2022/10/09/Dytechlab-Cup-2022/"/>
      <url>/2022/10/09/Dytechlab-Cup-2022/</url>
      
        <content type="html"><![CDATA[<h1 id="Dytechlab-Cup-2022"><a href="#Dytechlab-Cup-2022" class="headerlink" title="Dytechlab Cup 2022"></a>Dytechlab Cup 2022</h1><h2 id="A-Ela-Sorting-Books"><a href="#A-Ela-Sorting-Books" class="headerlink" title="A. Ela Sorting Books"></a>A. Ela Sorting Books</h2><p><strong>题目大意:</strong>  给定$n(1 \leq n \leq 200)$本书,每本书有一个首字符，要把这$n$本书放到$k$个书架上，每个书架上面按照字典序第一个没有出现过的字符加入集合中，问这个集合最大能够构成的字符是什么</p><p><strong>解题思路:</strong> 模拟样例可以发现一件事情，假设我们当前还有若干个字符，那么从第一个字符按顺序放到最后一个可以连续放置的字符肯定是最优秀的放置方法。那么我们怎么写呢？我们可以枚举每个书架可以最终放入集合的字符是多少，然后$check$即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn &#x3D; 1e6 + 10;int a[maxn],n,k;string str;map&lt;int,int&gt; mp;int check(int x)&#123;if(x &gt; n &#x2F; k) return 0;for(int i &#x3D; 0;i &lt;&#x3D; x - 1;++i)&#123;if(mp[i] &lt;&#x3D; 0) return 0; &#125;for(int i &#x3D; 0;i &lt;&#x3D; x - 1;++i)&#123;mp[i]--;&#125;return 1;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; k;cin &gt;&gt; str;mp.clear();for(auto to:str)&#123;int id &#x3D; to - &#39;a&#39;;mp[id]++;&#125;vector&lt;char&gt; ans;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;for(int j &#x3D; 25;j &gt;&#x3D; 0;--j)&#123;if(check(j))&#123;ans.push_back(&#39;a&#39; + j);break;&#125;&#125;&#125;sort(ans.begin(),ans.end());reverse(ans.begin(),ans.end());for(auto to:ans)&#123;cout &lt;&lt; to;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Ela’s-Fitness-and-the-Luxury-Number"><a href="#B-Ela’s-Fitness-and-the-Luxury-Number" class="headerlink" title="B. Ela’s Fitness and the Luxury Number"></a>B. Ela’s Fitness and the Luxury Number</h2><p><strong>题目大意:</strong> 给定$T (1 \leq T \leq 2e5)$组样例，每组两个数字分别是$l$ 以及$r(1 \leq l,r \leq 1e18)$ ，问在这个区间中美丽数字的个数是多少。美丽数字的定义是$x$可以被$x $  $mod$ $\lfloor\sqrt{x}\rfloor$ $ &#x3D; 0$</p><p><strong>解题思路:</strong> 发现数据范围实际上很大，然后我打了一下表发现了一个规律，就是根据每一个平方数去划分，可以以每个平方数划分成一个块，假设当前的平方数是$x$，当前的平方根是$y$，那么在这一个块中存在的数字分别是$x,x + y,x + 2 * y$</p><p>特别需要注意的是，$floor$存在的一定精度误差，因此在取的时候可以采取一些操作比如$–$来优化</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn &#x3D; 1e6 + 10;int a[maxn],n,k;string str;void get()&#123;for(int i &#x3D; 1;i &lt;&#x3D; 20;++i)&#123;int div &#x3D; floor(sqrt(1.0 * i));if(i % div &#x3D;&#x3D; 0)&#123;cout &lt;&lt; &quot;i -&gt; &quot; &lt;&lt; i &lt;&lt; &quot;\n&quot;;&#125;&#125;&#125;int getans(int x)&#123;if(x &#x3D;&#x3D; 0) return 0;int rd &#x3D; (sqrt(1.0 * x));if(rd * rd &gt; x) rd--;int haha &#x3D; rd * rd;int ans &#x3D; (rd - 1) * 3;if(x &gt;&#x3D; haha)&#123;ans++;&#125;if(x &gt;&#x3D; haha + rd)&#123;ans++;&#125;if(x &gt;&#x3D; haha + rd * 2)&#123;ans++;&#125;return ans;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;int l,r;cin &gt;&gt; l &gt;&gt; r;&#x2F;&#x2F; cout &lt;&lt; getans(l - 1) &lt;&lt; &quot;\n&quot;;&#x2F;&#x2F; cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; getans(l - 1) &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; getans(r) &lt;&lt; &quot;\n&quot;;cout &lt;&lt; getans(r) - getans(l - 1) &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Ela-and-Crickets"><a href="#C-Ela-and-Crickets" class="headerlink" title="C. Ela and Crickets"></a>C. Ela and Crickets</h2><p><strong>题目大意:</strong> 给定一个无限大的棋盘，给定一个$L$形状的棋子以及这个棋子刚开始的坐标，给定一个目标坐标，问这个棋子通过跳跃的方式能否到达这个目标点</p><p><strong>解题思路:</strong> 既然在一个棋盘上面，我们可以先考虑本身这个棋盘所带来的性质，也就是考虑存在的$L$形状的奇偶性带来的影响。我们可以模拟样例，发现对于一个$L$形状来说，和那个空着的格子的横纵坐标奇偶性都一样的那么我们是不可达的；然后我们考虑特殊情况，如果那个小角在边缘的话，那么不管怎么样子也只能再这个边缘移动，然后这样子判断即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn &#x3D; 1e2 + 10;int r[maxn],n,k,c[maxn],x,y,sx,sy;string str;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n;map&lt;int,int&gt; mpx,mpy;for(int i &#x3D; 1;i &lt;&#x3D; 3;++i)&#123;cin &gt;&gt; r[i] &gt;&gt; c[i];mpx[r[i]]++;mpy[c[i]]++;&#125;cin &gt;&gt; x &gt;&gt; y;sx &#x3D; sy &#x3D; 0;for(auto [to,cs]:mpx)&#123;if(cs &#x3D;&#x3D; 2) sx &#x3D; to;&#125;for(auto [to,cs]:mpy)&#123;if(cs &#x3D;&#x3D; 2) sy &#x3D; to;&#125;&#x2F;&#x2F;边缘if((sx &#x3D;&#x3D; 1 || sx &#x3D;&#x3D; n) &amp;&amp; (sy &#x3D;&#x3D; 1 || sy &#x3D;&#x3D; n))&#123;if(sx &#x3D;&#x3D; x || sy &#x3D;&#x3D; y) cout &lt;&lt; &quot;YES\n&quot;;else cout &lt;&lt; &quot;NO\n&quot;;continue;&#125;if((sx - x + sy - y) % 2 &#x3D;&#x3D; 1)&#123;cout &lt;&lt; &quot;YES\n&quot;;continue;&#125;if((sx - x) % 2 &#x3D;&#x3D; 0) cout &lt;&lt; &quot;YES\n&quot;;else if((sy - y) % 2 &#x3D;&#x3D; 0) cout &lt;&lt; &quot;YES\n&quot;;else cout &lt;&lt; &quot;NO\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Ela-and-the-Wiring-Wizard"><a href="#D-Ela-and-the-Wiring-Wizard" class="headerlink" title="D. Ela and the Wiring Wizard"></a>D. Ela and the Wiring Wizard</h2><p><strong>题目大意:</strong> 给定一张图，图有$n$个点$m$条边$(2 \leq n \leq 500,n - 1\leq m \leq 100000)$每次可以进行若干次操作，操作如下所示</p><p>选择两条边$(u,v)$和$(v,w)$删除$(u,v)$然后连接$(u,w)$，代价是$(u,v)$的边权</p><p>问从节点$1$到节点$n$最少需要多少次</p><p><strong>解题思路:</strong> 刚开始拿到题目的时候发现没有任何思路，模拟样例可以发现一个性质，就是无论最后怎么样，最后只有一条从$1$到$n$的边使用</p><p>那么我们可以提出猜想，是否从$1$到$n$只需要连接一条路呢？</p><p>接下来的部分参考了$pzr$佬的</p><p>我们可以做出反证感性理解一下，假设我们有多条路到$n$，其中分别是$1 -&gt; u_1 -&gt; u_2 -&gt; n$,设$u_1 -&gt;u_2$的距离是$w_1$，另外一条从$1 -&gt; u_1$权值是$w_2$</p><p>首先就放着这两条边，边权是$w_1 + w_2$</p><p>如果让我们把所有的边都变成$w_1$,那么就是$2w_1$</p><p>或者我们把所有边变成$w_2$，那么就是$2w_2$</p><p>那么进行修改后我们总能贪心取到最小的</p><p>分析样例之后，我们发现建边有成自环和非自环的情况</p><p>分析非自环的情况，那么对于一条边来说，就是去修改$dis(1,u) + dis(v,n)$的次数然后再加上$1$次走到的贡献</p><p>那么接下来考虑自环的情况，如果有自环的话最多可能存在几个自环呢？</p><p>我们可以把自环看成是一个点，设自环点是$x$,那么我们额外花费一个贡献连接$x$,从$1$到$x$再从$x$到$n$的距离相加然后乘贡献，这个$x$相当于中间的一个断点去更新整张图，因此实际上最多也就只有一个</p><p>那么对于这一种题目来说，分析完整道题目我们发现都是对<strong>边</strong> 这一个元素进行考虑</p><p>因为从一开始我们就在思考，从得出结论开始，再到实际上我去取哪条边最优</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define int long longtypedef long long ll;const int maxn &#x3D; 1e3 + 10;const int inf &#x3D; 1e9;int dis[maxn][maxn],n,m;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;int,3&gt;&gt; edge;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;dis[i][j] &#x3D; inf;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) dis[i][i] &#x3D; 0;for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge.push_back(&#123;u,v,w&#125;);dis[u][v] &#x3D; dis[v][u] &#x3D; 1;&#125;for(int k &#x3D; 1;k &lt;&#x3D; n;++k)&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;chkmin(dis[i][j],dis[i][k] + dis[k][j]);&#125;&#125;&#125;int ans &#x3D; 1e18;for(auto [u,v,w]:edge)&#123;chkmin(ans,(dis[1][u] + 1 + dis[v][n]) * w);chkmin(ans,(dis[1][v] + dis[u][n] + 1) * w);for(int x &#x3D; 1;x &lt;&#x3D; n;++x)&#123;chkmin(ans,(min(dis[u][x],dis[v][x]) + dis[1][x] + dis[x][n] + 2) * w);&#125;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 思维 </tag>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/09/hello-world/"/>
      <url>/2022/10/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 272</title>
      <link href="/2022/10/08/Atcoder-Beginner-Contest-272/"/>
      <url>/2022/10/08/Atcoder-Beginner-Contest-272/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-Beginner-Contest-272"><a href="#Atcoder-Beginner-Contest-272" class="headerlink" title="Atcoder Beginner Contest 272"></a>Atcoder Beginner Contest 272</h1><h2 id="A-Integer-Sum"><a href="#A-Integer-Sum" class="headerlink" title="A - Integer Sum"></a>A - Integer Sum</h2><p><strong>题目大意:</strong> 给定$n$个数字，求$n$个数字的和</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;int n,sum;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;sum +&#x3D; x;&#125;cout &lt;&lt; sum &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="B-Everyone-is-Friends"><a href="#B-Everyone-is-Friends" class="headerlink" title="B - Everyone is Friends"></a>B - Everyone is Friends</h2><p><strong>题目大意:</strong> 给定$n$个人以及$m$个分组，问是否每两个人都曾经出现在同一组过</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;int n,sum,m;set&lt;int&gt; a[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;for(int i &#x3D; 1,num;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; num;for(int j &#x3D; 1,x;j &lt;&#x3D; num;++j)&#123;cin &gt;&gt; x;a[x].insert(i);&#125;&#125;int f &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;int nm &#x3D; 0;for(auto to:a[i])&#123;auto it &#x3D; a[j].find(to);if(it !&#x3D; a[j].end()) &#123;nm++;&#125;&#125;if(nm &gt;&#x3D; 1) f++;&#125;&#125;if(f &#x3D;&#x3D; n * (n - 1) &#x2F; 2) cout &lt;&lt; &quot;Yes\n&quot;;else cout &lt;&lt; &quot;No\n&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="C-Max-Even"><a href="#C-Max-Even" class="headerlink" title="C - Max Even"></a>C - Max Even</h2><p><strong>题目大意:</strong> 给定$n(1 \leq n \leq 2e5)$个数字，问两个不相同的数字加起来的最大偶数是多少</p><p><strong>解题思路:</strong> 分析题目我们可以发现一个关键问题就是两个数字加起来是偶数，那么要么是奇数和奇数相加要么是偶数和偶数相加，我们分类一下数字的奇偶性即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;int n,sum,m;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);set&lt;int&gt; odd,even;cin &gt;&gt; n;for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;if(x &amp; 1) odd.insert(x);else even.insert(x);&#125;int ans &#x3D; -1;if(odd.size() &gt;&#x3D; 2)&#123;int res &#x3D; 0;res +&#x3D; *odd.rbegin();odd.erase(prev(odd.end()));res +&#x3D; *odd.rbegin();ans &#x3D; max(ans,res);&#125;if(even.size() &gt;&#x3D; 2)&#123;int res &#x3D; 0;res +&#x3D; *even.rbegin();even.erase(prev(even.end()));res +&#x3D; *even.rbegin();ans &#x3D; max(ans,res);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Root-M-Leaper"><a href="#D-Root-M-Leaper" class="headerlink" title="D - Root M Leaper"></a>D - Root M Leaper</h2><p><strong>题目大意:</strong> 给定一个$n * n(1\leq n \leq 400)$的棋盘，初始点在$(1,1)$，一个点如果在$(i,j)$当且仅当它可以到$(k,l)$存在他们的$\sqrt{(i - k) ^ 2 + (j - l) ^ 2} &#x3D; \sqrt{m} (1 \leq m \leq 1e5)$</p><p>求这个矩阵中的所有点最少需要几步能被走到</p><p><strong>解题思路:</strong> 发现无论怎么走实际上我们是走不出这个棋盘的，那么实际上$m$最多不会超过$n$，那么我们就可以预处理出所有可以走的步数然后进行$BFS$即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 5e2 + 10;const int inf &#x3D; 1e9;int n,m;int tx[] &#x3D; &#123;1,-1,1,-1&#125;;int ty[] &#x3D; &#123;1,1,-1,-1&#125;;int dis[maxn][maxn];int vis[maxn][maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;vector&lt;pair&lt;int,int&gt;&gt; stp;int lmt &#x3D; min(n,m) + 100;for(int i &#x3D; 0;i &lt;&#x3D; lmt;++i)&#123;for(int j &#x3D; 0;j &lt;&#x3D; lmt;++j)&#123;if(i * i + j * j &#x3D;&#x3D; m)&#123;stp.push_back(&#123;i,j&#125;);stp.push_back(&#123;j,i&#125;);&#125;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j) dis[i][j] &#x3D; inf;&#125;queue&lt;array&lt;int,2&gt;&gt; que;que.push(&#123;1,1&#125;);vis[1][1] &#x3D; 1;dis[1][1] &#x3D; 0;while(!que.empty())&#123;auto [x,y] &#x3D; que.front();que.pop();for(auto [spx,spy]:stp)&#123;for(int k &#x3D; 0;k &lt;&#x3D; 3;++k)&#123;auto fx &#x3D; x + spx * tx[k];auto fy &#x3D; y + spy * ty[k];if(fx &gt;&#x3D; 1 &amp;&amp; fx &lt;&#x3D; n &amp;&amp; fy &gt;&#x3D; 1 &amp;&amp; fy &lt;&#x3D; n &amp;&amp; dis[fx][fy] &#x3D;&#x3D; inf &amp;&amp; vis[fx][fy] &#x3D;&#x3D; 0)&#123;dis[fx][fy] &#x3D; dis[x][y] + 1;vis[fx][fy] &#x3D; 1;que.push(&#123;fx,fy&#125;);&#125;&#125;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;if(dis[i][j] &#x3D;&#x3D; inf) dis[i][j] &#x3D; -1;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;cout &lt;&lt; dis[i][j] &lt;&lt; &quot; \n&quot;[j &#x3D;&#x3D; n];&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Add-and-Mex"><a href="#E-Add-and-Mex" class="headerlink" title="E - Add and Mex"></a>E - Add and Mex</h2><p><strong>题目大意:</strong> 给定一个长度为$n (1 \leq n \leq 2e5)$的数组，数组是$int$范围，给定$m$次操作，每次操作第$i$个位置上面的数字都会加上$i$，问这个数组的$mex$是多少</p><p><strong>解题思路:</strong> 首先我们通过模拟样例可以发现一件事情，就是如果这个序列中的数字是负数，那么它实际上是没有用的，其次是考虑$mex$的性质，因为对于长度为$n$的数组来说，$mex$最大就是$n + 1$，那么对于每一个数字来说最多也不会超过$n + 1$，既然这样，因为对于一个下标为$i$的数字来说，最多加$n &#x2F; i$次，那么对于整个序列来说就是一个调和级数，模拟即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;const int inf &#x3D; 1e9;int n,m;int ans[maxn],a[maxn];vector&lt;int&gt; pos[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];int st &#x3D; 0;if(a[i] &lt; 0)&#123;int rd &#x3D; abs(a[i]) &#x2F; i;if(abs(a[i]) % i) rd++;a[i] +&#x3D; i * rd;st &#x3D; rd;if(st &lt;&#x3D; m)&#123;pos[st].push_back(a[i]);&#125;&#125;while(a[i] + i &lt;&#x3D; n &amp;&amp; st &lt;&#x3D; m)&#123;st++;a[i] +&#x3D; i;if(a[i] &gt;&#x3D; 0)&#123;pos[st].push_back(a[i]);&#125;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;sort(pos[i].begin(),pos[i].end());pos[i].erase(unique(pos[i].begin(),pos[i].end()),pos[i].end());int now &#x3D; 0;for(auto to:pos[i])&#123;if(to !&#x3D; now) break;now++;&#125;cout &lt;&lt; now &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="G-Yet-Another-mod-M"><a href="#G-Yet-Another-mod-M" class="headerlink" title="G - Yet Another mod M"></a>G - Yet Another mod M</h2><p><strong>题目大意:</strong> 给定一个长度为$n(1 \leq n \leq 5000)$，然后找到一个数字$M$，使得这个序列中每一个数字$mod$ $M$后存在唯一的众数</p><p><strong>解题思路:</strong> 在赛时就在想随机是否可行但是没有一个好的$check$方案，然后参考了一下严格鸽的题解</p><p>首先因为是唯一的众数，那么假设我们在序列中取两个数字，这两个数字$mod$ $M$ 都是$0$的，那么就存在$(x - y) $  $mod$  $m &#x3D;&#x3D; 0$</p><p>那接下来我们去找$(x - y)$的因子就可以了</p><p>这样子做的正确概率是：因为$x,y$都有$\frac{1}{2}$的概率取到，那么总的取到的概率就是$\frac{1}{4}$，那我们选择多次选择不到的概率实际上很小，对赌就可以了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;&#x2F;&#x2F; #define int long long&#x2F;&#x2F; typedef long long ll;const int maxn &#x3D; 2e5 + 10;const int inf &#x3D; 1e9;int n,m;int ans[maxn],a[maxn];vector&lt;int&gt; pos[maxn];int check(int x)&#123;if(x &lt; 3) return 0;map&lt;int,int&gt; mp;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;mp[a[i] % x]++;if(mp[a[i] % x] * 2 &gt; n) return 1;&#125;return 0;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);srand(time(NULL));cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];&#125;int cnt &#x3D; 200;while(cnt--)&#123;int x &#x3D; a[rand() % n + 1];int y &#x3D; a[rand() % n + 1];int d &#x3D; x - y;if(d &#x3D;&#x3D; 0) continue;for(int i &#x3D; 1;i * i &lt;&#x3D; d;++i)&#123;if(d % i !&#x3D; 0) continue;if(check(i))&#123;cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;return 0;&#125;if(check(d &#x2F; i))&#123;cout &lt;&lt; d &#x2F; i &lt;&lt; &quot;\n&quot;;return 0;&#125;&#125;&#125;cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> abc </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder Beginner Contest 271 C-F</title>
      <link href="/2022/10/02/abc271/"/>
      <url>/2022/10/02/abc271/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-Beginner-Contest-271-C-F"><a href="#Atcoder-Beginner-Contest-271-C-F" class="headerlink" title="Atcoder Beginner Contest 271 C-F"></a>Atcoder Beginner Contest 271 C-F</h1><h2 id="C-Manga"><a href="#C-Manga" class="headerlink" title="C - Manga"></a>C - Manga</h2><p><strong>题意:</strong> 给定一个长度为$n(1 \leq n \leq 3e5)$的序列,每个位置有一个值$x(1 \leq x \leq 1e9)$，我们可以进行任意多次操作，操作的话是如果序列的长度还大于等于$2$，那么我们可以任意选择$2$个数字去删除，然后加进去任意一个数字进去，问我们最后能够得到一个形似$1,2,3…$的最长序列</p><p><strong>解题思路:</strong> 首先我们分析一下题意，我们可以知道最后的答案最多不会超过$n$，那么我们在读入的时候可以将大于$n$的部分放进一个$vector$里面，然后对于小于$n$的一部分我们可以先给他标记然后放到一个双端队列里面，如果其中的数字有重复的部分我们也需要放进上面的$vector$之中。接着我们模拟这个过程即可。在模拟的时候注意我们优先取$vector$当中的，然后我们取队列后面的即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 3e5 + 10;int vis[maxn],n;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;vector&lt;int&gt; a;for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;if(x &lt;&#x3D; n)&#123;if(vis[x]) a.push_back(x);else vis[x] &#x3D; 1;&#125;else a.push_back(x);&#125;deque&lt;int&gt; q;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(vis[i]) q.push_back(i);&#125;int ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(vis[i] &amp;&amp; q.size())&#123;ans++;q.pop_front();continue;&#125;if(a.size() &gt;&#x3D; 2)&#123;a.pop_back();a.pop_back();&#125;else if(a.size() &#x3D;&#x3D; 1)&#123;a.pop_back();if(!q.empty()) q.pop_back(); else break;&#125;else&#123;if(q.size() &gt;&#x3D; 2)&#123;q.pop_back();q.pop_back();&#125;else break;&#125;ans++;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="D-Flip-and-Adjust"><a href="#D-Flip-and-Adjust" class="headerlink" title="D - Flip and Adjust"></a>D - Flip and Adjust</h2><p><strong>题意:</strong> 给定$n(1 \leq n \leq 100)$张卡片，每张卡片背面和正面有一个数字，现在让我们选择每张卡片的正面或者反面，问是否能够组成$s(1\leq s \leq 10000)$</p><p><strong>解题思路:</strong> 首先我们可以观察数据范围，可能是$O(n ^ 3)$或者$O(ns)$的$dp$</p><p>接下来我们考虑这样的一个过程，首先无论如何每张牌都是要取的，那么假定我现在取到第$i - 1$张牌的值有$s_{i - 1}$，那么我取第$i$张牌的时候的值肯定有$s_{i - 1} + mp[i][0]$和$s_{i - 1} + mp[i][1]$$(mp[i][0&#x2F;1]表示第i张牌的正反面的值)$</p><p>那么我们就可以用$dp[i][s]$来表示前$i$张牌可能组成的值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;const int maxn &#x3D; 2e2 + 10;int mp[maxn][2],n,s;int dp[maxn][40010];int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; s;dp[0][0] &#x3D; 1;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; mp[i][0] &gt;&gt; mp[i][1];if(i &#x3D;&#x3D; 1)&#123;dp[1][mp[i][0]] &#x3D; 1;dp[1][mp[i][1]] &#x3D; 1;continue;&#125;for(int j &#x3D; 0;j &lt;&#x3D; s;++j)&#123;if(!dp[i - 1][j]) continue;if(j + mp[i][0] &lt;&#x3D; s) dp[i][j + mp[i][0]] &#x3D; 1;if(j + mp[i][1] &lt;&#x3D; s) dp[i][j + mp[i][1]] &#x3D; 1;&#125;&#125;if(dp[n][s])&#123;cout &lt;&lt; &quot;Yes\n&quot;;string ans &#x3D; &quot;&quot;;for(int i &#x3D; n;i &gt;&#x3D; 1;--i)&#123;if(s - mp[i][0] &gt;&#x3D; 0 &amp;&amp; dp[i - 1][s - mp[i][0]])&#123;s -&#x3D; mp[i][0];ans.push_back(&#39;H&#39;);&#125;else&#123;s -&#x3D; mp[i][1];ans.push_back(&#39;T&#39;);&#125;&#125;assert(ans.length() &#x3D;&#x3D; n);reverse(ans.begin(),ans.end());cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;else&#123;cout &lt;&lt; &quot;No\n&quot;;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="E-Subsequence-Path"><a href="#E-Subsequence-Path" class="headerlink" title="E - Subsequence Path"></a>E - Subsequence Path</h2><p><strong>题目大意:</strong> 给定$n$个点$m$条单向边$(1 \leq n,m \leq 2e5)$，没有重边和自环，每个边有一条权值，接下来给定一个序列$E$，我们走的路径的标号形成的序列必须是这个序列$E$的子序列，问从点$1$到点$n$的最短路径</p><p><strong>解题思路:</strong> 分析题目发现我们的突破口应该在这个给定我们的序列$E$这里，因为考虑我们取到的序列是这个序列的子序列，这里给我们透露到一些信息，就是假设我们当前已经遍历到第$i$条边，那么我们是可以用前面$i - 1$条边来更新这一张图的，那么我们知道这个点之后就可以写啦</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longconst int maxn &#x3D; 2e5 + 10;const int inf &#x3D; 1e18;struct node&#123;int u,v,w;&#125;edge[maxn];int n,m,k;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;vector&lt;int&gt; dis(n + 1,inf);for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge[i] &#x3D; &#123;u,v,w&#125;;&#125;dis[1] &#x3D; 0;for(int i &#x3D; 1,x;i &lt;&#x3D; k;++i)&#123;cin &gt;&gt; x;int u &#x3D; edge[x].u;int v &#x3D; edge[x].v;int w &#x3D; edge[x].w;dis[v] &#x3D; min(dis[v],dis[u] + w);&#125;if(dis[n] !&#x3D; inf) cout &lt;&lt; dis[n] &lt;&lt; &quot;\n&quot;;else cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="F-XOR-on-Grid-Path"><a href="#F-XOR-on-Grid-Path" class="headerlink" title="F - XOR on Grid Path"></a>F - XOR on Grid Path</h2><p><strong>题目大意:</strong> 给定一个$n * n(1\leq n \leq 20)$的矩阵，我们从点$(1,1)$开始，每次移动可以向$(x + 1,y)$或者$(x,y + 1)$移动，问我们到达$(n,n)$使得异或和为$0$的路径有多少条</p><p><strong>解题思路:</strong> 首先对于这种矩阵的题目我们肯定先去考虑$dp$的，但是如果暴力去枚举所有方案的话方案数实际会非常的大</p><p>根据官方题解的思路，建议我们使用$meet$  $in$ $middle$来做</p><p>那$meet$  $in$ $middle$是个什么东西呢？大概就是我从两个点来搜索，搜索到一些具有共同性质的点从而结束，因为这样子会大大减少我们所需要的时间复杂度</p><p>那么对于矩阵来说，我们可以从$(1,1)$点和$(n,n)$点来搜索，对于这两个点来说我们都搜索到对角线上面的点来结束,因为对角线刚好分割两个矩阵</p><p>那么我们对于$(1,1)$点来说，我们可以直接搜索下去到对角线来记录当前异或和的数值，那么对于$(n,n)$点来说，我们可以往上面搜索，搜到对角线的话就加上之前前面遍历到这一点的值，因为我们需要异或和是$0$嘛</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;#define int long longint mp[30][30],n;unordered_map&lt;int,int&gt; dp[30][30];int ans;void dfs1(int x,int y,int now)&#123;if(x + y &#x3D;&#x3D; n)&#123;dp[x][y][now]++;return;&#125;if(x + y &gt; n) return;dfs1(x + 1,y,now ^ mp[x + 1][y]);dfs1(x,y + 1,now ^ mp[x][y + 1]);&#125;void dfs2(int x,int y,int now)&#123;if(x + y &#x3D;&#x3D; n)&#123;ans +&#x3D; dp[x][y][now ^ mp[x][y]];return;&#125;if(x + y &lt; n) return;dfs2(x - 1,y,now ^ mp[x - 1][y]);dfs2(x,y - 1,now ^ mp[x][y - 1]);&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j) cin &gt;&gt; mp[i][j];&#125;dfs1(1,1,mp[1][1]);dfs2(n,n,mp[n][n]);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> abc </tag>
            
            <tag> 思维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph Traing</title>
      <link href="/2022/09/29/Graph-Traing/"/>
      <url>/2022/09/29/Graph-Traing/</url>
      
        <content type="html"><![CDATA[<h1 id="Graph-Traing"><a href="#Graph-Traing" class="headerlink" title="Graph Traing"></a>Graph Traing</h1><h2 id="Boboniu-Walks-on-Graph"><a href="#Boboniu-Walks-on-Graph" class="headerlink" title="Boboniu Walks on Graph"></a>Boboniu Walks on Graph</h2><p><a href="https://codeforces.com/problemset/problem/1394/B">https://codeforces.com/problemset/problem/1394/B</a></p><p><strong>题目大意:</strong> 给定一张图有$n$个点$m$条边，每条边的权值从$1$ ~ $m$并且每条边的权值互相不相同，这张图中一个点的最大的出度是$k$,然后求$k$元组，这个$k$元组的第$i$个位置代表着出度数为$i$的点走他的边权从小到大为第$c_i$的边，问多元组最多有多少种</p><p><strong>解题思路:</strong> 首先我们可以发现这样子一件事情，因为$k$的范围并不大，因此如果我们暴力去枚举多元组的样子最多也只有$9!$种，那么我们是否可以有一种很快速的$check$方法来检查一种多元组是否合法呢？首先我们可以想这样一件事情，因为对于每一个点最后都能跳回到自己，所以最后的结果必定是一个环，那么对于一个环来说我们可以粗略的将其看成一个集合，然后我们给每个点刚开始随机一个数值。然后我们分析多元组的性质，对于任意一种多元组，第$i$位的跳跃到第$c_i$个，那么我们可以刚开始预处理这个东西，对于当前点的出度和当前去往点的序号记录一个数组然后加起来就可以了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;#define int long longtypedef long long ll;const int maxn &#x3D; 1e6 + 10;int n,m,k;int sum[15][15];int a[maxn],ansha,ans;int res;vector&lt;pair&lt;int,int&gt;&gt; edge[maxn];void dfs(int now)&#123;if(now &#x3D;&#x3D; k + 1)&#123;if(res &#x3D;&#x3D; ansha) ans++;return;&#125;for(int i &#x3D; 1;i &lt;&#x3D; now;++i)&#123;res +&#x3D; sum[now][i];dfs(now + 1);res -&#x3D; sum[now][i];&#125;return;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);srand(time(NULL));cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) a[i] &#x3D; rand() * rand(),ansha +&#x3D; a[i];for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge[u].push_back(&#123;w,v&#125;);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) sort(edge[i].begin(),edge[i].end());for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int sz &#x3D; edge[i].size();for(int j &#x3D; 0;j &lt; sz;++j)&#123;auto to &#x3D; edge[i][j].second;sum[sz][j + 1] +&#x3D; a[to];&#125;&#125;dfs(1);cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Slipper"><a href="#Slipper" class="headerlink" title="Slipper"></a>Slipper</h2><p>(<a href="https://vjudge.net/contest/517945#problem/C">https://vjudge.net/contest/517945#problem/C</a>)</p><p><strong>题目大意:</strong> 给定一棵树，结点个数为$n (1 \leq n \leq 1e5)$,给定每条树边连接的两个结点和对应的边权，除此之外可以进行若干次魔法，若$|dep_u - dep_v| &#x3D; k$，那么从$u$到$v$只需要$d$点边权，给定两个点$s$和$t$，求从$s$到$t$最少需要多少边权</p><p><strong>解题思路:</strong> 我们可以刚开始这么思考，如果不考虑任何优化，我们可以将每个点放到对应的一个存储容器中，这个容易用$dep$ 来标记，如果两个容器相差$k$，那么我们对于两个集合中的点进行一一连边即可。但是这样子实际的时间复杂度很大，那么我们考虑优化建边。根据上面的思考，我们可以发现一个性质只有层与层之间才会连接一条边，其实很多边是重复的，那么我们对于每一个层来说我们可以建一个点，表示层，那么我们对于每一个点来说，连向这个层，那么对于层与层之间的，我们可以从$u$往$u + k$建一条边，同时也可以从$u + k$往$u$建边，但是只有一层层点是不够的，因为原来的树点连过来的边权是$0$，那么我们再建一层层点来跑最短路即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;&#x2F;&#x2F; #define int long longtypedef long long ll;const int maxn &#x3D; 6e6 + 10;const int maxm &#x3D; 1e6 + 10;const ll inf &#x3D; 1e18;int tot;struct node&#123;    int u,v,w,nxt;&#125;edge[maxn &lt;&lt; 1];int head[maxn];inline void add(int u,int v,int w)&#123;    edge[++tot].u &#x3D; u,edge[tot].v &#x3D; v,edge[tot].w &#x3D; w,edge[tot].nxt &#x3D; head[u],head[u] &#x3D; tot;&#125;int n,dep[maxm],k,p,s,t,mxdep;void dfs(int s,int fa)&#123;    dep[s] &#x3D; dep[fa] + 1;    mxdep &#x3D; max(mxdep, dep[s]);    for(int i &#x3D; head[s];i;i &#x3D; edge[i].nxt)    &#123;        int to &#x3D; edge[i].v;        if(to &#x3D;&#x3D; fa) continue;        dfs(to,s);    &#125;&#125;void dij()&#123;    vector&lt;int&gt; vis(3 * n + 10, 0);    vector&lt;ll&gt; dis(3 * n + 10, inf);    dis[s] &#x3D; 0;    priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt;&gt;, greater&lt;pair&lt;ll, int&gt;&gt;&gt; que;    que.push(&#123;0, s&#125;);    while(!que.empty())    &#123;        auto now &#x3D; que.top().second;        que.pop();        if(vis[now])            continue;        vis[now] &#x3D; 1;        for(int i &#x3D; head[now];i;i &#x3D; edge[i].nxt)        &#123;            int to &#x3D; edge[i].v;            ll ww &#x3D; edge[i].w * 1ll;            if(dis[to] &gt; dis[now] + ww)            &#123;                dis[to] &#x3D; dis[now] + ww;                que.push(&#123;dis[to], to&#125;);            &#125;        &#125;    &#125;    printf(&quot;%lld\n&quot;,dis[t]);&#125;void solve()&#123;    tot &#x3D; 0;    scanf(&quot;%d&quot;,&amp;n);    &#x2F;&#x2F; cin &gt;&gt; n;    mxdep &#x3D; 0;    for(int i &#x3D; 1;i &lt;&#x3D; n + n + n + 10;++i) head[i] &#x3D; 0;    for (int i &#x3D; 1, u, v, w; i &lt;&#x3D; n - 1;++i)    &#123;        scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);        &#x2F;&#x2F; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;        add(u,v,w);        add(v,u,w);    &#125;    dfs(1, 0);    scanf(&quot;%d %d&quot;,&amp;k,&amp;p);    scanf(&quot;%d %d&quot;,&amp;s,&amp;t);    for (int i &#x3D; 1; i &lt;&#x3D; n;++i)    &#123;        add(i,dep[i] + n,0);        add(dep[i] + n + n,i,0);    &#125;    for (int l &#x3D; 1; l &lt;&#x3D; n;++l)    &#123;        int r &#x3D; l + k;        if(r &gt; mxdep)            break;        add(l + n,r + n + n,p);        add(r + n + n,l + n,p);    &#125;    dij();&#125;signed main()&#123;    ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);    int T;    scanf(&quot;%d&quot;, &amp;T);    &#x2F;&#x2F; cin &gt;&gt; T;    while(T--)    &#123;        solve();    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Ela-and-the-Wiring-Wizard"><a href="#Ela-and-the-Wiring-Wizard" class="headerlink" title="Ela and the Wiring Wizard"></a>Ela and the Wiring Wizard</h2><p><a href="https://codeforces.com/contest/1737/problem/D">https://codeforces.com/contest/1737/problem/D</a></p><p><strong>题目大意:</strong> 给定一张图，图有$n$个点$m$条边$(2 \leq n \leq 500,n - 1\leq m \leq 100000)$每次可以进行若干次操作，操作如下所示</p><p>选择两条边$(u,v)$和$(v,w)$删除$(u,v)$然后连接$(u,w)$，代价是$(u,v)$的边权</p><p>问从节点$1$到节点$n$最少需要多少次</p><p><strong>解题思路:</strong> 刚开始拿到题目的时候发现没有任何思路，模拟样例可以发现一个性质，就是无论最后怎么样，最后只有一条从$1$到$n$的边使用</p><p>那么我们可以提出猜想，是否从$1$到$n$只需要连接一条路呢？</p><p>接下来的部分参考了$pzr$佬的</p><p>我们可以做出反证感性理解一下，假设我们有多条路到$n$，其中分别是$1 -&gt; u_1 -&gt; u_2 -&gt; n$,设$u_1 -&gt;u_2$的距离是$w_1$，另外一条从$1 -&gt; u_1$权值是$w_2$</p><p>首先就放着这两条边，边权是$w_1 + w_2$</p><p>如果让我们把所有的边都变成$w_1$,那么就是$2w_1$</p><p>或者我们把所有边变成$w_2$，那么就是$2w_2$</p><p>那么进行修改后我们总能贪心取到最小的</p><p>分析样例之后，我们发现建边有成自环和非自环的情况</p><p>分析非自环的情况，那么对于一条边来说，就是去修改$dis(1,u) + dis(v,n)$的次数然后再加上$1$次走到的贡献</p><p>那么接下来考虑自环的情况，如果有自环的话最多可能存在几个自环呢？</p><p>我们可以把自环看成是一个点，设自环点是$x$,那么我们额外花费一个贡献连接$x$,从$1$到$x$再从$x$到$n$的距离相加然后乘贡献，这个$x$相当于中间的一个断点去更新整张图，因此实际上最多也就只有一个</p><p>那么对于这一种题目来说，分析完整道题目我们发现都是对<strong>边</strong> 这一个元素进行考虑</p><p>因为从一开始我们就在思考，从得出结论开始，再到实际上我去取哪条边最优</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define int long longtypedef long long ll;const int maxn &#x3D; 1e3 + 10;const int inf &#x3D; 1e9;int dis[maxn][maxn],n,m;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);int T;cin &gt;&gt; T;while(T--)&#123;cin &gt;&gt; n &gt;&gt; m;vector&lt;array&lt;int,3&gt;&gt; edge;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;dis[i][j] &#x3D; inf;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) dis[i][i] &#x3D; 0;for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;edge.push_back(&#123;u,v,w&#125;);dis[u][v] &#x3D; dis[v][u] &#x3D; 1;&#125;for(int k &#x3D; 1;k &lt;&#x3D; n;++k)&#123;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;chkmin(dis[i][j],dis[i][k] + dis[k][j]);&#125;&#125;&#125;int ans &#x3D; 1e18;for(auto [u,v,w]:edge)&#123;chkmin(ans,(dis[1][u] + 1 + dis[v][n]) * w);chkmin(ans,(dis[1][v] + dis[u][n] + 1) * w);for(int x &#x3D; 1;x &lt;&#x3D; n;++x)&#123;chkmin(ans,(min(dis[u][x],dis[v][x]) + dis[1][x] + dis[x][n] + 2) * w);&#125;&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Session-in-BSU"><a href="#Session-in-BSU" class="headerlink" title="Session in BSU"></a>Session in BSU</h2><p><a href="https://codeforces.com/problemset/problem/1027/F">Problem - 1027F - Codeforces</a></p><p><strong>题目大意:</strong> 给定$n(1 \leq n \leq 10 ^ 6)$场比赛，每场比赛有两个数字$a_i,b_i(1 \leq a_i ,b_i \leq 10 ^ 9)$ 代表可以在第几天考试，问最早可以在哪一天结束比赛，如果无法结束比赛输出$-1$</p><p><strong>解题思路:</strong> 首先如果我们不看这个数据范围的话，那么是不是实际上可以一眼网络流，建立每个考试点和对应的天数点，跑最大流即可。但是观察一下数据范围实际上很大，那么我们就不能直接跑网络流，不过既然一眼网络流我们可以往建图这一个方向去思考这个问题。假设我对每场考试连一条边，那么是不是就代表着一件事情:我这一条边可以选择这两个点中的任意一个时间。那么整张图是不是就是一个森林了。然后我们来考虑一下每个连通块有什么性质，对于每个连通块中，我们都要让这个连通块的边数(考试场数) 小于等于点数(选择考试的天数)，那么对于每一个连通块中，我们假设边数是$num$,我们是不是选择第$num$大的天数就是这个连通块的答案</p><p>但是实际写起来之后发现这样子直接写会出现一些奇怪的问题，那么我们可以在思考刚刚形成的连通块是什么样子的，因为边数要小于等于点数，所以要么是一颗树，要么是一棵基环树，那么对于这两个来说我们只需要记录一个最大值和次大值即可，对于连通块是树的话输出次大值，基环树的输出最大值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;const int maxn &#x3D; 4e6 + 10;int f[maxn],n,m,edgenum[maxn],sz[maxn],ansmx2[maxn],ansmx[maxn],val[maxn],cnt;int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;pair&lt;int,int&gt; edge[maxn];signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; m;for(int i &#x3D; 1,u,v;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v;edge[i] &#x3D; &#123;u,v&#125;;val[++cnt] &#x3D; u,val[++cnt] &#x3D; v;&#125;sort(val + 1,val + 1 + cnt);n &#x3D; unique(val + 1,val + 1 + cnt) - (val + 1);for(int i &#x3D; 1;i &lt;&#x3D; n;++i) f[i] &#x3D; i,sz[i] &#x3D; 1,edgenum[i] &#x3D; 0,ansmx[i] &#x3D; i;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;auto [u,v] &#x3D; edge[i];u &#x3D; lower_bound(val + 1,val + 1 + n,u) - val;v &#x3D; lower_bound(val + 1,val + 1 + n,v) - val;int fu &#x3D; getf(u);int fv &#x3D; getf(v);if(fu &#x3D;&#x3D; fv)&#123;edgenum[fu]++;&#125;else&#123;f[fu] &#x3D; fv;sz[fv] +&#x3D; sz[fu];edgenum[fv] +&#x3D; edgenum[fu] + 1;vector&lt;int&gt; ha;ha.push_back(ansmx2[fu]);ha.push_back(ansmx[fu]);ha.push_back(ansmx2[fv]);ha.push_back(ansmx[fv]);sort(ha.begin(),ha.end());ansmx[fv] &#x3D; ha[3];ansmx2[fv] &#x3D; ha[2];&#125;&#125;int f &#x3D; 1;int res &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int fi &#x3D; getf(i);if(i &#x3D;&#x3D; fi)&#123;if(sz[i] &lt; edgenum[i])&#123; f &#x3D; 0;break;&#125;if(edgenum[i] &#x3D;&#x3D; sz[i]) chkmax(res,val[ansmx[i]]);else chkmax(res,val[ansmx2[i]]);&#125;&#125;if(!f)&#123;cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;return 0;&#125;cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Moment-of-Bloom"><a href="#Moment-of-Bloom" class="headerlink" title="Moment of Bloom"></a>Moment of Bloom</h2><p><a href="https://codeforces.com/problemset/problem/1583/E">Problem - 1583E - Codeforces</a></p><p><strong>题目大意:</strong> 给定一个点数为$n$，边数为$m$的图$(1 \leq n,m \leq 3*10^5)$,初始所有点的点权为$0$。给定$q$次操作，每次操作给定两个点，你可以选择图上这两个点中任意一条简单路径，并且给这一条简单路径上面所有的点权加$1$，问经过$q$次操作这张图所有点的点权是否都是偶数，如果是的话输出$Y!ES$并且输出每次操作应该怎么操作，否则输出$N!O$并且输出最少还需要加几条边，特别注意的是$nq \leq 3 * 10^5$</p><p><strong>解题思路:</strong> 首先遇到这样子的问题在一张图上面会很棘手，因为两个点之间可能有很多的路径，那么既然这样，我们先尝试简化一下这个问题。如果我们把这一个问题放在一棵树上面，那么两点之间的路径是不是就已经确定了。既然这样，什么时候会出现不行的情况呢？我们每次可以对路径的两个端点增加一个值，如果最后在这一棵树上面存在点的点权是奇数，那么是肯定输出$NO$的。然后由于点是成对出现的，那么点也会是成对落单的，我们记录奇数个数的点为$num$个，那么最后需要的边数就是$\frac{num}{2}$个</p><p>然后对于原题来说我们已经把题目化成在树上面了，那么我们直接在树上类似$LCA$找祖先结点沿路径输出即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;const int maxn &#x3D; 3e5 + 10;struct graph&#123;vector&lt;int&gt; edge[maxn];inline void add(int u,int v)&#123;edge[u].push_back(v);edge[v].push_back(u);&#125;&#125;g1,g2;int n,m,deg[maxn];pair&lt;int,int&gt; op[maxn];int f[maxn],p[maxn],dep[maxn];int getf(int x)&#123;return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);&#125;void dfs(int s,int fa)&#123;dep[s] &#x3D; dep[fa] + 1;p[s] &#x3D; fa;for(auto to:g2.edge[s])&#123;if(to &#x3D;&#x3D; fa) continue;dfs(to,s);&#125;&#125;signed main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;for(int i &#x3D; 1,u,v;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v;g1.add(u,v);&#125;int q;cin &gt;&gt; q;for(int i &#x3D; 1;i &lt;&#x3D; q;++i) cin &gt;&gt; op[i].first &gt;&gt; op[i].second,deg[op[i].first]++,deg[op[i].second]++;int ct &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;ct +&#x3D; (deg[i] &amp; 1);&#125;if(ct)&#123;cout &lt;&lt; &quot;NO\n&quot;;cout &lt;&lt; ct &#x2F; 2 &lt;&lt; &quot;\n&quot;;return 0;&#125;cout &lt;&lt; &quot;YES\n&quot;;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) f[i] &#x3D; i;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(auto to:g1.edge[i])&#123;int fx &#x3D; getf(i);int fy &#x3D; getf(to);if(fx &#x3D;&#x3D; fy) continue;f[fy] &#x3D; fx;g2.add(i,to);&#125;&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;?? &quot; &lt;&lt; &quot;\n&quot;;dfs(1,0);for(int i &#x3D; 1;i &lt;&#x3D; q;++i)&#123;auto [u,v] &#x3D; op[i];vector&lt;int&gt; now;vector&lt;int&gt; now2;&#x2F;&#x2F; cout &lt;&lt; &quot;?? ? &quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot;\n&quot;;while(dep[u] !&#x3D; dep[v])&#123;if(dep[u] &gt; dep[v]) now.push_back(u),u &#x3D; p[u];else now2.push_back(v),v &#x3D; p[v];&#125;while(u !&#x3D; v)&#123;now.push_back(u);now2.push_back(v);u &#x3D; p[u];v &#x3D; p[v];&#125;reverse(now2.begin(),now2.end());now.push_back(u);for(auto to:now2)&#123;now.push_back(to);&#125;cout &lt;&lt; now.size() &lt;&lt; &quot;\n&quot;;for(auto to:now)&#123;cout &lt;&lt; to &lt;&lt; &quot; &quot;;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Factory-Balls"><a href="#Factory-Balls" class="headerlink" title="Factory Balls"></a>Factory Balls</h2><p><a href="https://codeforces.com/gym/103855/problem/A">Problem - A - Codeforces</a></p><p>**题目大意: ** 给定一个球，球被划分成为$n$个区域，然后有$k$种颜色的油漆桶，有$m$个装备，球的每个区域在初始状态都是$1$</p><p>接下来可以进行以下三种操作若干次，一种是将这个球放入油漆桶里面，这个球没有被装备安装的部分全部会感染上这个颜色，一种是在这个球上面安装一个装备，一种是给这个球脱下一种装备</p><p>问这个球的区域是否可以达到给定的目标状态，如果可以的话输出最小的步数，否则输出$-1$</p><p>特别的是$1 \leq n,m,k \leq 10$</p><p><strong>解题思路:</strong>  首先考虑数据范围，因为我们的数据范围实际上其实很小，那么我们可以进行状压来表示 <strong>当前的状态</strong> 和 <strong>目标状态</strong> 是否一致，如果一致是$1$否则就是$0$ 。然后我们就这样子$BFS$，我们进行搜索的时候的状态可以以当前的颜色和目标的颜色的差别以及装备的数目和种类，然后我们思考，当前状态更新一步的操作要么是去不变颜色更新装备状态，不变状态更新装备颜色，然后搜索即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;const int maxn &#x3D; 1111;const int inf &#x3D; 1e9 + 7;int n,k,m;int col[maxn],vis[maxn];vector&lt;int&gt; equ[maxn];int dis[maxn][maxn];int main()&#123;&#x2F;&#x2F; ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; col[i];int s &#x3D; 0;for(int i &#x3D; 0,num;i &lt; m;++i)&#123;cin &gt;&gt; num;for(int j &#x3D; 1,x;j &lt;&#x3D; num;++j)&#123;cin &gt;&gt; x;equ[i].push_back(x);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(col[i] &#x3D;&#x3D; 1)&#123;s |&#x3D; (1 &lt;&lt; (i - 1));&#125;&#125;queue&lt;pair&lt;int,int&gt;&gt; que;memset(dis,0x3f,sizeof dis);&#x2F;&#x2F; cout &lt;&lt; &quot;?1&quot; &lt;&lt; dis[s][0] &lt;&lt; &quot;??\n&quot;;dis[s][0] &#x3D; 0;que.push(&#123;s,0&#125;);while(!que.empty())&#123;auto [nowcol,nowequ] &#x3D; que.front();que.pop();&#x2F;&#x2F; cout &lt;&lt; &quot;-----------------------------\n&quot;;&#x2F;&#x2F; cout &lt;&lt; &quot;now -&gt; &quot; &lt;&lt; nowcol &lt;&lt; &quot; &quot; &lt;&lt; nowequ &lt;&lt; &quot;\n&quot;;for(int i &#x3D; 0;i &lt; m;++i)&#123;auto toequ &#x3D; nowequ ^ (1 &lt;&lt; i);if(dis[nowcol][toequ] &gt; dis[nowcol][nowequ] + 1)&#123;dis[nowcol][toequ] &#x3D; dis[nowcol][nowequ] + 1;que.push(&#123;nowcol,toequ&#125;);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i) vis[i] &#x3D; 0;for(int i &#x3D; 0;i &lt; m;++i)&#123;if(nowequ &gt;&gt; i &amp; 1)&#123;for(auto to:equ[i])&#123;vis[to] &#x3D; 1;&#125;&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;int tocol &#x3D; nowcol;for(int j &#x3D; 1;j &lt;&#x3D; n;++j)&#123;if(vis[j]) continue;if(col[j] &#x3D;&#x3D; i)&#123;tocol |&#x3D; (1 &lt;&lt; (j - 1));&#125;else&#123;if(tocol &gt;&gt; (j - 1) &amp; 1)&#123;tocol ^&#x3D; (1 &lt;&lt; (j - 1));&#125;&#125;&#125;&#x2F;&#x2F; cout &lt;&lt; i &lt;&lt; &quot; tocol ?? &quot; &lt;&lt; tocol &lt;&lt; &quot;\n&quot;;if(dis[tocol][nowequ]  &gt; dis[nowcol][nowequ] + 1)&#123;dis[tocol][nowequ] &#x3D; dis[nowcol][nowequ] + 1;que.push(&#123;tocol,nowequ&#125;);&#125;&#125;&#125;&#x2F;&#x2F; cout &lt;&lt; (1 &lt;&lt; (m)) - 1 &lt;&lt; &quot; &quot; &lt;&lt; dis[7][0] &lt;&lt; &quot; ??\n&quot;;if(dis[(1 &lt;&lt; (n)) - 1][0] &gt;&#x3D; inf) cout &lt;&lt; -1 &lt;&lt; &quot;\n&quot;;else cout &lt;&lt; dis[(1 &lt;&lt; (n)) - 1][0] &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flow</title>
      <link href="/2022/09/29/Flow/"/>
      <url>/2022/09/29/Flow/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>网络流时间复杂度大约为$O(n^2m)$</p><p>不过也比较玄学罢了</p><p>将一张图建完之后直接跑$dinic$即可</p><p>接下来有封装之后的版本</p><p>注意这个封装版本的最大流应该有以下的特征：</p><ul><li><p>首先最大流这个点我们是从$1$开始的，因此我们在设置对应的起点和终点的时候，应该注意设置</p></li><li><p>其次是边的标号，因为是从$0$开始的</p></li><li><p>所以我们每次开始的边其实都是$etot$</p></li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 1210;const int E &#x3D; 121000;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;        etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,m,s,t;FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;g.init(s,t,n);for(int i &#x3D; 1,u,v,w;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;g.addedge(u,v,w);&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="方案分配"><a href="#方案分配" class="headerlink" title="方案分配"></a>方案分配</h3><p>方案分配实际上我们可以思考他的<strong>流量</strong>和之前的关系，然后我们判断这个<strong>流量</strong>来输出方案</p><p>题目条件可以是类似于这样子的，给定一些试题类型，其中再给定一些试题，我每个试题是属于不同的试题类型的，求是否可以分配，并且输出方案</p><p>那么其实我们对应的解决方案是把相对应的东西放到一个$vector$中，然后去判断对应的边的流量即可</p><h4 id="P2763"><a href="#P2763" class="headerlink" title="P2763"></a>P2763</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 1210;const int E &#x3D; 121000;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;        etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,k,s,t;FlowGraph&lt;ll&gt; g;struct node&#123;int st,num,id;&#125;;vector&lt;int&gt; prob[100];int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; k &gt;&gt; n;s &#x3D; n + k + 1;t &#x3D; n + k + 2;g.init(s,t,t + 10);int sum &#x3D; 0;for(int i &#x3D; 1,x;i &lt;&#x3D; k;++i)&#123;&#x2F;&#x2F;1 -&gt; typecin &gt;&gt; x;sum +&#x3D; x;g.addedge(s,i,x);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;sum -&gt; &quot; &lt;&lt; sum &lt;&lt; &quot;\n&quot;;vector&lt;node&gt; used;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;&#x2F;&#x2F;type + 1 -&gt; type + nint num;cin &gt;&gt; num;for(int j &#x3D; 1,bel;j &lt;&#x3D; num;++j)&#123;cin &gt;&gt; bel;used.push_back(&#123;bel,i,g.etot&#125;);g.addedge(bel,k + i,1);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;g.addedge(k + i,t,1);&#125;&#x2F;&#x2F; cout &lt;&lt; &quot;??\n&quot;;ll namomo &#x3D; g.dinic();if(namomo !&#x3D; sum)&#123;cout &lt;&lt; &quot;\n&quot;;&#125;else&#123;for(auto now:used)&#123;int idd &#x3D; now.id;if(g.e[idd].f &#x3D;&#x3D; 0)&#123;prob[now.st].push_back(now.num);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; k;++i)&#123;cout &lt;&lt; i &lt;&lt; &quot;:&quot;;for(auto to:prob[i])&#123;cout &lt;&lt; &quot; &quot; &lt;&lt; to;&#125;cout &lt;&lt; &quot;\n&quot;;&#125;&#125;return 0;&#125;&#x2F;*属于是最大流的方案分配问题，首先显而易见我们可以通过这一条边的流量去判断这个边是否被用过来判断是否属于这一个方案当中那么我们可以这样子，因为我们是把试题库和相对应的试题连接在一起ok，那么这样子我们在建边的时候我们可以把相对应的边的号给放到一个vector里面然后后续我们去检查这个边的流量是否为1即可*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="路径模型"><a href="#路径模型" class="headerlink" title="路径模型"></a>路径模型</h3><p>比如说一个序列，如果可以从$a_i$ 到$a_j$有一条路径，实际上我们也可以映射到一张图上面去考虑，因为我们在做最大流的过程中实际上就是在走一些流的路径</p><p>然后对于一些<strong>流量限制</strong>的情况下我们可以采用<strong>拆点</strong>的方法去限制流量</p><h4 id="P2776"><a href="#P2776" class="headerlink" title="P2776"></a>P2776</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 101210;const int E &#x3D; 1210000;const int maxn &#x3D; 5e2 + 10;template&lt;typename T&gt;struct FlowGraph&#123;int s,t,vtot;int head[V],etot;int dis[V],cur[V];struct edge&#123;int v,nxt;T f;&#125;e[E * 2];void addedge(int u,int v,T f)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],0&#125;; head[v] &#x3D; etot++;&#125;bool bfs()&#123;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i)&#123;dis[i] &#x3D; 0;cur[i] &#x3D; head[i];&#125;queue&lt;int&gt; q;q.push(s);dis[s] &#x3D; 1;while(!q.empty())&#123;int u &#x3D; q.front();q.pop();for(int i &#x3D; head[u];~i;i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; !dis[e[i].v])&#123;int v &#x3D; e[i].v;dis[v] &#x3D; dis[u] + 1;if(v &#x3D;&#x3D; t) return true;q.push(v);&#125;&#125;&#125;return false;&#125;T dfs(int u,T m)&#123;if(u &#x3D;&#x3D; t) return m;T flow &#x3D; 0;for(int i &#x3D; cur[u];~i;cur[u] &#x3D; i &#x3D; e[i].nxt)&#123;if(e[i].f &amp;&amp; dis[e[i].v] &#x3D;&#x3D; dis[u] + 1)&#123;T f &#x3D; dfs(e[i].v,min(e[i].f,m));e[i].f -&#x3D; f;e[i ^ 1].f +&#x3D; f;m -&#x3D; f;flow +&#x3D; f;if(!m) break;&#125;&#125;if(!flow) dis[u] &#x3D; -1;return flow;&#125;T dinic()&#123;T flow &#x3D; 0;while(bfs()) flow +&#x3D; dfs(s,numeric_limits&lt;T&gt;::max());return flow;&#125;void init(int s_,int t_,int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; vtot;++i) head[i] &#x3D; -1;&#125;&#125;;int n,m,s,t;int a[maxn],dp[maxn];FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];dp[i] &#x3D; 1;&#125;int ans &#x3D; 1;for(int i &#x3D; 2;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt; i;++j)&#123;if(a[i] &gt;&#x3D; a[j])&#123;dp[i] &#x3D; max(dp[i],dp[j] + 1);&#125;&#125;ans &#x3D; max(ans,dp[i]);&#125;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;s &#x3D; 2 * n + 1;t &#x3D; 2 * n + 2;g.init(s,t,t);for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(dp[i] &#x3D;&#x3D; 1) g.addedge(s,i,n);&#x2F;&#x2F;添加流量为inf的边if(dp[i] &#x3D;&#x3D; ans) g.addedge(i + n,t,n);g.addedge(i,i + n,1);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(a[j] &gt;&#x3D; a[i] &amp;&amp; dp[j] &#x3D;&#x3D; dp[i] + 1)&#123;g.addedge(i + n,j,1);&#125;&#125;&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;g.init(s,t,t);for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(dp[i] &#x3D;&#x3D; 1) g.addedge(s,i,n);&#x2F;&#x2F;添加流量为inf的边if(dp[i] &#x3D;&#x3D; ans) g.addedge(i + n,t,n);if(ans &#x3D;&#x3D; 1) g.addedge(i,i + n,1);else g.addedge(i,i + n,n);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)&#123;if(a[j] &gt;&#x3D; a[i] &amp;&amp; dp[j] &#x3D;&#x3D; dp[i] + 1)&#123;g.addedge(i + n,j,1);&#125;&#125;&#125;cout &lt;&lt; g.dinic() &lt;&lt; &quot;\n&quot;;&#125;&#x2F;*题目大意：给定一个序列，需要解决如下的三个问题1.求这个序列的最长非递减子序列2.每个元素只能使用一次的情况下序列的最长非递减子序列3.每个元素使用多次的情况下序列的最长非递减子序列建图思路:首先对于第一个问题来说我们直接dp即可对于第二个问题，我们需要思考以下我们的建图方向因为只需要求方案数目，那么我们可以进行这样子的建图，我们可以从s-&gt;dp &#x3D; 1的值建一条边我们也可以从dp &#x3D; ans -&gt; t建一条边因为在第一种情况我们只考虑每一个点使用一个那么我们可以使用拆点拆点是为了加一个限制只能流一个1然后因为我们要找第j个数字可能从哪个第i个数字转移过来 那么我们继续找重新建边即可对于第三个问题 实际上我一个点可以使用多次了那么我们先特判考虑最后答案是1的情况 其实实际上下面两个问题的答案就是n然后我们再考虑一个可以使用多次 那么我们拆店的时候对于多个点建n就可以了*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小割"><a href="#最小割" class="headerlink" title="最小割"></a>最小割</h2><p><strong>概念:</strong> 给定一张图，删除一些边使得$s$和$t$不连通</p><p>那么其实就是对于每一个点，我去将点划分为两个集合，每一个点要么属于$s$集合，要么属于$t$集合</p><p>那么对于这里割边来说，实际上就是找一条边，对于他的两个端点$u$和$v$，两个点分别属于一个集合</p><p>最小割 $\geq$ 最大流</p><p>接下来我们分析一下建边的过程</p><p>对于无向图建立割边，实际上我们不仅要考虑正向边，我们也要考虑反向边，那么对于无向图的建图方式实际上就是建两条相同边权的边</p><p>具体的建边方式如下图所示可以</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void addedge(int u,int v,T f,T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v,head[u],f&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u,head[v],f2&#125;; head[v] &#x3D; etot++;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么有向图的话实际上还是和之前的类似，我去建一条长度为$c$的边，另外一条是长度为$0$的边</p><p>如何在实际题目中去思考到 <strong>最小割</strong> 这个东西呢？</p><h3 id="最大权独立集"><a href="#最大权独立集" class="headerlink" title="最大权独立集"></a>最大权独立集</h3><p>首先我们可以考虑引入这样子的一个问题</p><p>假设我们有两个集合(假设为一个黑子集合和一个白子集合)，每个集合都有$n$个点，每个点都有一个点权，如果我们取了一些黑子那么我们就不能取白子，要求我们最后取得的权值<strong>最大</strong> ，对于这一个问题我们如何解答呢？</p><p>我们可以考虑这样子的一个解题方向，我们最后的集合一定是分为两个集合，一个集合是取到的棋子，另外一个集合是没有取到的集合。</p><p>那么分为两个集合的操作是不是就是一个求最小割的过程呢？我们只需要把两个集合分别和$S$和$T$集合连边就可以，然后接下来相对应连边的权值就是他们的点权，然后点之间的限制因为无法切割我们可以采用$inf$</p><p>那么其实对应的如果是二维棋盘我们也可以通过这样子的操作</p><h4 id="P2774"><a href="#P2774" class="headerlink" title="P2774"></a>P2774</h4><p>方格取数，每个方格有一定权值，可以取若干个方格，方格之间不能有相互重叠的边</p><p>本质上也就是求一个最大权独立集的问题，行列相对应建边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const ll inf &#x3D; (1ll &lt;&lt; 60);int n,m,s,t,x;FlowGraph&lt;ll&gt; g;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;s &#x3D; n * m + 1;t &#x3D; n * m + 2;g.init(s,t,t);ll ans &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;cin &gt;&gt; x;ans +&#x3D; x;int id &#x3D; (i - 1) * m + j;if((i + j) % 2 &#x3D;&#x3D; 1) &#123;g.addedge(s,id,x);if(i - 1 &gt;&#x3D; 1) g.addedge(id,id - m,inf);if(i + 1 &lt;&#x3D; n) g.addedge(id,id + m,inf);if(j + 1 &lt;&#x3D; m) g.addedge(id,id + 1,inf);if(j - 1 &gt;&#x3D; 1) g.addedge(id,id - 1,inf);&#125;else g.addedge(id,t,x);&#125;&#125;cout &lt;&lt; ans - g.dinic() &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h3><p>最大权闭合子图的定义实际上就是我每个点有一定的点权，选定一些点需要使得点权和最大，然后如果我选了一个点我是必须需要选定其他后继点的，然后我们来求这张图最多获得多少的点权</p><p>其实这个也是最小割的一种模型，那么实际上和最大权独立集的本质是一样的，我给$s$和$t$集合一定的意义，然后我去进行相应的连边。</p><p>考虑这样的一件事情，因为我们在求最小割的过程中实际上是求在$S$集合中的最小割，那么实际上也就是我们把一些东西放到了$S$集合上面。</p><p>那么之前我们说了边的方案如何选择，那么如何去进行选择点的方案呢？</p><p>那么我们可以去看$dis$数组里面的东西，因为$dis$刚开始都是$0$的，对于放在$S$集合里面的东西我们都应该选择$dis$不为$0$的点即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n,m,s,t;FlowGraph&lt;ll&gt; g;string str;const ll inf &#x3D; (1ll &lt;&lt; 60);int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; m &gt;&gt; n;s &#x3D; m + n + 1;t &#x3D; m + n + 2;g.init(s,t,t);ll ans &#x3D; 0;getline(cin,str);for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;getline(cin,str);stringstream ss;ss &lt;&lt; str;&#x2F;&#x2F; cout &lt;&lt; &quot;str -&gt; &quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;;int x;ss &gt;&gt; x;g.addedge(s,i,x);&#x2F;&#x2F;第i个实验的费用ans +&#x3D; x;while(!ss.eof())&#123;ss &gt;&gt; x;g.addedge(i,x + m,inf);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;int x;cin &gt;&gt; x;g.addedge(i + m,t,x);&#125;ans -&#x3D; g.dinic();vector&lt;int&gt; p1,p2;for(int i &#x3D; 1;i &lt;&#x3D; m;++i)&#123;if(g.dis[i] &gt; 0) p1.push_back(i);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;if(g.dis[i + m] &gt; 0) p2.push_back(i);&#125;for(auto to:p1) cout &lt;&lt; to &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\n&quot;;for(auto to:p2) cout &lt;&lt; to &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\n&quot;;cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 20100;const int E &#x3D; 201000;template&lt;typename T&gt;struct MinCostGraph&#123;int s,t,vtot;int head[V],cur[V],etot;T dis[V],flow,cost;int pre[V];bool vis[V];struct edge&#123;int v,nxt;T f,c;&#125;e[E * 2];void addedge(int u,int v, T f, T c, T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v, head[u], f, c&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u, head[v], f2, -c&#125;; head[v] &#x3D; etot++;&#125;bool spfa()&#123;T inf &#x3D; numeric_limits&lt;T&gt;::max() &#x2F; 2;&#x2F;&#x2F;防止溢出for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i)&#123;dis[i] &#x3D; inf;vis[i] &#x3D; false;pre[i] &#x3D; -1; &#x2F;&#x2F;记录一下上一条边,方便增广&#125;dis[s] &#x3D; 0;vis[s] &#x3D; true;queue&lt;int&gt; q;q.push(s);while(!q.empty())&#123;auto u &#x3D; q.front();for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].nxt)&#123;int v &#x3D; e[i].v;if(e[i].f &amp;&amp; dis[v] &gt; dis[u] + e[i].c)&#123;dis[v] &#x3D; dis[u] + e[i].c;pre[v] &#x3D; i;if(!vis[v])&#123;vis[v] &#x3D; 1;q.push(v);&#125;&#125;&#125;q.pop();vis[u] &#x3D; false;&#125;return dis[t] !&#x3D; inf;&#125;&#x2F;&#x2F;增广void augment()&#123;int u &#x3D; t;T f &#x3D; numeric_limits&lt;T&gt;::max();while(~pre[u])&#123;f &#x3D; min(f, e[pre[u]].f);u &#x3D; e[pre[u] ^ 1].v;&#125;flow +&#x3D; f;cost +&#x3D; f * dis[t];u &#x3D; t;while(~pre[u])&#123;e[pre[u]].f -&#x3D; f;e[pre[u] ^ 1].f +&#x3D; f;u &#x3D; e[pre[u] ^ 1].v;&#125;&#125;pair&lt;T, T&gt; solve()&#123;flow &#x3D; 0;cost &#x3D; 0;while(spfa()) augment();return &#123;flow, cost&#125;;&#125;void init(int s_, int t_, int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i) head[i] &#x3D; -1;&#125;&#125;;MinCostGraph&lt;int&gt; g;int n,m,s,t;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;g.init(s,t,n);for(int i &#x3D; 1,u,v,f,c;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; u &gt;&gt; v &gt;&gt; f &gt;&gt; c;g.addedge(u,v,f,c);&#125;auto ans &#x3D; g.solve();cout &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最大费用最大流"><a href="#最大费用最大流" class="headerlink" title="最大费用最大流"></a>最大费用最大流</h3><p>因为我们考虑这样子的一件事情，我们在求$MCMF$的时候实际上求的是最小的费用那么我们只需要建负边并且最终答案取反就可以了</p><h4 id="P4015"><a href="#P4015" class="headerlink" title="P4015"></a>P4015</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MinCostGraph&lt;ll&gt; g1,g2;int n,m,s,t;int main()&#123;ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);cin &gt;&gt; n &gt;&gt; m;s &#x3D; n + m + 1;t &#x3D; n + m + 2;g1.init(s,t,t);g2.init(s,t,t);for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; x;g1.addedge(s,i,x,0);g2.addedge(s,i,x,0);&#125;for(int i &#x3D; 1,x;i &lt;&#x3D; m;++i)&#123;cin &gt;&gt; x;g1.addedge(i + n,t,x,0);g2.addedge(i + n,t,x,0);&#125;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;for(int j &#x3D; 1;j &lt;&#x3D; m;++j)&#123;int x;cin &gt;&gt; x;g1.addedge(i,j + n,1 &lt;&lt; 30,x);g2.addedge(i,j + n,1 &lt;&lt; 30,-x);&#125;&#125;auto ans1 &#x3D; g1.solve();auto ans2 &#x3D; g2.solve();cout &lt;&lt; ans1.second &lt;&lt; &quot;\n&quot; &lt;&lt; -ans2.second &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="优化建图"><a href="#优化建图" class="headerlink" title="优化建图"></a>优化建图</h3><p><a href="https://codeforces.com/problemset/problem/1525/D">Problem - 1525D - Codeforces</a></p><p><strong>题意:</strong> 给定$n$个座位，每个座位刚开始有两个数字$1$和$0$，题目保证初始给定的$1$的数量少于$0$的数量，将一个$1$移动位置需要$abs(i - j)$的贡献，问让刚开始的$1$全部变成$0$最少需要多少贡献</p><p><strong>解题思路:</strong> 其实刚开始看到题目就想着是裸的费用流，将两种点分在两边，中间连接相对应的边权即可，但是后面发现这样子写的话会有问题。但是考虑反正$1$只会往相邻的$0$移动，那么就相邻的两边建边即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef long long ll;const int V &#x3D; 20100;const int E &#x3D; 521000;template&lt;typename T&gt;struct MinCostGraph&#123;int s,t,vtot;int head[V],cur[V],etot;T dis[V],flow,cost;int pre[V];bool vis[V];struct edge&#123;int v,nxt;T f,c;&#125;e[E * 2];void addedge(int u,int v, T f, T c, T f2 &#x3D; 0)&#123;e[etot] &#x3D; &#123;v, head[u], f, c&#125;; head[u] &#x3D; etot++;e[etot] &#x3D; &#123;u, head[v], f2, -c&#125;; head[v] &#x3D; etot++;&#125;bool spfa()&#123;T inf &#x3D; numeric_limits&lt;T&gt;::max() &#x2F; 2;&#x2F;&#x2F;防止溢出for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i)&#123;dis[i] &#x3D; inf;vis[i] &#x3D; false;pre[i] &#x3D; -1; &#x2F;&#x2F;记录一下上一条边,方便增广&#125;dis[s] &#x3D; 0;vis[s] &#x3D; true;queue&lt;int&gt; q;q.push(s);while(!q.empty())&#123;auto u &#x3D; q.front();for(int i &#x3D; head[u]; ~i; i &#x3D; e[i].nxt)&#123;int v &#x3D; e[i].v;if(e[i].f &amp;&amp; dis[v] &gt; dis[u] + e[i].c)&#123;dis[v] &#x3D; dis[u] + e[i].c;pre[v] &#x3D; i;if(!vis[v])&#123;vis[v] &#x3D; 1;q.push(v);&#125;&#125;&#125;q.pop();vis[u] &#x3D; false;&#125;return dis[t] !&#x3D; inf;&#125;&#x2F;&#x2F;增广void augment()&#123;int u &#x3D; t;T f &#x3D; numeric_limits&lt;T&gt;::max();while(~pre[u])&#123;f &#x3D; min(f, e[pre[u]].f);u &#x3D; e[pre[u] ^ 1].v;&#125;flow +&#x3D; f;cost +&#x3D; f * dis[t];u &#x3D; t;while(~pre[u])&#123;e[pre[u]].f -&#x3D; f;e[pre[u] ^ 1].f +&#x3D; f;u &#x3D; e[pre[u] ^ 1].v;&#125;&#125;pair&lt;T, T&gt; solve()&#123;flow &#x3D; 0;cost &#x3D; 0;while(spfa()) augment();return &#123;flow, cost&#125;;&#125;void init(int s_, int t_, int vtot_)&#123;s &#x3D; s_;t &#x3D; t_;vtot &#x3D; vtot_;etot &#x3D; 0;for(int i &#x3D; 1; i &lt;&#x3D; vtot; ++i) head[i] &#x3D; -1;&#125;&#125;;MinCostGraph&lt;int&gt; g;int n,m,s,t;int a[V];int main()&#123;cin &gt;&gt; n;s &#x3D; n + 1,t &#x3D; n + 2;g.init(s,t,t);vector&lt;int&gt; pos0,pos1;int ct &#x3D; 0;for(int i &#x3D; 1;i &lt;&#x3D; n;++i)&#123;cin &gt;&gt; a[i];if(a[i])&#123;&#x2F;&#x2F; ct++;g.addedge(s,i,1,0);&#125;else&#123;g.addedge(i,t,1,0);&#125;&#125;for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)&#123;g.addedge(i,i + 1,1 &lt;&lt; 30,1);g.addedge(i + 1,i,1 &lt;&lt; 30,1);&#125;auto [f,c] &#x3D; g.solve();cout &lt;&lt; c &lt;&lt; &quot;\n&quot;;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 建图 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
