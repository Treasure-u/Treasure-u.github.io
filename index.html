<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Treasure">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Treasure&#39;s blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-并查集-最小生成树部分题解及代码" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81/" class="article-date">
  <time class="dt-published" datetime="2023-01-04T16:11:17.000Z" itemprop="datePublished">2023-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81/">并查集&amp;最小生成树部分题解及代码</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并查集-amp-最小生成树题解"><a href="#并查集-amp-最小生成树题解" class="headerlink" title="并查集&amp;最小生成树题解"></a>并查集&amp;最小生成树题解</h1><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p><strong>解题思路:</strong> 计算几个连通块，并查集一下即可</p>
<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p><strong>解题思路:</strong> 计算这片连通森林还需要几条边变成一个连通块，那么需要数量就是连通块数量减去$1$</p>
<h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p><strong>解题思路:</strong> 最小生成树模板题</p>
<h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p><strong>解题思路:</strong> $MST$模板题，先加上已经选择的边，再加上没有选择的边即可</p>
<h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2><p><strong>解题思路:</strong> 判断是否只有一个$MST$，那么我们可以先找到一棵$MST$，记录这一棵$MST$的边，然后我们暴力去枚举去掉这条边之后是否还存在一棵和之前权值一样的$MST$</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn &#x3D; 1e5 + 10;
struct node
&#123;
	int x,y,r;
&#125;a[maxn];
int flag[maxn],n,m;
struct DSU
&#123;
	int f[maxn],num;
	int getf(int x)
	&#123;
		return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);
	&#125;
	int merge(int x,int y)
	&#123;
		int fx &#x3D; getf(x);
		int fy &#x3D; getf(y);
		f[fx] &#x3D; fy;
		if(fx !&#x3D; fy)
		&#123;
			num++;
			return 1;
		&#125;
		else return 0;
	&#125;
	void init()
	&#123;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) f[i] &#x3D; i;
		num &#x3D; 0;
	&#125;
&#125;dsu;
struct kruskal
&#123;
	DSU now;
	int nowres;
	void init()
	&#123;
		now.init();
		nowres &#x3D; 0;
	&#125;
&#125;kru;
int cmp(node A,node B)
&#123;
	return A.r &lt; B.r;
&#125;
int main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n &gt;&gt; m;
		dsu.init();
		for(int i &#x3D; 1;i &lt;&#x3D; m;++i)
		&#123;
			cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].r;
			flag[i] &#x3D; 0;
		&#125;
		sort(a + 1,a + 1 + m,cmp);
		int ans &#x3D; 0;
		for(int i &#x3D; 1;i &lt;&#x3D; m;++i)
		&#123;
			if(dsu.merge(a[i].x,a[i].y))
			&#123;
				ans +&#x3D; a[i].r;
				flag[i] &#x3D; 1;
			&#125;
		&#125;
		int f &#x3D; 1;
		for(int i &#x3D; 1;i &lt;&#x3D; m;++i)
		&#123;
			if(!flag[i]) continue;
			kru.init();
			for(int j &#x3D; 1;j &lt;&#x3D; m;++j)
			&#123;
				if(j &#x3D;&#x3D; i) continue;
				if(kru.now.merge(a[j].x,a[j].y))
				&#123;
					kru.nowres +&#x3D; a[j].r;
				&#125;
			&#125;
			if(kru.nowres &#x3D;&#x3D; ans &amp;&amp; kru.now.num &#x3D;&#x3D; n - 1) f &#x3D; 0;
		&#125;
		if(f) cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
		else cout &lt;&lt; &quot;Not Unique!\n&quot;;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2><p><strong>解题思路:</strong> 首先先把免费的边连接起来，然后对$n$个点建立点对，排序之后求最小生成树，直接用$Kruskal$记录边即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;
template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;
#define int long long
const int maxn &#x3D; 1e6 + 10;
int p[maxn][2],tot,n,m;
struct node
&#123;
	int x,y;
	double r;
	node()&#123;&#125;;
	node(int _x,int _y,double _r): x(_x),y(_y),r(_r)&#123;&#125;
&#125;a[maxn];
struct DSU
&#123;
	int f[maxn];
	int getf(int x)
	&#123;
		return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);
	&#125;
	void merge(int x,int y,int op)
	&#123;
		int fx &#x3D; getf(x);
		int fy &#x3D; getf(y);
		if(fx !&#x3D; fy)
		&#123;
			f[fx] &#x3D; fy;
			if(op) cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot;\n&quot;;
		&#125;
	&#125;
	void init()
	&#123;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) f[i] &#x3D; i;
	&#125;
&#125;dsu;
int pow2(int x)
&#123;
	return x * x;
&#125;
double cal(int i,int j)
&#123;
	return sqrt(1.0 * pow2(p[i][0] - p[j][0]) + 1.0 * pow2(p[i][1] - p[j][1]));
&#125;
int cmp(node A,node B)
&#123;
	return A.r &lt; B.r;
&#125;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; n;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		cin &gt;&gt; p[i][0] &gt;&gt; p[i][1];
	&#125;
	cin &gt;&gt; m;
	dsu.init();
	for(int i &#x3D; 1,u,v;i &lt;&#x3D; m;++i)
	&#123;
		cin &gt;&gt; u &gt;&gt; v;
		dsu.merge(u,v,0);
	&#125;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)
		&#123;
			double dis &#x3D; cal(i,j);
			a[++tot] &#x3D; node(i,j,dis);
		&#125;
	&#125;
	sort(a + 1,a + 1 + tot,cmp);
	for(int i &#x3D; 1;i &lt;&#x3D; tot;++i)
	&#123;
		dsu.merge(a[i].x,a[i].y,1);
	&#125;
	return 0;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p><strong>解题思路:</strong> 和上课讲的基本类似，同时需要注意的是这里存在位置固定的问题，如果位置固定的话那么对于他所存在的连通块只会带来$1$的贡献</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define int long long
const int maxn &#x3D; 5e5 + 10;
const int mod &#x3D; 1e9 + 7;
int a[maxn],b[maxn],c[maxn],n;
struct DSU
&#123;
	int f[maxn],sz[maxn];
	int getf(int x)
	&#123;
		return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);
	&#125;
	void merge(int x,int y)
	&#123;
		int fx &#x3D; getf(x);
		int fy &#x3D; getf(y);
		if(fx !&#x3D; fy)
		&#123;
			f[fy] &#x3D; fx;
			sz[fx] +&#x3D; sz[fy];
		&#125;
	&#125;
	void init()
	&#123;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) f[i] &#x3D; i,sz[i] &#x3D; 1;
	&#125;
&#125;dsu;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; b[i];
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; c[i];
		dsu.init();
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			dsu.merge(a[i],b[i]);
		&#125;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			if(c[i])
			&#123;
				dsu.sz[dsu.getf(c[i])] &#x3D; 0;
			&#125;
		&#125;
		int ans &#x3D; 1;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			if(dsu.f[i] &#x3D;&#x3D; i)
			&#123;
				if(dsu.sz[i] &gt;&#x3D; 2) ans &#x3D; ans * 2 % mod;
			&#125;
		&#125;
		cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p><strong>解题思路:</strong> 种族并查集，首先我们先思考如何解决多个种族之间的事情，首先我们先考虑$A$这个位置，因为它可以吃$B$,但是被$C$吃，因此在这里的关系存在的是三种：自己(同族)，食物，敌人。所以我们再开空间的时候可以开$3$倍的空间。</p>
<p>然后我们考虑这样一件事情，假设$a$可以吃$b,c$，那么$b,c$实际上是同族；同理如果$b,c$可以吃$a$，那么$b,c$也是同族。那么也就是说 <strong>敌人的敌人是朋友</strong></p>
<p>那么接下来考虑什么时候不合法，首先是在$x$和$y$合并的时候，如果$x$是$y$的敌人或者$y$是$x$的敌人就不行</p>
<p>然后考虑$x$可以吃$y$的情况下，首先是题目告诉如果相同就不行，然后是如果$x$是$y$的同族或者$y$可以吃$x$不行</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn &#x3D; 1e5 + 10;
&#x2F;&#x2F; const int inf &#x3D; 1e18;
int f[maxn * 3],n,m,ans;
int getf(int x)
&#123;
	return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);
&#125;
void merge(int x,int y)
&#123;
	int fx &#x3D; getf(x);
	int fy &#x3D; getf(y);
	f[fx] &#x3D; fy;
&#125;
signed main()
&#123;
	&#x2F;&#x2F; ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	&#x2F;&#x2F; cin &gt;&gt; n &gt;&gt; m;
	scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
	for(int i &#x3D; 1;i &lt;&#x3D; 3 * n;++i) f[i] &#x3D; i;
	&#x2F;&#x2F;A -&gt; B -&gt; C -&gt; A
	for(int i &#x3D; 1,op,x,y;i &lt;&#x3D; m;++i)
	&#123;
		scanf(&quot;%d %d %d&quot;,&amp;op,&amp;x,&amp;y);
		if(x &gt; n || y &gt; n)
		&#123;
			ans++;
			continue;
		&#125;
		if(op &#x3D;&#x3D; 1)
		&#123;
			if(getf(x) &#x3D;&#x3D; getf(y + 2 * n) || getf(x + 2 * n) &#x3D;&#x3D; getf(y))
			&#123;
				ans++;
			&#125;
			else
			&#123;
				merge(x,y);
				merge(x + n,y + n);
				merge(x + 2 * n,y + 2 * n);
			&#125;
		&#125;
		else
		&#123;
			if(x &#x3D;&#x3D; y)
			&#123;
				ans++;
			&#125;
			else if(getf(x) &#x3D;&#x3D; getf(y) || getf(x + 2 * n) &#x3D;&#x3D; getf(y))
			&#123;
				ans++;
			&#125;
			else
			&#123;
				merge(x,y + 2 * n);
				merge(x + n,y);
				merge(x + 2 * n,y + n);
			&#125;

		&#125;
	&#125;
	printf(&quot;%d\n&quot;,ans);
	return 0;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="I"><a href="#I" class="headerlink" title="I"></a>I</h2><p><strong>解题思路:</strong> 求一个连通块最大是多少，但是由于标号很大所以我们先需要离散化再进行并查集查找即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 1e6 + 10;
int ans,n;
struct DSU
&#123;
	unordered_map&lt;int,int&gt; f;
	unordered_map&lt;int,int&gt; sz;
	int getf(int x)
	&#123;
		return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);
	&#125;
	void merge(int x,int y)
	&#123;
		int fx &#x3D; getf(x);
		int fy &#x3D; getf(y);
		if(fx !&#x3D; fy)
		&#123;
			f[fx] &#x3D; fy;
			sz[fy] +&#x3D; sz[fx];
			ans &#x3D; max(ans,sz[fy]);
		&#125;
	&#125;
	void init()
	&#123;
		f.clear();
		sz.clear();
		ans &#x3D; 0;
	&#125;
&#125;dsu;
array&lt;int,2&gt; p[maxn];
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		dsu.init();
		cin &gt;&gt; n;
		for(int i &#x3D; 1,u,v;i &lt;&#x3D; n;++i)
		&#123;
			cin &gt;&gt; u &gt;&gt; v;
			p[i] &#x3D; &#123;u,v&#125;;
			dsu.f[u] &#x3D; u,dsu.sz[u] &#x3D; 1;
			dsu.f[v] &#x3D; v,dsu.sz[v] &#x3D; 1;
		&#125;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			auto [u,v] &#x3D; p[i];
			dsu.merge(u,v);
		&#125;
		cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><p><strong>题目大意:</strong> 有三个长度为$n$的序列$a,b,c$</p>
<p>$Alice$和$Bob$玩游戏，一共进行$n$个回合，游戏规则如下：</p>
<ul>
<li>选定$a_i,b_i,c_i$</li>
<li>$Alice$从这三个数字选择一个数字删掉</li>
<li>$Bob$从这三个数字选择一个数字</li>
</ul>
<p>我们让$Bob$每回合选择的数字是$d_i$,如果序列$d$是一个排列那么$Alice$获胜否则$Bob$获胜</p>
<p>现在给定$a,b$两个数组，问有多少个$c$数组可以使得$Bob$获胜，结果对$998244353$取模</p>
<p><strong>解题思路:</strong> 首先我们先考虑$Alice$会选择什么数字删掉，假设对于第$i$次操作来说，$a_i &#x3D; b_i$,那么我们可以选择任意的$c_i$并且最终把$c_i$删掉，这样子$Bob$一定取到的是$a_i$这个数字表示的值(因为$a_i &#x3D; b_i$)</p>
<p>然后我们考虑如果$a_i \neq b_i$那么我们选择的$c_i$就非常重要，因为$c_i$决定着我们可以选择$a_i$或者$b_i$中的哪个数字，只需要让$c_i &#x3D; a_i \ or \ c_i &#x3D; b_i$即可</p>
<p>那么选择某一个位置的思路就很清晰了，我们只需要考虑构造大于等于两个相同的并且把其中一个不需要的值删掉即可</p>
<p>接下来我们再考虑位置之间带来的因素</p>
<p>假设我们没有$a_i &#x3D; b_i$的情况，那么我们现在的问题可以转换为给定两个序列分别是$a,b$，每个位置上面取一个看是否可以构成一个排序</p>
<p>对于这一个问题来说，因为每一个位置做一个选择，同时也相同与每一个位置的两个数字相互制衡，那么我们可以用图论的语言来表达，在他们之间建一条边</p>
<p>我们可以发现只有基环树的形式是可以的，而基环树的形式实际上就是点数等于边数</p>
<p>那么我们最终只需要使用并查集取维护每个环中存在点数和边数即可</p>
<p>那么最后再思考答案贡献，对于一个基环树来说，如果这个树里面没有自环，那么贡献就是$2$，因为考虑每条边有两个选择，如果里面有自环的话，贡献就是$n$</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;
template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;
#define int long long
const int maxn &#x3D; 1e6 + 10;
const int mod &#x3D; 998244353;
int n,m,a[maxn],b[maxn];
int f[maxn],szv[maxn],sze[maxn],loop[maxn];
void init()
&#123;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		f[i] &#x3D; i;
		szv[i] &#x3D; 1;
		sze[i] &#x3D; 0;
		loop[i] &#x3D; 0;
	&#125;
&#125;
int getf(int x)
&#123;
	return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);
&#125;
void merge(int x,int y)
&#123;
	int fx &#x3D; getf(x);
	int fy &#x3D; getf(y);
	if(fx !&#x3D; fy)
	&#123;
		f[fy] &#x3D; fx;
		sze[fx] +&#x3D; sze[fy];
		szv[fx] +&#x3D; szv[fy];
		loop[fx] +&#x3D; loop[fy];
	&#125;
&#125;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		init();
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; b[i];
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			merge(a[i],b[i]);
			sze[getf(a[i])]++;
			if(a[i] &#x3D;&#x3D; b[i]) loop[getf(a[i])]++;
		&#125;
		int ans &#x3D; 1;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			if(i &#x3D;&#x3D; getf(i))
			&#123;
				if(sze[i] !&#x3D; szv[i]) ans &#x3D; 0;

                else ans &#x3D; ans * 2 % mod;
			&#125;
		&#125;
		cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81/" data-id="clcisub0b000w5vwl1xt6bfi8" data-title="并查集&amp;最小生成树部分题解及代码" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dsu/" rel="tag">dsu</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mst/" rel="tag">mst</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-pythonbasic" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/03/pythonbasic/" class="article-date">
  <time class="dt-published" datetime="2023-01-03T08:08:13.000Z" itemprop="datePublished">2023-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/03/pythonbasic/">pythonbasic</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Python基础语法和基本数据"><a href="#Python基础语法和基本数据" class="headerlink" title="Python基础语法和基本数据"></a>Python基础语法和基本数据</h1><h2 id="标识符号"><a href="#标识符号" class="headerlink" title="标识符号"></a>标识符号</h2><ul>
<li>第一个字符必须是字母表中字母或下划线 <strong>_</strong> 。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<h2 id="Python保留字"><a href="#Python保留字" class="headerlink" title="Python保留字"></a>Python保留字</h2><p>保留字即关键字，我们不能把它们用作任何标识符名称。$Python$ 的标准库提供了一个 $keyword$ 模块。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> keyword
<span class="token keyword">print</span><span class="token punctuation">(</span>keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>$python$中单行注释以 <strong>#</strong> 开头</p>
<p>多行注释可以用多个 <strong>#</strong> 号，还有 <strong>‘’’</strong> 和 **”””**：</p>
<h2 id="Python多行语句"><a href="#Python多行语句" class="headerlink" title="Python多行语句"></a>Python多行语句</h2><p>$Python$ 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 *<em>*</em> 来实现多行语句，例如:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">total <span class="token operator">=</span> item_one <span class="token operator">+</span> \
        item_two <span class="token operator">+</span> \
        item_three<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>用 <code>**</code> 运算符来计算乘方</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">**</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment">#25</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>在交互模式下，可以用变量 <code>_</code> 表示上一次的值</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>$Python$中单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用完全相同。</p>
</li>
<li><p>使用三引号(<strong>‘’’</strong> 或 <strong>“””</strong>)可以指定一个多行字符串。</p>
</li>
<li><p>按字面意义级联字符串，如 <strong>“this “ “is “ “string”</strong> 会被自动转换为 <strong>this is string</strong>。</p>
</li>
<li><p>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复。</p>
</li>
<li><p>$Python$ 中的字符串有两种索引方式，从左往右以 <strong>0</strong> 开始，从右往左以 <strong>-1</strong> 开始。</p>
</li>
<li><p>$Python$ 中的字符串不能改变。</p>
</li>
<li><p>$Python$ 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p>
</li>
<li><p>字符串的截取的语法格式如下：<strong>变量[头下标:尾下标:步长]</strong></p>
</li>
</ul>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>$Python$中单引号 <code>&#39;</code> 和双引号 <code>&quot;</code>使用完全相同。</p>
<p>反斜杠 <code>\</code> 可以用来转义，或者如果我们想要使用单引号我们外面可以加一个双引号</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is test1'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'this is \' test2'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"this is test '3 "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">this is test1
this is &#39; test2
this is test &#39;3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>注意如果我们不需要使用到转义的话我们可以在字符串前面加一个<code>r</code></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\hahah\tese'</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">r'\hahah\tese'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<pre class="line-numbers language-python" data-language="python"><code class="language-python">\hahah	ese
\hahah\tese<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="跨行连续输入"><a href="#跨行连续输入" class="headerlink" title="跨行连续输入"></a>跨行连续输入</h3><p>使用三引号<code>&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;</code>可以指定一个多行字符串。</p>
<h3 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h3><p>字符串可以用 <strong>+</strong> 运算符连接在一起，用 ***** 运算符重复</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token string">'ha'</span> <span class="token operator">+</span> <span class="token string">'uhuh'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">hahahauhuh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>或者说可以按照字面意思连接字符串，比如相邻多个字符串会自动连接到一起</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'114514'</span><span class="token string">'1919810'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">1145141919810<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>因此我们在输出较长字符串的时候我们可以使用按照字面意思连接的方法来输出</p>
<h3 id="字符串只读"><a href="#字符串只读" class="headerlink" title="字符串只读"></a>字符串只读</h3><p>$python$中的字符串不能被修改，如果我们需要强行修改的话会错掉</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span>
test<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'i'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">Traceback (most recent call last):
  File &quot;e:\Sublime Text\code\codeforces\traing\test.py&quot;, line 2, in &lt;module&gt;
    test[3] &#x3D; &#39;i&#39;
TypeError: &#39;str&#39; object does not support item assignment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>如果需要一个新的字符串我们只能通过新建的方式来，同时我们可以使用$len$来获取字符串的长度</p>
<h3 id="字符串属性"><a href="#字符串属性" class="headerlink" title="字符串属性"></a>字符串属性</h3><pre class="line-numbers language-none"><code class="language-none">文本序列类型 --- str
     字符串是一种 *序列类型* ，因此也支持序列类型的各种操作。

  字符串的方法
     字符串支持许多变换和查找的方法。

  格式化字符串字面值
     内嵌表达式的字符串字面值。

  格式字符串语法
     使用 &quot;str.format()&quot; 进行字符串格式化。

  printf 风格的字符串格式化
     这里详述了使用 &quot;%&quot; 运算符进行字符串格式化。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>字符串是可以被索引 (下标) 访问的，字符串的第一个字母的索引是 $0$</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">t
s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="负索引"><a href="#负索引" class="headerlink" title="负索引"></a>负索引</h3><p>索引使用负数的话说明是从右边往左边开始数，因为我们考虑到0的负数还是本身所以我们从 $-1$开始数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">d
o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>索引可以获得单个字符，切片可以获得一个字符串的字串，切片的形式是$[l:r]$，对于切片来说$l$是被包含在输出的字符串当中但是$r$不会</p>
<p>切片的索引有默认值；省略开始索引时默认为0，省略结束索引时默认为到字符 串的结束:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> test<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">te
stw
testword
tes
ord<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>我们可以发现一个性质就是对于一个字符串来说$s[:i] + s[i:] &#x3D; s$</p>
<h3 id="索引越界"><a href="#索引越界" class="headerlink" title="索引越界"></a>索引越界</h3><p>在我们使用过大的索引的时候会出现以下的错误:</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">114514</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">Traceback (most recent call last):
  File &quot;e:\Sublime Text\code\codeforces\traing\test.py&quot;, line 2, in &lt;module&gt;
    print(test[114514])
IndexError: string index out of range<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是对于切片中的越界索引他会自动去取到相对应的边界</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">test <span class="token operator">=</span> <span class="token string">"testword"</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token number">114514</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>test<span class="token punctuation">[</span><span class="token number">114514</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">stword
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>





<h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p>列表是写在<code>[]</code>之间用有道分隔开的元素列表，和字符串一样列表也可以被索引和截取，列表被截取后返回一个包含所需元素的新列表，注意列表中的元素类型可以不相同</p>
<p>我们可以通过和字符串类似的写法$[a:b:c]$来表示从坐标$a$开始到坐标$b - 1$每次相间隔$c$去一个列表中的元素，特别需要注意的是，当$c &lt; 0$的时候，截取字符是从后往前的，那么我们可以采用如下的写法来进行对一个列表逆序</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
     
    <span class="token comment"># 通过空格将字符串分隔符，把各个单词分隔为列表</span>
    inputWords <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span>
 
    <span class="token comment"># 翻转字符串</span>
    <span class="token comment"># 假设列表 list = [1,2,3,4],  </span>
    <span class="token comment"># list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)</span>
    <span class="token comment"># inputWords[-1::-1] 有三个参数</span>
    <span class="token comment"># 第一个参数 -1 表示最后一个元素</span>
    <span class="token comment"># 第二个参数为空，表示移动到列表末尾</span>
    <span class="token comment"># 第三个参数为步长，-1 表示逆向</span>
    inputWords<span class="token operator">=</span>inputWords<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
 
    <span class="token comment"># 重新组合字符串</span>
    output <span class="token operator">=</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>inputWords<span class="token punctuation">)</span>
     
    <span class="token keyword">return</span> output
 
<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>
    <span class="token builtin">input</span> <span class="token operator">=</span> <span class="token string">'I like runoob'</span>
    rw <span class="token operator">=</span> reverseWords<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>列表还可以通过$append$来添加元素</p>
<h2 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h2><p>缩进相同的一组语句构成一个代码块，我们称之代码组。</p>
<p>像$ if $、$ while $ 、$ def $ 和$ class$ 这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> expression <span class="token punctuation">:</span> 
   suite
<span class="token keyword">elif</span> expression <span class="token punctuation">:</span> 
   suite 
<span class="token keyword">else</span> <span class="token punctuation">:</span> 
   suite<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>







<h3 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h3><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 <strong>()</strong> 里，元素之间用逗号隔开。</p>
<p>元组中的类型也可以不相同</p>
<h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p>集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。</p>
<p>基本功能是进行成员关系测试和删除重复元素。</p>
<p>可以使用大括号 ${ }$ 或者 $set()$ 函数创建集合，注意：创建一个空集合必须用 $set()$ 而不是 ${ }$，因为 ${ }$ 是用来创建一个空字典。</p>
<p>创建格式：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">st <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span>
a <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">"1234567"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"a:"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"st:"</span><span class="token punctuation">,</span>st<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-python" data-language="python"><code class="language-python">a<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">&#125;</span>
st<span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>当然，对于一个已有元素的$set$,如果我们需要往这个里面添加元素的话，我们可以使用$add$函数来进行添加</p>
<p>注意这里的集合是一个 <strong>没有顺序</strong> 的集合</p>
<p>对于集合来说我们通常还需要判断一个集合和另外一个集合之间的关系，那么实际上 $python$也为我们提供了这些方法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">print(a - b)     # a 和 b 的差集

print(a | b)     # a 和 b 的并集

print(a &amp; b)     # a 和 b 的交集

print(a ^ b)     # a 和 b 中不同时存在的元素，即只在一个集合中出现<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">"145296"</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token string">"256789"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">|</span> b<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">&amp;</span> b<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a <span class="token operator">^</span> b<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">&#123;</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#123;</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#123;</span><span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#123;</span><span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'7'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h3><p>字典是一种映射类型，字典用 ${ }$标识，它是一个无序的 键$(key)$ : 值$(value)$ 的集合。</p>
<p>键$(key)$必须使用不可变类型。</p>
<p>在同一个字典中，键$(key)$必须是唯一的。</p>
<p>注意对于字典的构造函数$dict()$也可以直接从键值对序列中构建字典如下</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'Runoob'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Google'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'Taobao'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span><span class="token string">'Runoob'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Google'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">&#125;</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">&#123;</span>x<span class="token punctuation">:</span> x<span class="token operator">**</span><span class="token number">2</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">:</span> <span class="token number">36</span><span class="token punctuation">&#125;</span>
<span class="token operator">>></span><span class="token operator">></span> <span class="token builtin">dict</span><span class="token punctuation">(</span>Runoob<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> Google<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> Taobao<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span><span class="token string">'Runoob'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Google'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Taobao'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h3><p>$python$提供$input()$函数从标准输入中读入一行 <strong>文本</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">str</span> <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h3 id="读取一行中的多个数字"><a href="#读取一行中的多个数字" class="headerlink" title="读取一行中的多个数字"></a>读取一行中的多个数字</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 读取一行中的两个整数</span>
a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token builtin">map</span><span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">,</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h3 id="读取一行中的数字，两个数字类型不一样"><a href="#读取一行中的数字，两个数字类型不一样" class="headerlink" title="读取一行中的数字，两个数字类型不一样"></a>读取一行中的数字，两个数字类型不一样</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 读取一行中的两个数字</span>
a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span>
a <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
b <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="读取一个文件直到末尾"><a href="#读取一个文件直到末尾" class="headerlink" title="读取一个文件直到末尾"></a>读取一个文件直到末尾</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 打开文件</span>
<span class="token keyword">with</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>
    <span class="token comment"># 读取文件的每一行</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>
        <span class="token comment"># 在这里处理每一行的数据</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Python循环语句"><a href="#Python循环语句" class="headerlink" title="Python循环语句"></a>Python循环语句</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>$python$中并不存在$do…while$的语法，因此我们可以直接用$while$来写。</p>
<p>除此之外$python$还存在在一个$while$后面跟着$else$</p>
<p>一般来说是如果我当前的$while$不执行的话那么我就会直接走后面的$else$</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">n <span class="token operator">=</span> <span class="token number">10</span>
now <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> now <span class="token operator">&lt;=</span> n<span class="token punctuation">:</span>
    <span class="token builtin">sum</span> <span class="token operator">+=</span> now
    now <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sum??"</span><span class="token punctuation">,</span><span class="token builtin">sum</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>比如上面的程序就是先去计算$1…10$的和然后跳出循环之后直接输出这个和是多少</p>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>我们需要注意的是，对于$python$来说，$for$循环可以遍历任何可以迭代的对象，比如一个列表或者一个字符串</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">:</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Good number"</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"now number is"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"no good number"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"finish"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于上述程序我们跑出来的结果是</p>
<pre class="line-numbers language-none"><code class="language-none">now number is 1
now number is 2
Good number
finish<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<p>更改成以下内容跑出来的数据相对应的是</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> a<span class="token punctuation">:</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Good number"</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"now number is"</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>
<span class="token keyword">else</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"no good number"</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"finish"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">now number is 1
now number is 2
now number is 7
now number is 4
now number is 5
no good number
finish<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="range函数"><a href="#range函数" class="headerlink" title="range函数"></a>range函数</h4><p>遍历数字序列的时候我们可以使用内置的$range$函数</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>end <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">0 1 2 3 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如何指定区间的话，假设$range(l,r)$，那么我们获得的数字就是从$l$然后一直到$r - 1$</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>end <span class="token operator">=</span> <span class="token string">" "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">5 6 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>当然$range$还具有第三个参数步长，可以通过给这个步长一些指定的参数来进行循环</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token builtin">sum</span> <span class="token operator">+=</span> i
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>比如上述程序就会从$0 - 8$逐个相加</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token builtin">sum</span> <span class="token operator">+=</span> i
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同时我们也可以通过$range$和$len$函数去遍历一个序列的索引</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">666</span><span class="token punctuation">,</span><span class="token number">7777</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-none"><code class="language-none">0 1
1 2
2 3
3 4
4 55
5 666
6 7777<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/03/pythonbasic/" data-id="clcisub0a000u5vwl10yjdnl3" data-title="pythonbasic" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-goodbye2022" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/03/goodbye2022/" class="article-date">
  <time class="dt-published" datetime="2023-01-03T08:06:27.000Z" itemprop="datePublished">2023-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/03/goodbye2022/">goodbye2022</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Good-Bye-2022"><a href="#Good-Bye-2022" class="headerlink" title="Good Bye 2022"></a>Good Bye 2022</h1><h2 id="A-Koxia-and-Whiteboards"><a href="#A-Koxia-and-Whiteboards" class="headerlink" title="A.Koxia and Whiteboards"></a>A.Koxia and Whiteboards</h2><p>**题目大意: ** 给定一个长度为$n$的序列，接下来进行$m$次操作，问操作之后序列值最大是多少</p>
<p><strong>解题思路:</strong> 数量级很小考虑暴力即可，每次把$a$序列中最小的元素换下来</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;
template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;
#define int long long
const int maxn &#x3D; 1e6 + 10;
int n,m,a[maxn],b[maxn];
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n &gt;&gt; m;
		multiset&lt;int&gt; st;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i],st.insert(a[i]);
		for(int i &#x3D; 1;i &lt;&#x3D; m;++i) cin &gt;&gt; b[i];
		for(int i &#x3D; 1;i &lt;&#x3D; m;++i)
		&#123;
			st.erase(st.begin());
			st.insert(b[i]);
		&#125;
		int sum &#x3D; 0;
		for(auto to:st) sum +&#x3D; to;
		cout &lt;&lt; sum &lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="B-Koxia-and-Permutation"><a href="#B-Koxia-and-Permutation" class="headerlink" title="B. Koxia and Permutation"></a>B. Koxia and Permutation</h2><p><strong>题目大意:</strong> 构造一个长度为$n$的序列，进行$n - k + 1$次划分，第$i$次划分获得的是从$i$开始$k$个数字的最大值和最小值相加，一个排列$p$的代价是划分中的值的最大值，问这个最大值最小的序列是什么样的</p>
<p><strong>解题思路:</strong> 因为最后要让我们的最大值最小，考虑值的构成是一个区域内的最大值加上最小值，如果一段区域里面都是连续的大数是肯定不行的，因此我们可以从$1-n$的数字头尾顺序取即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;
template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;
#define int long long
const int maxn &#x3D; 1e6 + 10;
int n,m,a[maxn],b[maxn];
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n &gt;&gt; m;
		vector&lt;int&gt; ans;
		for(int i &#x3D; 1,j &#x3D; n;i &lt; j;++i,--j)
		&#123;
			ans.push_back(j);
			ans.push_back(i);
			&#x2F;&#x2F; cout &lt;&lt; &quot;??? &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;\n&quot;;
		&#125;
		if(n &amp; 1) ans.push_back((n + 1) &#x2F; 2);
		for(auto to:ans)
		&#123;
			cout &lt;&lt; to &lt;&lt; &quot; &quot;;
		&#125;
		cout &lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="C-Koxia-and-Number-Theory"><a href="#C-Koxia-and-Number-Theory" class="headerlink" title="C. Koxia and Number Theory"></a>C. Koxia and Number Theory</h2><p><strong>题目大意:</strong> 给定一个长度为$n$的序列,问是否存在一个$x$使得每一对$gcd(a_i+ x ,a_j + x) &#x3D; 1$</p>
<p><strong>解题思路:</strong> 不懂数学，感觉可以看严格鸽的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;
template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;
#define int long long
const int maxn &#x3D; 1e6 + 10;
int n,m,a[maxn],b[maxn];
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		set&lt;int&gt; st;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i],st.insert(a[i]);
		if(st.size() !&#x3D; n)
		&#123;
			cout &lt;&lt; &quot;No\n&quot;;
			continue;
		&#125;
		int f &#x3D; 1;
		for(int p &#x3D; 2;p &lt;&#x3D; n;++p)
		&#123;
			map&lt;int,int&gt; mp;
			for(int i &#x3D; 1;i &lt;&#x3D; n;++i) mp[a[i] % p]++;
			int mi &#x3D; n + n;
			int ha &#x3D; 0;
			for(auto to:mp)
			&#123;
				if(to.second &gt;&#x3D; 2) ha++;
			&#125;
			if(ha &gt;&#x3D; p) f &#x3D; 0;
		&#125;
		if(f) cout &lt;&lt; &quot;Yes\n&quot;;
		else cout &lt;&lt; &quot;No\n&quot;;

	&#125;
	return 0;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="D-Koxia-and-Game"><a href="#D-Koxia-and-Game" class="headerlink" title="D. Koxia and Game"></a>D. Koxia and Game</h2><p><strong>题目大意:</strong> 有三个长度为$n$的序列$a,b,c$</p>
<p>$Alice$和$Bob$玩游戏，一共进行$n$个回合，游戏规则如下：</p>
<ul>
<li>选定$a_i,b_i,c_i$</li>
<li>$Alice$从这三个数字选择一个数字删掉</li>
<li>$Bob$从这三个数字选择一个数字</li>
</ul>
<p>我们让$Bob$每回合选择的数字是$d_i$,如果序列$d$是一个排列那么$Alice$获胜否则$Bob$获胜</p>
<p>现在给定$a,b$两个数组，问有多少个$c$数组可以使得$Bob$获胜，结果对$998244353$取模</p>
<p><strong>解题思路:</strong> 首先我们先考虑$Alice$会选择什么数字删掉，假设对于第$i$次操作来说，$a_i &#x3D; b_i$,那么我们可以选择任意的$c_i$并且最终把$c_i$删掉，这样子$Bob$一定取到的是$a_i$这个数字表示的值(因为$a_i &#x3D; b_i$)</p>
<p>然后我们考虑如果$a_i \neq b_i$那么我们选择的$c_i$就非常重要，因为$c_i$决定着我们可以选择$a_i$或者$b_i$中的哪个数字，只需要让$c_i &#x3D; a_i \ or \ c_i &#x3D; b_i$即可</p>
<p>那么选择某一个位置的思路就很清晰了，我们只需要考虑构造大于等于两个相同的并且把其中一个不需要的值删掉即可</p>
<p>接下来我们再考虑位置之间带来的因素</p>
<p>假设我们没有$a_i &#x3D; b_i$的情况，那么我们现在的问题可以转换为给定两个序列分别是$a,b$，每个位置上面取一个看是否可以构成一个排序</p>
<p>对于这一个问题来说，因为每一个位置做一个选择，同时也相同与每一个位置的两个数字相互制衡，那么我们可以用图论的语言来表达，在他们之间建一条边</p>
<p>我们可以发现只有基环树的形式是可以的，而基环树的形式实际上就是点数等于边数</p>
<p>那么我们最终只需要使用并查集取维护每个环中存在点数和边数即可</p>
<p>那么最后再思考答案贡献，对于一个基环树来说，如果这个树里面没有自环，那么贡献就是$2$，因为考虑每条边有两个选择，如果里面有自环的话，贡献就是$n$</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;
template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;
#define int long long
const int maxn &#x3D; 1e6 + 10;
const int mod &#x3D; 998244353;
int n,m,a[maxn],b[maxn];
int f[maxn],szv[maxn],sze[maxn],loop[maxn];
void init()
&#123;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		f[i] &#x3D; i;
		szv[i] &#x3D; 1;
		sze[i] &#x3D; 0;
		loop[i] &#x3D; 0;
	&#125;
&#125;
int getf(int x)
&#123;
	return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);
&#125;
void merge(int x,int y)
&#123;
	int fx &#x3D; getf(x);
	int fy &#x3D; getf(y);
	if(fx !&#x3D; fy)
	&#123;
		f[fy] &#x3D; fx;
		sze[fx] +&#x3D; sze[fy];
		szv[fx] +&#x3D; szv[fy];
		loop[fx] +&#x3D; loop[fy];
	&#125;
&#125;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		init();
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; b[i];
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			merge(a[i],b[i]);
			sze[getf(a[i])]++;
			if(a[i] &#x3D;&#x3D; b[i]) loop[getf(a[i])]++;
		&#125;
		int ans &#x3D; 1;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			if(i &#x3D;&#x3D; getf(i))
			&#123;
				if(sze[i] !&#x3D; szv[i]) ans &#x3D; 0;

                else ans &#x3D; ans * 2 % mod;
			&#125;
		&#125;
		cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
	
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/03/goodbye2022/" data-id="clcisub07000p5vwlfyu189vt" data-title="goodbye2022" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cf/" rel="tag">cf</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ICPC-2021-EC-J" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/11/ICPC-2021-EC-J/" class="article-date">
  <time class="dt-published" datetime="2022-11-11T07:35:19.000Z" itemprop="datePublished">2022-11-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/11/ICPC-2021-EC-J/">ICPC-2021-EC-J</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="J-Elden-Ring"><a href="#J-Elden-Ring" class="headerlink" title="J. Elden Ring"></a>J. Elden Ring</h1><p><a target="_blank" rel="noopener" href="https://codeforces.com/gym/103861/problem/J">https://codeforces.com/gym/103861/problem/J</a></p>
<p><strong>题目大意:</strong> 给定一个规模为$2e5$的无向图，每个点除了起始点都有一个怪物在那里，第$i$个点的怪物的战力值为$l_i$，我们初始的战力值为$l_1$</p>
<p>我们可以打败怪物当且仅当我们的战力值比怪物的高。怪物每天的战力值会增加$B$，我们杀掉一只怪物增加的战力值为$A$，问我们是否可以到达最终点</p>
<p><strong>解题思路:</strong> 考虑这道题和别的题目不一样的地方也就是引入了战力值这个概念，首先我们假设我们的战力值永远不会改变，那么起始也就是对于$A &#x3D; B$的这一种情况，我们直接$BFS$，并且看当前这个点的战力值是否比起始点要小，符合条件的那么我们就可以加入相对应的队列即可。</p>
<p>然后我们考虑$A &lt; B$的这一种情况，因为我们的战力值是不断减少的，那么我们仍然可以直接$BFS$去找我们可以到达的点，并且比较到达当前点消耗的数值是否比原来的战力值小即可。</p>
<p>最后我们来分析$A &gt; B$的情况，因为$A &gt; B$，所以我们的战力值是在不断增加的。在不断增加的时候我们实际上是可以开放很多点的，那么对于原来的跑图来说我们处理的要么是本身可以到达的，要么是处理因为一些条件不能到达的，因此对于这一张新图来说我们先跑一遍最短路来处理什么点在这种情况下可以先到达。</p>
<p>对于处理这一张新图来说我们首先先把$1$号节点给放进去，然后我们再跑$dij$，优先队列里面放的是当前点的权值和这个点，维护一个小数字在前面的队列。因为小数字在前面，那么我们可以不断增加自己的战力值，因此最后有可能达到一些权值更大的情况。</p>
<p>然后在跑实际天数的时候我们可以直接跑$dij$，但是这里的话使用的是从$1$号节点到当前这个$now$节点所需要的天数,然后对当前的值进行分析，如果比转移点要小的话直接$+1$即可，否则计算以下从$1$号节点转移过来的权值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn &#x3D; 2e5 + 10;
const ll inf &#x3D; 1e18;
vector&lt;int&gt; edge[maxn];
ll n,m,A,B;
ll dis[maxn],vis[maxn],val[maxn];
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	for(int Case &#x3D; 1;Case &lt;&#x3D; T;++Case)
	&#123;
		cin &gt;&gt; n &gt;&gt; m &gt;&gt; A &gt;&gt; B;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			edge[i].clear();
			dis[i] &#x3D; inf;
			vis[i] &#x3D; 0;
		&#125;
		for(int i &#x3D; 1,u,v;i &lt;&#x3D; m;++i)
		&#123;
			cin &gt;&gt; u &gt;&gt; v;
			edge[u].push_back(v);
			edge[v].push_back(u);
		&#125;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; val[i],val[i] +&#x3D; B;
		val[1] -&#x3D; B;
		if(A &#x3D;&#x3D; B)
		&#123;
			queue&lt;int&gt; que;
			que.push(1);
			dis[1] &#x3D; 0;
			while(!que.empty())
			&#123;
				auto now &#x3D; que.front();
				que.pop();
				for(auto to:edge[now])
				&#123;
					if(val[to] &lt; val[1] &amp;&amp; dis[to] &gt; dis[now])
					&#123;
						que.push(to);
						dis[to] &#x3D; dis[now] + 1;
					&#125;
				&#125;
			&#125;
			cout &lt;&lt; (dis[n] &#x3D;&#x3D; inf ? -1 : dis[n]) &lt;&lt; &quot;\n&quot;;
		&#125;
		else if(A &lt; B)
		&#123;
			queue&lt;int&gt; que;
			que.push(1);
			dis[1] &#x3D; 0;
			while(!que.empty())
			&#123;
				auto now &#x3D; que.front();
				que.pop();
				for(auto to:edge[now])
				&#123;
					if(1ll * val[to] + dis[now] * (B - A) * 1ll &lt; val[1] &amp;&amp; dis[to] &gt; dis[now])
					&#123;
						dis[to] &#x3D; dis[now] + 1;
						que.push(to);
					&#125;
				&#125;
			&#125;
			cout &lt;&lt; (dis[n] &#x3D;&#x3D; inf ? -1 : dis[n]) &lt;&lt; &quot;\n&quot;;
		&#125;
		else
		&#123;
			priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; que;
			int day &#x3D; -1;
			que.push(&#123;0,1&#125;);
			while(!que.empty())
			&#123;
				auto [nowd,now] &#x3D; que.top();
				que.pop();
				if(vis[now]) continue;
				if(day !&#x3D; -1 &amp;&amp; val[now] &gt;&#x3D; val[1] + (A - B) * day)
				&#123;
					break;
				&#125;
				vis[now] &#x3D; 1;
				day++;
				for(auto to:edge[now])
				&#123;
					if(!vis[to]) que.push(&#123;val[to],to&#125;);
				&#125;
			&#125;
			dis[1] &#x3D; 0;
			while(!que.empty()) que.pop();
			que.push(&#123;dis[1],1&#125;);
			while(!que.empty())
			&#123;
				auto [nowd,now] &#x3D; que.top();
				que.pop();
				if(nowd &gt; dis[now]) continue;
				for(auto to:edge[now])
				&#123;
					if(!vis[to]) continue;
					if(val[to] &lt; val[now] &amp;&amp; dis[to] &gt; nowd + 1)
					&#123;
						dis[to] &#x3D; nowd + 1;
						que.push(&#123;dis[to],to&#125;);
						continue;
					&#125;
					if(dis[to] &gt; max(nowd + 1ll,(val[to] - val[1]) &#x2F; (A - B) + 2))
					&#123;
						dis[to] &#x3D; max(nowd + 1ll,(val[to] - val[1]) &#x2F; (A - B) + 2);
						que.push(&#123;dis[to],to&#125;);
					&#125;
				&#125;
			&#125;
			cout &lt;&lt; (dis[n] &#x3D;&#x3D; inf ? -1 : dis[n]) &lt;&lt; &quot;\n&quot;;
		&#125;
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/11/ICPC-2021-EC-J/" data-id="clcisuazy000f5vwl5oq6by0y" data-title="ICPC-2021-EC-J" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Codeforces-Round-831-A-E" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/11/01/Codeforces-Round-831-A-E/" class="article-date">
  <time class="dt-published" datetime="2022-11-01T02:09:45.000Z" itemprop="datePublished">2022-11-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/11/01/Codeforces-Round-831-A-E/">Codeforces Round 831 A - E</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Codeforces-Round-831-A-E"><a href="#Codeforces-Round-831-A-E" class="headerlink" title="Codeforces Round 831 A - E"></a>Codeforces Round 831 A - E</h1><h2 id="A-Factorise-N-M"><a href="#A-Factorise-N-M" class="headerlink" title="A. Factorise N+M"></a>A. Factorise N+M</h2><p><strong>题目大意:</strong> 给定一个质数$n$，找到一个质数$m$ ，使得$n + m$是一个非质数</p>
<p><strong>解题思路:</strong> 对于非$2$的质数来说其他质数全部都是奇数，那么我们可以对于这些质数加上一个$3$，然后对于$2$特判加上$5$即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		if(n &#x3D;&#x3D; 2)
		&#123;
			cout &lt;&lt; 7 &lt;&lt; &quot;\n&quot;;
		&#125;
		else cout &lt;&lt; 3 &lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="B-Jumbo-Extra-Cheese-2"><a href="#B-Jumbo-Extra-Cheese-2" class="headerlink" title="B. Jumbo Extra Cheese 2"></a>B. Jumbo Extra Cheese 2</h2><p><strong>题目大意:</strong> 给定$n$个矩阵，我们需要把矩阵放到$x$轴上面，一个矩阵不能放在另外一个矩阵的上面，问这个矩阵的形成的一个图形的周长是多少</p>
<p><strong>解题思路:</strong> 将这个图形拿出来在颅内思考一下，发现因为很多个矩形会贴在一起，那么对于形成的这个图形的 <strong>高</strong> 实际上就是最长的矩形的高，同时对于每个矩形来说他们的宽都要计算两边，那么我们对于每一个矩形来说我们可以选定较小的那一部分作为宽，较高的那一部分作为高，然后找一个最长的高即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pair&lt;int,int&gt; a[maxn];
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		for(int i &#x3D; 1,u,v;i &lt;&#x3D; n;++i)
		&#123;
			cin &gt;&gt; u &gt;&gt; v;
			if(u &lt; v) swap(u,v);
			a[i] &#x3D; &#123;u,v&#125;;
		&#125;
		sort(a + 1,a + 1 + n);
		int ans &#x3D; 2 * a[n].first;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			ans +&#x3D; a[i].second * 2;
		&#125;
		cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="C-Bricks-and-Bags"><a href="#C-Bricks-and-Bags" class="headerlink" title="C. Bricks and Bags"></a>C. Bricks and Bags</h2><p><strong>题目大意:</strong> 给定$n(1 \leq n \leq 10^5)$个数字，将他们放在$a,b,c$三个背包中，玩家需要从这三个背包中各选择一个数字，并且计算$|w_1 - w_2| + |w_2 - w_3|$ $(w_1 \in a,w_2 \in b,w_3 \in c)$的值是多少，然后玩家想要让值尽可能的小，放置者想要让值尽可能的大，问如何放置才能使得这个值最大</p>
<p><strong>解题思路:</strong> 首先先放在数轴上面考虑这个问题，我们假设$w_3 &gt; w_1$，如果$w_2$在$w_1$和$w_3$之间，那么值就是$w_3 - w_1$，如果$w_2 &lt; w_1$，那么对应的值就是$w_1 - w_2 + w_3 - w_2$，若$w_2 &gt; w_3$，那么对应的值就是$w_2 - w_3 + w_2 - w_1$</p>
<p>对于夹在中间的情况，我们可以直接计算，也就是整个序列的最大值减去整个序列的最小值</p>
<p>如果是第一种情况$w_2 &lt; w_1$，那么实际上我们是去取若干个小值给放在$b$中，为了让权值最大我们可以把$a_n$给单独拉出来当作$w_3$，假设目前取到的小值已经到了第$i$位，那么权值就是$a_n - a_i + a_{i + 1} - a_i$</p>
<p>如果是第二种情况$w_2 &gt; w_3$，那么实际上我们就是去取若干个大值给放在$b$中，为了让权值最大我们可以把$a_1$给单独拉出来当作$w_1$，假设目前取到的大值已经到了第$i$位，那么权值实际上就是$a_i - a_1 + a_i - a_{i - 1}$</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];
		sort(a + 1,a + 1 + n);
		int ans &#x3D; 0;
		for(int i &#x3D; 1;i &lt; n - 1;++i)
		&#123;
			chkmax(ans,a[n] - a[i] + a[i + 1] - a[i]);
		&#125;
		for(int i &#x3D; n;i &gt; 2;--i)
		&#123;
			chkmax(ans,a[i] - a[i - 1] + a[i] - a[1]);
		&#125;
		cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;	
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="D-Knowledge-Cards"><a href="#D-Knowledge-Cards" class="headerlink" title="D. Knowledge Cards"></a>D. Knowledge Cards</h2><p><strong>题目大意:</strong> 给定一个$n * m(n * m \leq 10^6)$的矩阵，刚开始在矩阵$(1,1)$堆积着$k$张牌，从顶部到底部分别是$a_1,a_2,…,a_k$，接下来我们可以把牌移动到别的格子中，注意除了$(1,1)$和$(n,m)$这两个格子其他格子放置的牌数不能超过一张，然后$(1,1)$不能被重复放置牌，也不能从$(n,m)$移出去一张牌，问堆在$(n,m)$上面的牌从顶部到底部牌的排列是否可以是$1,2,3,…k$</p>
<p><strong>解题思路:</strong> 直接移动牌即可，因为我们在移动牌的时候肯定需要给当前一张牌留出一点位置的，所以除了$(1,1)$和$(n,m)$我们另外留出一个位置就能随便移动了，否则就是不能构成的情况</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
for(int i &#x3D; 1;i &lt;&#x3D; k;++i) cin &gt;&gt; a[i];
int nowcnt &#x3D; k;
priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; q;
int f &#x3D; 1;
for(int i &#x3D; 1;i &lt;&#x3D; k;++i)
&#123;
    q.push(a[i]);
    if(q.size() &gt;&#x3D; n * m - 2)
    &#123;
        f &#x3D; 0;
        break;
    &#125;
    while(!q.empty() &amp;&amp; q.top() &#x3D;&#x3D; nowcnt)
    &#123;
        q.pop();
        nowcnt--;
    &#125;
&#125;
if(f) cout &lt;&lt; &quot;YA\n&quot;;
else cout &lt;&lt; &quot;TIDAK\n&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="E-Hanging-Hearts"><a href="#E-Hanging-Hearts" class="headerlink" title="E. Hanging Hearts"></a>E. Hanging Hearts</h2><p><strong>题目大意:</strong> 给定一棵树，我们需要给这棵树分配一些权值，这些权值属于一个排列。然后我们从叶子开始取，取的时候会构成一个序列。我们每次取叶子的时候判断他的父节点是否大于叶子结点如果大于叶子结点那么父节点的权值也变成叶子结点的权值，问构成的序列中形成的最大非递减子序列长度是多少</p>
<p><strong>解题思路:</strong> 考虑拿取叶子的性质实际上我们将小的权值放在下面更好一点，因为小的权值会把权值赋值给上面的父亲节点，那么对于一个节点来说她下面可能有很多条链，我这个节点要么作为子序列的终点要么作为子序列的中转点。如果作为终点的话那么也需要从下面的终点转移过来，如果作为中转点的话就可以将下面的节点选择他们的中转点或者是终点取最大然后把权值全部加起来</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n,m,k;
int dp[maxn][2];
vector&lt;int&gt; edge[maxn];
void dfs(int s,int fa)
&#123;
	dp[s][0] &#x3D; dp[s][1] &#x3D; 0;
	int mx &#x3D; 0;
	for(auto to:edge[s])
	&#123;
		if(to &#x3D;&#x3D; fa) continue;
		dfs(to,s);
		dp[s][0] +&#x3D; max(dp[to][0],dp[to][1]);
		chkmax(mx,dp[to][1]);
	&#125;
	dp[s][1] &#x3D; mx + 1;
&#125;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; n;
	for(int i &#x3D; 2,x;i &lt;&#x3D; n;++i)
	&#123;
		cin &gt;&gt; x;
		edge[i].push_back(x);
		edge[x].push_back(i);
	&#125;
	dfs(1,0);
	cout &lt;&lt; max(dp[1][0],dp[1][1]) &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/01/Codeforces-Round-831-A-E/" data-id="clcisuazn00035vwldgai9asb" data-title="Codeforces Round 831 A - E" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cf/" rel="tag">cf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Computational-Geometry" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/29/Computational-Geometry/" class="article-date">
  <time class="dt-published" datetime="2022-10-29T11:00:41.000Z" itemprop="datePublished">2022-10-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/10/29/Computational-Geometry/">Computational Geometry</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;

using point_t&#x3D;long double;  &#x2F;&#x2F;全局数据类型，可修改为 long long 等

constexpr point_t eps&#x3D;1e-8;
constexpr long double PI&#x3D;3.1415926535897932384l;

&#x2F;&#x2F; 点与向量
template&lt;typename T&gt; struct point
&#123;
    T x,y;

    bool operator&#x3D;&#x3D;(const point &amp;a) const &#123;return (abs(x-a.x)&lt;&#x3D;eps &amp;&amp; abs(y-a.y)&lt;&#x3D;eps);&#125;
    bool operator&lt;(const point &amp;a) const &#123;if (abs(x-a.x)&lt;&#x3D;eps) return y&lt;a.y-eps; return x&lt;a.x-eps;&#125;
    bool operator&gt;(const point &amp;a) const &#123;return !(*this&lt;a || *this&#x3D;&#x3D;a);&#125;
    point operator+(const point &amp;a) const &#123;return &#123;x+a.x,y+a.y&#125;;&#125;
    point operator-(const point &amp;a) const &#123;return &#123;x-a.x,y-a.y&#125;;&#125;
    point operator-() const &#123;return &#123;-x,-y&#125;;&#125;
    point operator*(const T k) const &#123;return &#123;k*x,k*y&#125;;&#125;
    point operator&#x2F;(const T k) const &#123;return &#123;x&#x2F;k,y&#x2F;k&#125;;&#125;
    T operator*(const point &amp;a) const &#123;return x*a.x+y*a.y;&#125;  &#x2F;&#x2F; 点积
    T operator^(const point &amp;a) const &#123;return x*a.y-y*a.x;&#125;  &#x2F;&#x2F; 叉积，注意优先级
    int toleft(const point &amp;a) const &#123;const auto t&#x3D;(*this)^a; return (t&gt;eps)-(t&lt;-eps);&#125;  &#x2F;&#x2F; to-left 测试
    T len2() const &#123;return (*this)*(*this);&#125;  &#x2F;&#x2F; 向量长度的平方
    T dis2(const point &amp;a) const &#123;return (a-(*this)).len2();&#125;  &#x2F;&#x2F; 两点距离的平方

    &#x2F;&#x2F; 涉及浮点数
    long double len() const &#123;return sqrtl(len2());&#125;  &#x2F;&#x2F; 向量长度
    long double dis(const point &amp;a) const &#123;return sqrtl(dis2(a));&#125;  &#x2F;&#x2F; 两点距离
    long double ang(const point &amp;a) const &#123;return acosl(max(-1.0l,min(1.0l,((*this)*a)&#x2F;(len()*a.len()))));&#125;  &#x2F;&#x2F; 向量夹角
    point rot(const long double rad) const &#123;return &#123;x*cos(rad)-y*sin(rad),x*sin(rad)+y*cos(rad)&#125;;&#125;  &#x2F;&#x2F; 逆时针旋转（给定角度）
    point rot(const long double cosr,const long double sinr) const &#123;return &#123;x*cosr-y*sinr,x*sinr+y*cosr&#125;;&#125;  &#x2F;&#x2F; 逆时针旋转（给定角度的正弦与余弦）
&#125;;

using Point&#x3D;point&lt;point_t&gt;;

&#x2F;&#x2F; 极角排序
struct argcmp
&#123;
    bool operator()(const Point &amp;a,const Point &amp;b) const
    &#123;
        const auto quad&#x3D;[](const Point &amp;a)
        &#123;
            if (a.y&lt;-eps) return 1;
            if (a.y&gt;eps) return 4;
            if (a.x&lt;-eps) return 5;
            if (a.x&gt;eps) return 3;
            return 2;
        &#125;;
        const int qa&#x3D;quad(a),qb&#x3D;quad(b);
        if (qa!&#x3D;qb) return qa&lt;qb;
        const auto t&#x3D;a^b;
        &#x2F;&#x2F; if (abs(t)&lt;&#x3D;eps) return a*a&lt;b*b-eps;  &#x2F;&#x2F; 不同长度的向量需要分开
        return t&gt;eps;
    &#125;
&#125;;

&#x2F;&#x2F; 直线
template&lt;typename T&gt; struct line
&#123;
    point&lt;T&gt; p,v;  &#x2F;&#x2F; p 为直线上一点，v 为方向向量

    bool operator&#x3D;&#x3D;(const line &amp;a) const &#123;return v.toleft(a.v)&#x3D;&#x3D;0 &amp;&amp; v.toleft(p-a.p)&#x3D;&#x3D;0;&#125;
    int toleft(const point&lt;T&gt; &amp;a) const &#123;return v.toleft(a-p);&#125;  &#x2F;&#x2F; to-left 测试
    bool operator&lt;(const line &amp;a) const  &#x2F;&#x2F; 半平面交算法定义的排序
    &#123;
        if (abs(v^a.v)&lt;&#x3D;eps &amp;&amp; v*a.v&gt;&#x3D;-eps) return toleft(a.p)&#x3D;&#x3D;-1;
        return argcmp()(v,a.v);
    &#125;

    &#x2F;&#x2F; 涉及浮点数
    point&lt;T&gt; inter(const line &amp;a) const &#123;return p+v*((a.v^(p-a.p))&#x2F;(v^a.v));&#125;  &#x2F;&#x2F; 直线交点
    long double dis(const point&lt;T&gt; &amp;a) const &#123;return abs(v^(a-p))&#x2F;v.len();&#125;  &#x2F;&#x2F; 点到直线距离
    point&lt;T&gt; proj(const point&lt;T&gt; &amp;a) const &#123;return p+v*((v*(a-p))&#x2F;(v*v));&#125;  &#x2F;&#x2F; 点在直线上的投影
&#125;;

using Line&#x3D;line&lt;point_t&gt;;

&#x2F;&#x2F;线段
template&lt;typename T&gt; struct segment
&#123;
    point&lt;T&gt; a,b;

    bool operator&lt;(const segment &amp;s) const &#123;return make_pair(a,b)&lt;make_pair(s.a,s.b);&#125;

    &#x2F;&#x2F; 判定性函数建议在整数域使用

    &#x2F;&#x2F; 判断点是否在线段上
    &#x2F;&#x2F; -1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上
    int is_on(const point&lt;T&gt; &amp;p) const  
    &#123;
        if (p&#x3D;&#x3D;a || p&#x3D;&#x3D;b) return -1;
        return (p-a).toleft(p-b)&#x3D;&#x3D;0 &amp;&amp; (p-a)*(p-b)&lt;-eps;
    &#125;

    &#x2F;&#x2F; 判断线段直线是否相交
    &#x2F;&#x2F; -1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交
    int is_inter(const line&lt;T&gt; &amp;l) const
    &#123;
        if (l.toleft(a)&#x3D;&#x3D;0 || l.toleft(b)&#x3D;&#x3D;0) return -1;
        return l.toleft(a)!&#x3D;l.toleft(b);
    &#125;
    
    &#x2F;&#x2F; 判断两线段是否相交
    &#x2F;&#x2F; -1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交
    int is_inter(const segment&lt;T&gt; &amp;s) const
    &#123;
        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;
        const line&lt;T&gt; l&#123;a,b-a&#125;,ls&#123;s.a,s.b-s.a&#125;;
        return l.toleft(s.a)*l.toleft(s.b)&#x3D;&#x3D;-1 &amp;&amp; ls.toleft(a)*ls.toleft(b)&#x3D;&#x3D;-1;
    &#125;

    &#x2F;&#x2F; 点到线段距离
    long double dis(const point&lt;T&gt; &amp;p) const
    &#123;
        if ((p-a)*(b-a)&lt;-eps || (p-b)*(a-b)&lt;-eps) return min(p.dis(a),p.dis(b));
        const line&lt;T&gt; l&#123;a,b-a&#125;;
        return l.dis(p);
    &#125;

    &#x2F;&#x2F; 两线段间距离
    long double dis(const segment&lt;T&gt; &amp;s) const
    &#123;
        if (is_inter(s)) return 0;
        return min(&#123;dis(s.a),dis(s.b),s.dis(a),s.dis(b)&#125;);
    &#125;
&#125;;

using Segment&#x3D;segment&lt;point_t&gt;;
&#x2F;&#x2F;----------------------------必打-----------------------&#x2F;&#x2F;

&#x2F;&#x2F; 多边形
template&lt;typename T&gt; struct polygon
&#123;
    vector&lt;point&lt;T&gt;&gt; p;  &#x2F;&#x2F; 以逆时针顺序存储

    size_t nxt(const size_t i) const &#123;return i&#x3D;&#x3D;p.size()-1?0:i+1;&#125;
    size_t pre(const size_t i) const &#123;return i&#x3D;&#x3D;0?p.size()-1:i-1;&#125;
    
    &#x2F;&#x2F; 回转数
    &#x2F;&#x2F; 返回值第一项表示点是否在多边形边上
    &#x2F;&#x2F; 对于狭义多边形，回转数为 0 表示点在多边形外，否则点在多边形内
    pair&lt;bool,int&gt; winding(const point&lt;T&gt; &amp;a) const
    &#123;
        int cnt&#x3D;0;
        for (size_t i&#x3D;0;i&lt;p.size();i++)
        &#123;
            const point&lt;T&gt; u&#x3D;p[i],v&#x3D;p[nxt(i)];
            if (abs((a-u)^(a-v))&lt;&#x3D;eps &amp;&amp; (a-u)*(a-v)&lt;&#x3D;eps) return &#123;true,0&#125;;
            if (abs(u.y-v.y)&lt;&#x3D;eps) continue;
            const Line uv&#x3D;&#123;u,v-u&#125;;
            if (u.y&lt;v.y-eps &amp;&amp; uv.toleft(a)&lt;&#x3D;0) continue;
            if (u.y&gt;v.y+eps &amp;&amp; uv.toleft(a)&gt;&#x3D;0) continue;
            if (u.y&lt;a.y-eps &amp;&amp; v.y&gt;&#x3D;a.y-eps) cnt++;
            if (u.y&gt;&#x3D;a.y-eps &amp;&amp; v.y&lt;a.y-eps) cnt--;
        &#125;
        return &#123;false,cnt&#125;;
    &#125;

    &#x2F;&#x2F; 多边形面积的两倍
    &#x2F;&#x2F; 可用于判断点的存储顺序是顺时针或逆时针
    T area() const
    &#123;
        T sum&#x3D;0;
        for (size_t i&#x3D;0;i&lt;p.size();i++) sum+&#x3D;p[i]^p[nxt(i)];
        return sum;
    &#125;

    &#x2F;&#x2F; 多边形的周长
    long double circ() const
    &#123;
        long double sum&#x3D;0;
        for (size_t i&#x3D;0;i&lt;p.size();i++) sum+&#x3D;p[i].dis(p[nxt(i)]);
        return sum;
    &#125;
&#125;;

using Polygon&#x3D;polygon&lt;point_t&gt;;

&#x2F;&#x2F;凸多边形
template&lt;typename T&gt; struct convex: polygon&lt;T&gt;
&#123;
    &#x2F;&#x2F; 闵可夫斯基和
    convex operator+(const convex &amp;c) const  
    &#123;
        const auto &amp;p&#x3D;this-&gt;p;
        vector&lt;Segment&gt; e1(p.size()),e2(c.p.size()),edge(p.size()+c.p.size());
        vector&lt;point&lt;T&gt;&gt; res; res.reserve(p.size()+c.p.size());
        const auto cmp&#x3D;[](const Segment &amp;u,const Segment &amp;v) &#123;return argcmp()(u.b-u.a,v.b-v.a);&#125;;
        for (size_t i&#x3D;0;i&lt;p.size();i++) e1[i]&#x3D;&#123;p[i],p[this-&gt;nxt(i)]&#125;;
        for (size_t i&#x3D;0;i&lt;c.p.size();i++) e2[i]&#x3D;&#123;c.p[i],c.p[c.nxt(i)]&#125;;
        rotate(e1.begin(),min_element(e1.begin(),e1.end(),cmp),e1.end());
        rotate(e2.begin(),min_element(e2.begin(),e2.end(),cmp),e2.end());
        merge(e1.begin(),e1.end(),e2.begin(),e2.end(),edge.begin(),cmp);
        const auto check&#x3D;[](const vector&lt;point&lt;T&gt;&gt; &amp;res,const point&lt;T&gt; &amp;u)
        &#123;
            const auto back1&#x3D;res.back(),back2&#x3D;*prev(res.end(),2);
            return (back1-back2).toleft(u-back1)&#x3D;&#x3D;0 &amp;&amp; (back1-back2)*(u-back1)&gt;&#x3D;-eps;
        &#125;;
        auto u&#x3D;e1[0].a+e2[0].a;
        for (const auto &amp;v:edge)
        &#123;
            while (res.size()&gt;1 &amp;&amp; check(res,u)) res.pop_back();
            res.push_back(u);
            u&#x3D;u+v.b-v.a;
        &#125;
        if (res.size()&gt;1 &amp;&amp; check(res,res[0])) res.pop_back();
        return &#123;res&#125;;
    &#125;

    &#x2F;&#x2F; 旋转卡壳
    &#x2F;&#x2F; func 为更新答案的函数，可以根据题目调整位置
    template&lt;typename F&gt; void rotcaliper(const F &amp;func) const
    &#123;
        const auto &amp;p&#x3D;this-&gt;p;
        const auto area&#x3D;[](const point&lt;T&gt; &amp;u,const point&lt;T&gt; &amp;v,const point&lt;T&gt; &amp;w)&#123;return (w-u)^(w-v);&#125;;
        for (size_t i&#x3D;0,j&#x3D;1;i&lt;p.size();i++)
        &#123;
            const auto nxti&#x3D;this-&gt;nxt(i);
            func(p[i],p[nxti],p[j]);
            while (area(p[this-&gt;nxt(j)],p[i],p[nxti])&gt;&#x3D;area(p[j],p[i],p[nxti]))
            &#123;
                j&#x3D;this-&gt;nxt(j);
                func(p[i],p[nxti],p[j]);
            &#125;
        &#125;
    &#125;

    &#x2F;&#x2F; 凸多边形的直径的平方
    T diameter2() const
    &#123;
        const auto &amp;p&#x3D;this-&gt;p;
        if (p.size()&#x3D;&#x3D;1) return 0;
        if (p.size()&#x3D;&#x3D;2) return p[0].dis2(p[1]);
        T ans&#x3D;0;
        auto func&#x3D;[&amp;](const point&lt;T&gt; &amp;u,const point&lt;T&gt; &amp;v,const point&lt;T&gt; &amp;w)&#123;ans&#x3D;max(&#123;ans,w.dis2(u),w.dis2(v)&#125;);&#125;;
        rotcaliper(func);
        return ans;
    &#125;
    
    &#x2F;&#x2F; 判断点是否在凸多边形内
    &#x2F;&#x2F; 复杂度 O(logn)
    &#x2F;&#x2F; -1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内
    int is_in(const point&lt;T&gt; &amp;a) const
    &#123;
        const auto &amp;p&#x3D;this-&gt;p;
        if (p.size()&#x3D;&#x3D;1) return a&#x3D;&#x3D;p[0]?-1:0;
        if (p.size()&#x3D;&#x3D;2) return segment&lt;T&gt;&#123;p[0],p[1]&#125;.is_on(a)?-1:0; 
        if (a&#x3D;&#x3D;p[0]) return -1;
        if ((p[1]-p[0]).toleft(a-p[0])&#x3D;&#x3D;-1 || (p.back()-p[0]).toleft(a-p[0])&#x3D;&#x3D;1) return 0;
        const auto cmp&#x3D;[&amp;](const Point &amp;u,const Point &amp;v)&#123;return (u-p[0]).toleft(v-p[0])&#x3D;&#x3D;1;&#125;;
        const size_t i&#x3D;lower_bound(p.begin()+1,p.end(),a,cmp)-p.begin();
        if (i&#x3D;&#x3D;1) return segment&lt;T&gt;&#123;p[0],p[i]&#125;.is_on(a)?-1:0;
        if (i&#x3D;&#x3D;p.size()-1 &amp;&amp; segment&lt;T&gt;&#123;p[0],p[i]&#125;.is_on(a)) return -1;
        if (segment&lt;T&gt;&#123;p[i-1],p[i]&#125;.is_on(a)) return -1;
        return (p[i]-p[i-1]).toleft(a-p[i-1])&gt;0;
    &#125;

    &#x2F;&#x2F; 凸多边形关于某一方向的极点
    &#x2F;&#x2F; 复杂度 O(logn)
    &#x2F;&#x2F; 参考资料：https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;48868
    template&lt;typename F&gt; size_t extreme(const F &amp;dir) const
    &#123;
        const auto &amp;p&#x3D;this-&gt;p;
        const auto check&#x3D;[&amp;](const size_t i)&#123;return dir(p[i]).toleft(p[this-&gt;nxt(i)]-p[i])&gt;&#x3D;0;&#125;;
        const auto dir0&#x3D;dir(p[0]); const auto check0&#x3D;check(0);
        if (!check0 &amp;&amp; check(p.size()-1)) return 0;
        const auto cmp&#x3D;[&amp;](const Point &amp;v)
        &#123;
            const size_t vi&#x3D;&amp;v-p.data();
            if (vi&#x3D;&#x3D;0) return 1;
            const auto checkv&#x3D;check(vi);
            const auto t&#x3D;dir0.toleft(v-p[0]);
            if (vi&#x3D;&#x3D;1 &amp;&amp; checkv&#x3D;&#x3D;check0 &amp;&amp; t&#x3D;&#x3D;0) return 1;
            return checkv^(checkv&#x3D;&#x3D;check0 &amp;&amp; t&lt;&#x3D;0);
        &#125;;
        return partition_point(p.begin(),p.end(),cmp)-p.begin();
    &#125;

    &#x2F;&#x2F; 过凸多边形外一点求凸多边形的切线，返回切点下标
    &#x2F;&#x2F; 复杂度 O(logn)
    &#x2F;&#x2F; 必须保证点在多边形外
    pair&lt;size_t,size_t&gt; tangent(const point&lt;T&gt; &amp;a) const
    &#123;
        const size_t i&#x3D;extreme([&amp;](const point&lt;T&gt; &amp;u)&#123;return u-a;&#125;);
        const size_t j&#x3D;extreme([&amp;](const point&lt;T&gt; &amp;u)&#123;return a-u;&#125;);
        return &#123;i,j&#125;;
    &#125;

    &#x2F;&#x2F; 求平行于给定直线的凸多边形的切线，返回切点下标
    &#x2F;&#x2F; 复杂度 O(logn)
    pair&lt;size_t,size_t&gt; tangent(const line&lt;T&gt; &amp;a) const
    &#123;
        const size_t i&#x3D;extreme([&amp;](...)&#123;return a.v;&#125;);
        const size_t j&#x3D;extreme([&amp;](...)&#123;return -a.v;&#125;);
        return &#123;i,j&#125;;
    &#125;
&#125;;

using Convex&#x3D;convex&lt;point_t&gt;;

&#x2F;&#x2F; 圆
struct Circle
&#123;
    Point c;
    long double r;

    bool operator&#x3D;&#x3D;(const Circle &amp;a) const &#123;return c&#x3D;&#x3D;a.c &amp;&amp; abs(r-a.r)&lt;&#x3D;eps;&#125;
    long double circ() const &#123;return 2*PI*r;&#125;  &#x2F;&#x2F; 周长
    long double area() const &#123;return PI*r*r;&#125;  &#x2F;&#x2F; 面积

    &#x2F;&#x2F; 点与圆的关系
    &#x2F;&#x2F; -1 圆上 | 0 圆外 | 1 圆内
    int is_in(const Point &amp;p) const &#123;const long double d&#x3D;p.dis(c); return abs(d-r)&lt;&#x3D;eps?-1:d&lt;r-eps;&#125;

    &#x2F;&#x2F; 直线与圆关系
    &#x2F;&#x2F; 0 相离 | 1 相切 | 2 相交
    int relation(const Line &amp;l) const
    &#123;
        const long double d&#x3D;l.dis(c);
        if (d&gt;r+eps) return 0;
        if (abs(d-r)&lt;&#x3D;eps) return 1;
        return 2;
    &#125;

    &#x2F;&#x2F; 圆与圆关系
    &#x2F;&#x2F; -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含
    int relation(const Circle &amp;a) const
    &#123;
        if (*this&#x3D;&#x3D;a) return -1;
        const long double d&#x3D;c.dis(a.c);
        if (d&gt;r+a.r+eps) return 0;
        if (abs(d-r-a.r)&lt;&#x3D;eps) return 1;
        if (abs(d-abs(r-a.r))&lt;&#x3D;eps) return 3;
        if (d&lt;abs(r-a.r)-eps) return 4;
        return 2;
    &#125;

    &#x2F;&#x2F; 直线与圆的交点
    vector&lt;Point&gt; inter(const Line &amp;l) const
    &#123;
        const long double d&#x3D;l.dis(c);
        const Point p&#x3D;l.proj(c);
        const int t&#x3D;relation(l);
        if (t&#x3D;&#x3D;0) return vector&lt;Point&gt;();
        if (t&#x3D;&#x3D;1) return vector&lt;Point&gt;&#123;p&#125;;
        const long double k&#x3D;sqrt(r*r-d*d);
        return vector&lt;Point&gt;&#123;p-(l.v&#x2F;l.v.len())*k,p+(l.v&#x2F;l.v.len())*k&#125;;
    &#125;

    &#x2F;&#x2F; 圆与圆交点
    vector&lt;Point&gt; inter(const Circle &amp;a) const
    &#123;
        const long double d&#x3D;c.dis(a.c);
        const int t&#x3D;relation(a);
        if (t&#x3D;&#x3D;-1 || t&#x3D;&#x3D;0 || t&#x3D;&#x3D;4) return vector&lt;Point&gt;();
        Point e&#x3D;a.c-c; e&#x3D;e&#x2F;e.len()*r;
        if (t&#x3D;&#x3D;1 || t&#x3D;&#x3D;3) 
        &#123;
            if (r*r+d*d-a.r*a.r&gt;&#x3D;-eps) return vector&lt;Point&gt;&#123;c+e&#125;;
            return vector&lt;Point&gt;&#123;c-e&#125;;
        &#125;
        const long double costh&#x3D;(r*r+d*d-a.r*a.r)&#x2F;(2*r*d),sinth&#x3D;sqrt(1-costh*costh);
        return vector&lt;Point&gt;&#123;c+e.rot(costh,-sinth),c+e.rot(costh,sinth)&#125;;
    &#125;

    &#x2F;&#x2F; 圆与圆交面积
    long double inter_area(const Circle &amp;a) const
    &#123;
        const long double d&#x3D;c.dis(a.c);
        const int t&#x3D;relation(a);
        if (t&#x3D;&#x3D;-1) return area();
        if (t&lt;2) return 0;
        if (t&gt;2) return min(area(),a.area());
        const long double costh1&#x3D;(r*r+d*d-a.r*a.r)&#x2F;(2*r*d),costh2&#x3D;(a.r*a.r+d*d-r*r)&#x2F;(2*a.r*d);
        const long double sinth1&#x3D;sqrt(1-costh1*costh1),sinth2&#x3D;sqrt(1-costh2*costh2);
        const long double th1&#x3D;acos(costh1),th2&#x3D;acos(costh2);
        return r*r*(th1-costh1*sinth1)+a.r*a.r*(th2-costh2*sinth2);
    &#125;

    &#x2F;&#x2F; 过圆外一点圆的切线
    vector&lt;Line&gt; tangent(const Point &amp;a) const
    &#123;
        const int t&#x3D;is_in(a);
        if (t&#x3D;&#x3D;1) return vector&lt;Line&gt;();
        if (t&#x3D;&#x3D;-1)
        &#123;
            const Point v&#x3D;&#123;-(a-c).y,(a-c).x&#125;;
            return vector&lt;Line&gt;&#123;&#123;a,v&#125;&#125;;
        &#125;
        Point e&#x3D;a-c; e&#x3D;e&#x2F;e.len()*r;
        const long double costh&#x3D;r&#x2F;c.dis(a),sinth&#x3D;sqrt(1-costh*costh);
        const Point t1&#x3D;c+e.rot(costh,-sinth),t2&#x3D;c+e.rot(costh,sinth);
        return vector&lt;Line&gt;&#123;&#123;a,t1-a&#125;,&#123;a,t2-a&#125;&#125;;
    &#125;

    &#x2F;&#x2F; 两圆的公切线
    vector&lt;Line&gt; tangent(const Circle &amp;a) const
    &#123;
        const int t&#x3D;relation(a);
        vector&lt;Line&gt; lines;
        if (t&#x3D;&#x3D;-1 || t&#x3D;&#x3D;4) return lines;
        if (t&#x3D;&#x3D;1 || t&#x3D;&#x3D;3)
        &#123;
            const Point p&#x3D;inter(a)[0],v&#x3D;&#123;-(a.c-c).y,(a.c-c).x&#125;;
            lines.push_back(&#123;p,v&#125;);
        &#125;
        const long double d&#x3D;c.dis(a.c);
        const Point e&#x3D;(a.c-c)&#x2F;(a.c-c).len();
        if (t&lt;&#x3D;2)
        &#123;
            const long double costh&#x3D;(r-a.r)&#x2F;d,sinth&#x3D;sqrt(1-costh*costh);
            const Point d1&#x3D;e.rot(costh,-sinth),d2&#x3D;e.rot(costh,sinth);
            const Point u1&#x3D;c+d1*r,u2&#x3D;c+d2*r,v1&#x3D;a.c+d1*a.r,v2&#x3D;a.c+d2*a.r;
            lines.push_back(&#123;u1,v1-u1&#125;); lines.push_back(&#123;u2,v2-u2&#125;);
        &#125;
        if (t&#x3D;&#x3D;0)
        &#123;
            const long double costh&#x3D;(r+a.r)&#x2F;d,sinth&#x3D;sqrt(1-costh*costh);
            const Point d1&#x3D;e.rot(costh,-sinth),d2&#x3D;e.rot(costh,sinth);
            const Point u1&#x3D;c+d1*r,u2&#x3D;c+d2*r,v1&#x3D;a.c-d1*a.r,v2&#x3D;a.c-d2*a.r;
            lines.push_back(&#123;u1,v1-u1&#125;); lines.push_back(&#123;u2,v2-u2&#125;);
        &#125;
        return lines;
    &#125;

    &#x2F;&#x2F; 圆的反演
    tuple&lt;int,Circle,Line&gt; inverse(const Line &amp;l) const
    &#123;
        const Circle null_c&#x3D;&#123;&#123;0.0,0.0&#125;,0.0&#125;;
        const Line null_l&#x3D;&#123;&#123;0.0,0.0&#125;,&#123;0.0,0.0&#125;&#125;;
        if (l.toleft(c)&#x3D;&#x3D;0) return &#123;2,null_c,l&#125;;
        const Point v&#x3D;l.toleft(c)&#x3D;&#x3D;1?Point&#123;l.v.y,-l.v.x&#125;:Point&#123;-l.v.y,l.v.x&#125;;
        const long double d&#x3D;r*r&#x2F;l.dis(c);
        const Point p&#x3D;c+v&#x2F;v.len()*d;
        return &#123;1,&#123;(c+p)&#x2F;2,d&#x2F;2&#125;,null_l&#125;;
    &#125;
    
    tuple&lt;int,Circle,Line&gt; inverse(const Circle &amp;a) const
    &#123;
        const Circle null_c&#x3D;&#123;&#123;0.0,0.0&#125;,0.0&#125;;
        const Line null_l&#x3D;&#123;&#123;0.0,0.0&#125;,&#123;0.0,0.0&#125;&#125;;
        const Point v&#x3D;a.c-c;
        if (a.is_in(c)&#x3D;&#x3D;-1)
        &#123;
            const long double d&#x3D;r*r&#x2F;(a.r+a.r);
            const Point p&#x3D;c+v&#x2F;v.len()*d;
            return &#123;2,null_c,&#123;p,&#123;-v.y,v.x&#125;&#125;&#125;;
        &#125;
        if (c&#x3D;&#x3D;a.c) return &#123;1,&#123;c,r*r&#x2F;a.r&#125;,null_l&#125;;
        const long double d1&#x3D;r*r&#x2F;(c.dis(a.c)-a.r),d2&#x3D;r*r&#x2F;(c.dis(a.c)+a.r);
        const Point p&#x3D;c+v&#x2F;v.len()*d1,q&#x3D;c+v&#x2F;v.len()*d2;
        return &#123;1,&#123;(p+q)&#x2F;2,p.dis(q)&#x2F;2&#125;,null_l&#125;;
    &#125;
&#125;;

&#x2F;&#x2F; 圆与多边形面积交
long double area_inter(const Circle &amp;circ,const Polygon &amp;poly)
&#123;
    const auto cal&#x3D;[](const Circle &amp;circ,const Point &amp;a,const Point &amp;b)
    &#123;
        if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;0) return 0.0l;
        const auto ina&#x3D;circ.is_in(a),inb&#x3D;circ.is_in(b);
        const Line ab&#x3D;&#123;a,b-a&#125;;
        if (ina &amp;&amp; inb) return ((a-circ.c)^(b-circ.c))&#x2F;2;
        if (ina &amp;&amp; !inb)
        &#123;
            const auto t&#x3D;circ.inter(ab);
            const Point p&#x3D;t.size()&#x3D;&#x3D;1?t[0]:t[1];
            const long double ans&#x3D;((a-circ.c)^(p-circ.c))&#x2F;2;
            const long double th&#x3D;(p-circ.c).ang(b-circ.c);
            const long double d&#x3D;circ.r*circ.r*th&#x2F;2;
            if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;1) return ans+d;
            return ans-d;
        &#125;
        if (!ina &amp;&amp; inb)
        &#123;
            const Point p&#x3D;circ.inter(ab)[0];
            const long double ans&#x3D;((p-circ.c)^(b-circ.c))&#x2F;2;
            const long double th&#x3D;(a-circ.c).ang(p-circ.c);
            const long double d&#x3D;circ.r*circ.r*th&#x2F;2;
            if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;1) return ans+d;
            return ans-d;
        &#125;
        const auto p&#x3D;circ.inter(ab);
        if (p.size()&#x3D;&#x3D;2 &amp;&amp; Segment&#123;a,b&#125;.dis(circ.c)&lt;&#x3D;circ.r+eps)
        &#123;
            const long double ans&#x3D;((p[0]-circ.c)^(p[1]-circ.c))&#x2F;2;
            const long double th1&#x3D;(a-circ.c).ang(p[0]-circ.c),th2&#x3D;(b-circ.c).ang(p[1]-circ.c);
            const long double d1&#x3D;circ.r*circ.r*th1&#x2F;2,d2&#x3D;circ.r*circ.r*th2&#x2F;2;
            if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;1) return ans+d1+d2;
            return ans-d1-d2;
        &#125;
        const long double th&#x3D;(a-circ.c).ang(b-circ.c);
        if ((a-circ.c).toleft(b-circ.c)&#x3D;&#x3D;1) return circ.r*circ.r*th&#x2F;2;
        return -circ.r*circ.r*th&#x2F;2;
    &#125;;

    long double ans&#x3D;0;
    for (size_t i&#x3D;0;i&lt;poly.p.size();i++)
    &#123;
        const Point a&#x3D;poly.p[i],b&#x3D;poly.p[poly.nxt(i)];
        ans+&#x3D;cal(circ,a,b);
    &#125;
    return ans;
&#125;

&#x2F;&#x2F; 点集的凸包
&#x2F;&#x2F; Andrew 算法，复杂度 O(nlogn)
Convex convexhull(vector&lt;Point&gt; p)
&#123;
    vector&lt;Point&gt; st;
    if (p.empty()) return Convex&#123;st&#125;;
    sort(p.begin(),p.end());
    const auto check&#x3D;[](const vector&lt;Point&gt; &amp;st,const Point &amp;u)
    &#123;
        const auto back1&#x3D;st.back(),back2&#x3D;*prev(st.end(),2);
        return (back1-back2).toleft(u-back1)&lt;&#x3D;0;
    &#125;;
    for (const Point &amp;u:p)
    &#123;
        while (st.size()&gt;1 &amp;&amp; check(st,u)) st.pop_back();
        st.push_back(u);
    &#125;
    size_t k&#x3D;st.size();
    p.pop_back(); reverse(p.begin(),p.end());
    for (const Point &amp;u:p)
    &#123;
        while (st.size()&gt;k &amp;&amp; check(st,u)) st.pop_back();
        st.push_back(u);
    &#125;
    st.pop_back();
    return Convex&#123;st&#125;;
&#125;

&#x2F;&#x2F; 半平面交
&#x2F;&#x2F; 排序增量法，复杂度 O(nlogn)
&#x2F;&#x2F; 输入与返回值都是用直线表示的半平面集合
vector&lt;Line&gt; halfinter(vector&lt;Line&gt; l, const point_t lim&#x3D;1e9)
&#123;
    const auto check&#x3D;[](const Line &amp;a,const Line &amp;b,const Line &amp;c)&#123;return a.toleft(b.inter(c))&lt;0;&#125;;
    &#x2F;&#x2F; 无精度误差的方法，但注意取值范围会扩大到三次方
    &#x2F;*const auto check&#x3D;[](const Line &amp;a,const Line &amp;b,const Line &amp;c)
    &#123;
        const Point p&#x3D;a.v*(b.v^c.v),q&#x3D;b.p*(b.v^c.v)+b.v*(c.v^(b.p-c.p))-a.p*(b.v^c.v);
        return p.toleft(q)&lt;0;
    &#125;;*&#x2F;
    l.push_back(&#123;&#123;-lim,0&#125;,&#123;0,-1&#125;&#125;); l.push_back(&#123;&#123;0,-lim&#125;,&#123;1,0&#125;&#125;);
    l.push_back(&#123;&#123;lim,0&#125;,&#123;0,1&#125;&#125;); l.push_back(&#123;&#123;0,lim&#125;,&#123;-1,0&#125;&#125;);
    sort(l.begin(),l.end());
    deque&lt;Line&gt; q;
    for (size_t i&#x3D;0;i&lt;l.size();i++)
    &#123;
        if (i&gt;0 &amp;&amp; l[i-1].v.toleft(l[i].v)&#x3D;&#x3D;0 &amp;&amp; l[i-1].v*l[i].v&gt;eps) continue;
        while (q.size()&gt;1 &amp;&amp; check(l[i],q.back(),q[q.size()-2])) q.pop_back();
        while (q.size()&gt;1 &amp;&amp; check(l[i],q[0],q[1])) q.pop_front();
        if (!q.empty() &amp;&amp; q.back().v.toleft(l[i].v)&lt;&#x3D;0) return vector&lt;Line&gt;();
        q.push_back(l[i]);
    &#125;
    while (q.size()&gt;1 &amp;&amp; check(q[0],q.back(),q[q.size()-2])) q.pop_back();
    while (q.size()&gt;1 &amp;&amp; check(q.back(),q[0],q[1])) q.pop_front();
    return vector&lt;Line&gt;(q.begin(),q.end());
&#125;

&#x2F;&#x2F; 点集形成的最小最大三角形
&#x2F;&#x2F; 极角序扫描线，复杂度 O(n^2logn)
&#x2F;&#x2F; 最大三角形问题可以使用凸包与旋转卡壳做到 O(n^2)
pair&lt;point_t,point_t&gt; minmax_triangle(const vector&lt;Point&gt; &amp;vec)
&#123;
    if (vec.size()&lt;&#x3D;2) return &#123;0,0&#125;;
    vector&lt;pair&lt;int,int&gt;&gt; evt;
    evt.reserve(vec.size()*vec.size());
    point_t maxans&#x3D;0,minans&#x3D;numeric_limits&lt;point_t&gt;::max();
    for (size_t i&#x3D;0;i&lt;vec.size();i++)
    &#123;
        for (size_t j&#x3D;0;j&lt;vec.size();j++)
        &#123;
            if (i&#x3D;&#x3D;j) continue;
            if (vec[i]&#x3D;&#x3D;vec[j]) minans&#x3D;0;
            else evt.push_back(&#123;i,j&#125;);
        &#125;
    &#125;
    sort(evt.begin(),evt.end(),[&amp;](const pair&lt;int,int&gt; &amp;u,const pair&lt;int,int&gt; &amp;v)
    &#123;
        const Point du&#x3D;vec[u.second]-vec[u.first],dv&#x3D;vec[v.second]-vec[v.first];
        return argcmp()(&#123;du.y,-du.x&#125;,&#123;dv.y,-dv.x&#125;);
    &#125;);
    vector&lt;size_t&gt; vx(vec.size()),pos(vec.size());
    for (size_t i&#x3D;0;i&lt;vec.size();i++) vx[i]&#x3D;i;
    sort(vx.begin(),vx.end(),[&amp;](int x,int y)&#123;return vec[x]&lt;vec[y];&#125;);
    for (size_t i&#x3D;0;i&lt;vx.size();i++) pos[vx[i]]&#x3D;i;
    for (auto [u,v]:evt)
    &#123;
        const size_t i&#x3D;pos[u],j&#x3D;pos[v];
        const size_t l&#x3D;min(i,j),r&#x3D;max(i,j);
        const Point vecu&#x3D;vec[u],vecv&#x3D;vec[v];
        if (l&gt;0) minans&#x3D;min(minans,abs((vec[vx[l-1]]-vecu)^(vec[vx[l-1]]-vecv)));
        if (r&lt;vx.size()-1) minans&#x3D;min(minans,abs((vec[vx[r+1]]-vecu)^(vec[vx[r+1]]-vecv)));
        maxans&#x3D;max(&#123;maxans,abs((vec[vx[0]]-vecu)^(vec[vx[0]]-vecv)),abs((vec[vx.back()]-vecu)^(vec[vx.back()]-vecv))&#125;);
        if (i&lt;j) swap(vx[i],vx[j]),pos[u]&#x3D;j,pos[v]&#x3D;i;
    &#125;
    return &#123;minans,maxans&#125;;
&#125;

&#x2F;&#x2F; 判断多条线段是否有交点
&#x2F;&#x2F; 扫描线，复杂度 O(nlogn)
bool segs_inter(const vector&lt;Segment&gt; &amp;segs)
&#123;
    if (segs.empty()) return false;
    using seq_t&#x3D;tuple&lt;point_t,int,Segment&gt;;
    const auto seqcmp&#x3D;[](const seq_t &amp;u, const seq_t &amp;v)
    &#123;
        const auto [u0,u1,u2]&#x3D;u;
        const auto [v0,v1,v2]&#x3D;v;
        if (abs(u0-v0)&lt;&#x3D;eps) return make_pair(u1,u2)&lt;make_pair(v1,v2);
        return u0&lt;v0-eps;
    &#125;;
    vector&lt;seq_t&gt; seq;
    for (auto seg:segs)
    &#123;
        if (seg.a.x&gt;seg.b.x+eps) swap(seg.a,seg.b);
        seq.push_back(&#123;seg.a.x,0,seg&#125;);
        seq.push_back(&#123;seg.b.x,1,seg&#125;);
    &#125;
    sort(seq.begin(),seq.end(),seqcmp);
    point_t x_now;
    auto cmp&#x3D;[&amp;](const Segment &amp;u, const Segment &amp;v)
    &#123;
        if (abs(u.a.x-u.b.x)&lt;&#x3D;eps || abs(v.a.x-v.b.x)&lt;&#x3D;eps) return u.a.y&lt;v.a.y-eps;
        return ((x_now-u.a.x)*(u.b.y-u.a.y)+u.a.y*(u.b.x-u.a.x))*(v.b.x-v.a.x)&lt;((x_now-v.a.x)*(v.b.y-v.a.y)+v.a.y*(v.b.x-v.a.x))*(u.b.x-u.a.x)-eps;
    &#125;;
    multiset&lt;Segment,decltype(cmp)&gt; s&#123;cmp&#125;;
    for (const auto [x,o,seg]:seq)
    &#123;
        x_now&#x3D;x;
        const auto it&#x3D;s.lower_bound(seg);
        if (o&#x3D;&#x3D;0)
        &#123;
            if (it!&#x3D;s.end() &amp;&amp; seg.is_inter(*it)) return true;
            if (it!&#x3D;s.begin() &amp;&amp; seg.is_inter(*prev(it))) return true;
            s.insert(seg);
        &#125;
        else
        &#123;
            if (next(it)!&#x3D;s.end() &amp;&amp; it!&#x3D;s.begin() &amp;&amp; (*prev(it)).is_inter(*next(it))) return true;
            s.erase(it);
        &#125;
    &#125;
    return false;
&#125;

&#x2F;&#x2F; 多边形面积并
&#x2F;&#x2F; 轮廓积分，复杂度 O(n^2logn)，n为边数
&#x2F;&#x2F; ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector&lt;long double&gt; area_union(const vector&lt;Polygon&gt; &amp;polys)
&#123;
    const size_t siz&#x3D;polys.size();
    vector&lt;vector&lt;pair&lt;Point,Point&gt;&gt;&gt; segs(siz);
    const auto check&#x3D;[](const Point &amp;u,const Segment &amp;e)&#123;return !((u&lt;e.a &amp;&amp; u&lt;e.b) || (u&gt;e.a &amp;&amp; u&gt;e.b));&#125;;

    auto cut_edge&#x3D;[&amp;](const Segment &amp;e,const size_t i)
    &#123;
        const Line le&#123;e.a,e.b-e.a&#125;;
        vector&lt;pair&lt;Point,int&gt;&gt; evt;
        evt.push_back(&#123;e.a,0&#125;); evt.push_back(&#123;e.b,0&#125;);
        for (size_t j&#x3D;0;j&lt;polys.size();j++)
        &#123;
            if (i&#x3D;&#x3D;j) continue;
            const auto &amp;pj&#x3D;polys[j];
            for (size_t k&#x3D;0;k&lt;pj.p.size();k++)
            &#123;
                const Segment s&#x3D;&#123;pj.p[k],pj.p[pj.nxt(k)]&#125;;
                if (le.toleft(s.a)&#x3D;&#x3D;0 &amp;&amp; le.toleft(s.b)&#x3D;&#x3D;0)
                &#123;
                    evt.push_back(&#123;s.a,0&#125;);
                    evt.push_back(&#123;s.b,0&#125;);
                &#125;
                else if (s.is_inter(le))
                &#123;
                    const Line ls&#123;s.a,s.b-s.a&#125;;
                    const Point u&#x3D;le.inter(ls);
                    if (le.toleft(s.a)&lt;0 &amp;&amp; le.toleft(s.b)&gt;&#x3D;0) evt.push_back(&#123;u,-1&#125;);
                    else if (le.toleft(s.a)&gt;&#x3D;0 &amp;&amp; le.toleft(s.b)&lt;0) evt.push_back(&#123;u,1&#125;);
                &#125;
            &#125;
        &#125;
        sort(evt.begin(),evt.end());
        if (e.a&gt;e.b) reverse(evt.begin(),evt.end());
        int sum&#x3D;0;
        for (size_t i&#x3D;0;i&lt;evt.size();i++)
        &#123;
            sum+&#x3D;evt[i].second;
            const Point u&#x3D;evt[i].first,v&#x3D;evt[i+1].first;
            if (!(u&#x3D;&#x3D;v) &amp;&amp; check(u,e) &amp;&amp; check(v,e)) segs[sum].push_back(&#123;u,v&#125;);
            if (v&#x3D;&#x3D;e.b) break;
        &#125;
    &#125;;
    
    for (size_t i&#x3D;0;i&lt;polys.size();i++)
    &#123;
        const auto &amp;pi&#x3D;polys[i];
        for (size_t k&#x3D;0;k&lt;pi.p.size();k++)
        &#123;
            const Segment ei&#x3D;&#123;pi.p[k],pi.p[pi.nxt(k)]&#125;;
            cut_edge(ei,i);
        &#125;
    &#125;
    vector&lt;long double&gt; ans(siz);
    for (size_t i&#x3D;0;i&lt;siz;i++)
    &#123;
        long double sum&#x3D;0;
        sort(segs[i].begin(),segs[i].end());
        int cnt&#x3D;0;
        for (size_t j&#x3D;0;j&lt;segs[i].size();j++)
        &#123;
            if (j&gt;0 &amp;&amp; segs[i][j]&#x3D;&#x3D;segs[i][j-1]) segs[i+(++cnt)].push_back(segs[i][j]);
            else cnt&#x3D;0,sum+&#x3D;segs[i][j].first^segs[i][j].second;
        &#125;
        ans[i]&#x3D;sum&#x2F;2;
    &#125;
    return ans;
&#125;

&#x2F;&#x2F; 圆面积并
&#x2F;&#x2F; 轮廓积分，复杂度 O(n^2logn)
&#x2F;&#x2F; ans[i] 表示被至少覆盖了 i+1 次的区域的面积
vector&lt;long double&gt; area_union(const vector&lt;Circle&gt; &amp;circs)
&#123;
    const size_t siz&#x3D;circs.size();
    using arc_t&#x3D;tuple&lt;Point,long double,long double,long double&gt;;
    vector&lt;vector&lt;arc_t&gt;&gt; arcs(siz);
    const auto eq&#x3D;[](const arc_t &amp;u,const arc_t &amp;v)
    &#123;
        const auto [u1,u2,u3,u4]&#x3D;u;
        const auto [v1,v2,v3,v4]&#x3D;v;
        return u1&#x3D;&#x3D;v1 &amp;&amp; abs(u2-v2)&lt;&#x3D;eps &amp;&amp; abs(u3-v3)&lt;&#x3D;eps &amp;&amp; abs(u4-v4)&lt;&#x3D;eps;
    &#125;;

    auto cut_circ&#x3D;[&amp;](const Circle &amp;ci,const size_t i)
    &#123;
        vector&lt;pair&lt;long double,int&gt;&gt; evt;
        evt.push_back(&#123;-PI,0&#125;); evt.push_back(&#123;PI,0&#125;);
        int init&#x3D;0;
        for (size_t j&#x3D;0;j&lt;circs.size();j++)
        &#123;
            if (i&#x3D;&#x3D;j) continue;
            const Circle &amp;cj&#x3D;circs[j];
            if (ci.r&lt;cj.r-eps &amp;&amp; ci.relation(cj)&gt;&#x3D;3) init++;
            const auto inters&#x3D;ci.inter(cj);
            if (inters.size()&#x3D;&#x3D;1) evt.push_back(&#123;atan2l((inters[0]-ci.c).y,(inters[0]-ci.c).x),0&#125;);
            if (inters.size()&#x3D;&#x3D;2)
            &#123;
                const Point dl&#x3D;inters[0]-ci.c,dr&#x3D;inters[1]-ci.c;
                long double argl&#x3D;atan2l(dl.y,dl.x),argr&#x3D;atan2l(dr.y,dr.x);
                if (abs(argl+PI)&lt;&#x3D;eps) argl&#x3D;PI;
                if (abs(argr+PI)&lt;&#x3D;eps) argr&#x3D;PI;
                if (argl&gt;argr+eps)
                &#123;
                    evt.push_back(&#123;argl,1&#125;); evt.push_back(&#123;PI,-1&#125;);
                    evt.push_back(&#123;-PI,1&#125;); evt.push_back(&#123;argr,-1&#125;);
                &#125;
                else
                &#123;
                    evt.push_back(&#123;argl,1&#125;);
                    evt.push_back(&#123;argr,-1&#125;);
                &#125;
            &#125;
        &#125;
        sort(evt.begin(),evt.end());
        int sum&#x3D;init;
        for (size_t i&#x3D;0;i&lt;evt.size();i++)
        &#123;
            sum+&#x3D;evt[i].second;
            if (abs(evt[i].first-evt[i+1].first)&gt;eps) arcs[sum].push_back(&#123;ci.c,ci.r,evt[i].first,evt[i+1].first&#125;);
            if (abs(evt[i+1].first-PI)&lt;&#x3D;eps) break;
        &#125;
    &#125;;

    const auto oint&#x3D;[](const arc_t &amp;arc)
    &#123;
        const auto [cc,cr,l,r]&#x3D;arc;
        if (abs(r-l-PI-PI)&lt;&#x3D;eps) return 2.0l*PI*cr*cr;
        return cr*cr*(r-l)+cc.x*cr*(sin(r)-sin(l))-cc.y*cr*(cos(r)-cos(l));
    &#125;;

    for (size_t i&#x3D;0;i&lt;circs.size();i++)
    &#123;
        const auto &amp;ci&#x3D;circs[i];
        cut_circ(ci,i);
    &#125;
    vector&lt;long double&gt; ans(siz);
    for (size_t i&#x3D;0;i&lt;siz;i++)
    &#123;
        long double sum&#x3D;0;
        sort(arcs[i].begin(),arcs[i].end());
        int cnt&#x3D;0;
        for (size_t j&#x3D;0;j&lt;arcs[i].size();j++)
        &#123;
            if (j&gt;0 &amp;&amp; eq(arcs[i][j],arcs[i][j-1])) arcs[i+(++cnt)].push_back(arcs[i][j]);
            else cnt&#x3D;0,sum+&#x3D;oint(arcs[i][j]);
        &#125;
        ans[i]&#x3D;sum&#x2F;2;
    &#125;
    return ans;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/29/Computational-Geometry/" data-id="clcisuazr00065vwl1zrb5ckl" data-title="Computational Geometry" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" rel="tag">计算几何</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/abc/" rel="tag">abc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cf/" rel="tag">cf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/codeforces/" rel="tag">codeforces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dsu/" rel="tag">dsu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mst/" rel="tag">mst</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%BA%E5%9B%BE/" rel="tag">建图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" rel="tag">计算几何</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/abc/" style="font-size: 15px;">abc</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/cf/" style="font-size: 15px;">cf</a> <a href="/tags/codeforces/" style="font-size: 10px;">codeforces</a> <a href="/tags/dsu/" style="font-size: 10px;">dsu</a> <a href="/tags/mst/" style="font-size: 10px;">mst</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 15px;">图论</a> <a href="/tags/%E5%BB%BA%E5%9B%BE/" style="font-size: 10px;">建图</a> <a href="/tags/%E6%80%9D%E7%BB%B4/" style="font-size: 20px;">思维</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 10px;">最短路</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" style="font-size: 10px;">网络流</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size: 10px;">计算几何</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81/">并查集&amp;最小生成树部分题解及代码</a>
          </li>
        
          <li>
            <a href="/2023/01/03/pythonbasic/">pythonbasic</a>
          </li>
        
          <li>
            <a href="/2023/01/03/goodbye2022/">goodbye2022</a>
          </li>
        
          <li>
            <a href="/2022/11/11/ICPC-2021-EC-J/">ICPC-2021-EC-J</a>
          </li>
        
          <li>
            <a href="/2022/11/01/Codeforces-Round-831-A-E/">Codeforces Round 831 A - E</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Treasure<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>