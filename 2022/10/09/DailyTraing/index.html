<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  
  <title>DailyTraing | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="每日思维题Graph and StringProblem - A - Codeforces 题目大意： 给出一个由字符串ss建图的过程。  字符仅有$a,b,c$三种，建出的图中第$i$个顶点表示原来的第$i$个字符。 $i$与$j$有连边，当且仅当$s[i]$与$s[j]$相同或$s[i]$和$s[j]$是相邻的字符（$a$与$b$相邻，$b$与$c$相邻）  现给出由某个字符串$s$建出的图，">
<meta property="og:type" content="article">
<meta property="og:title" content="DailyTraing">
<meta property="og:url" content="http://example.com/2022/10/09/DailyTraing/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="每日思维题Graph and StringProblem - A - Codeforces 题目大意： 给出一个由字符串ss建图的过程。  字符仅有$a,b,c$三种，建出的图中第$i$个顶点表示原来的第$i$个字符。 $i$与$j$有连边，当且仅当$s[i]$与$s[j]$相同或$s[i]$和$s[j]$是相邻的字符（$a$与$b$相邻，$b$与$c$相邻）  现给出由某个字符串$s$建出的图，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-09T14:38:09.000Z">
<meta property="article:modified_time" content="2022-10-09T14:45:59.377Z">
<meta property="article:author" content="Treasure">
<meta property="article:tag" content="思维">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Treasure&#39;s blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-DailyTraing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/10/09/DailyTraing/" class="article-date">
  <time class="dt-published" datetime="2022-10-09T14:38:09.000Z" itemprop="datePublished">2022-10-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      DailyTraing
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="每日思维题"><a href="#每日思维题" class="headerlink" title="每日思维题"></a>每日思维题</h1><h2 id="Graph-and-String"><a href="#Graph-and-String" class="headerlink" title="Graph and String"></a>Graph and String</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/623/problem/A">Problem - A - Codeforces</a></p>
<p>题目大意：</p>
<p>给出一个由字符串s<em>s</em>建图的过程。</p>
<ul>
<li>字符仅有$a,b,c$三种，建出的图中第$i$个顶点表示原来的第$i$个字符。</li>
<li>$i$与$j$有连边，当且仅当$s[i]$与$s[j]$相同或$s[i]$和$s[j]$是相邻的字符（$a$与$b$相邻，$b$与$c$相邻）</li>
</ul>
<p>现给出由某个字符串$s$建出的图，构造一个字符串使其符合上面的要求要求，或者回答不存在这样的字符串。</p>
<p>解题思路：首先分析题目可以发现这样一件事情，对于出现的$b$来说他是需要连接所有点的，$a$只需要连接相邻的$a$以及$b$即可，$c$的话和$a$同理，那么其实这样子的话我们可以在刚开始的时候处理以下所有和其他点连接的点，赋值为$b$，然后我们可以考虑一件事情，对于$a$和$c$来说相对应的边是不相连的，那么对于原图的补图来说一定是一张二分图，然后我们可以判断二分图并且染色之后再去根据颜色判断，如果两个相邻的边是$a$以及$c$那么就是不行的</p>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 5e2 + 10;
int mp[maxn][maxn],n,m;
int deg[maxn],col[maxn];
char ans[maxn];
vector&lt;int&gt; edge[maxn];
int flag &#x3D; 1;
void dfs(int s,int fa)
&#123;
	for(auto to:edge[s])
	&#123;
		if(to &#x3D;&#x3D; fa) continue;
		if(col[to] &#x3D;&#x3D; -1)
		&#123;
			col[to] &#x3D; col[s] ^ 1;
			dfs(to,s);
		&#125;
		else if(col[to] &#x3D;&#x3D; col[s]) flag &#x3D; 0;
	&#125;
&#125;
int main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; n &gt;&gt; m;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i) mp[i][i] &#x3D; 1,col[i] &#x3D; -1;
	for(int i &#x3D; 1,u,v;i &lt;&#x3D; m;++i)
	&#123;
		cin &gt;&gt; u &gt;&gt; v;
		mp[u][v] &#x3D; mp[v][u] &#x3D; 1;
		deg[u]++;
		deg[v]++;
	&#125;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)
		&#123;
			if(mp[i][j]) continue;
			edge[i].emplace_back(j);
			edge[j].emplace_back(i);
		&#125;
	&#125;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		if(deg[i] &#x3D;&#x3D; n - 1) ans[i] &#x3D; &#39;b&#39;;
		else
		&#123;
			if(col[i] &#x3D;&#x3D; -1) col[i] &#x3D; 0,dfs(i,0);
		&#125;
	&#125;
	if(!flag)
	&#123;
		cout &lt;&lt; &quot;No\n&quot;;
		return 0;
	&#125;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		for(int j &#x3D; i + 1;j &lt;&#x3D; n;++j)
		&#123;
			if(mp[i][j] &amp;&amp; col[i] + col[j] &#x3D;&#x3D; 1)
			&#123;
				cout &lt;&lt; &quot;No\n&quot;;
				return 0;
			&#125;
		&#125;
	&#125;
	cout &lt;&lt; &quot;Yes\n&quot;;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		if(deg[i] &#x3D;&#x3D; n - 1)
		&#123;
			cout &lt;&lt; &quot;b&quot;;
		&#125;
		else if(col[i] &#x3D;&#x3D; 0) cout &lt;&lt; &quot;a&quot;;
		else cout &lt;&lt; &quot;c&quot;;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Carousel"><a href="#Carousel" class="headerlink" title="Carousel"></a>Carousel</h2><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/CF1328D">CF1328D Carousel - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a> </p>
<p><strong>题目大意:</strong> 有$q$组询问,每组询问如下:</p>
<p>已知一个有$n(3\le n\le 2<em>10^5)$个点的*<em>环</em></em>,点$i$的类型为$a_i$,现在需要给每个点进行染色,要求<strong>相邻</strong>不同类型的点的颜色不同且所用颜色数最小.输出颜色数及一种染色方案即可.(颜色从1开始)</p>
<p>注意: $n ≤2*10^5$</p>
<p><strong>解题思路:</strong></p>
<p>其实很容易想到环的颜色种类不多，至多只有$3$</p>
<p>那么我们可以进行这样子的讨论，首先我们可以把这个环分成奇环和偶环，对于偶环来说他有比较好的性质我们直接赋值$1$ $2$交替即可</p>
<p>那奇环呢？分析样例我们可以得出对于两两之间不一样的都是$3$种，反之就是$2$种</p>
<p>同时我们需要特判以下情况，在这个序列中只存在$1$种或者$2$种数字的情况</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 2e5 + 10;
int a[maxn],num[maxn],n;
int main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		int cnt &#x3D; 0;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			cin &gt;&gt; a[i];
			num[a[i]]++;
			if(num[a[i]] &#x3D;&#x3D; 1) cnt++;
		&#125;
		if(cnt &#x3D;&#x3D; 1)
		&#123;
			cout &lt;&lt; &quot;1\n&quot;;
			for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
			&#123;
				cout &lt;&lt; &quot;1 &quot;;
			&#125;
			cout &lt;&lt; &quot;\n&quot;;
		&#125;
		else if(cnt &#x3D;&#x3D; 2)
		&#123;
			cout &lt;&lt; 2 &lt;&lt; &quot;\n&quot;;
			for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
			&#123;
				if(a[i] &#x3D;&#x3D; a[1]) cout &lt;&lt; &quot;1 &quot;;
				else cout &lt;&lt; &quot;2 &quot;;
			&#125;
			cout &lt;&lt; &quot;\n&quot;;
		&#125;
		else if(n % 2 &#x3D;&#x3D; 0)
		&#123;
			cout &lt;&lt; 2 &lt;&lt; &quot;\n&quot;;
			for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
			&#123;
				cout &lt;&lt; (i &amp; 1)  + 1&lt;&lt; &quot; &quot;;
			&#125;
			cout &lt;&lt; &quot;\n&quot;;
		&#125;
		else
		&#123;
			int flag &#x3D; -1;
			for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)
			&#123;
				if(a[i] &#x3D;&#x3D; a[i + 1]) flag &#x3D; i;
			&#125;
			if(a[n] &#x3D;&#x3D; a[1]) flag &#x3D; n;
			if(flag &#x3D;&#x3D; -1)
			&#123;
				cout &lt;&lt; &quot;3\n&quot;;
				for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)
				&#123;
					cout &lt;&lt; (i &amp; 1) + 1 &lt;&lt; &quot; &quot;; 
				&#125;
				cout &lt;&lt; &quot;3\n&quot;;
			&#125;
			else
			&#123;
				cout &lt;&lt; &quot;2\n&quot;;
				for(int i &#x3D; 1;i &lt;&#x3D; flag;++i)
				&#123;
					if(i % 2) cout &lt;&lt; 1 &lt;&lt; &quot; &quot;;
					else cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;
				&#125;
				for(int i &#x3D; flag + 1;i &lt;&#x3D; n;++i)
				&#123;
					if(i % 2) cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;
					else cout &lt;&lt; 1 &lt;&lt; &quot; &quot;;
				&#125;
				cout &lt;&lt; &quot;\n&quot;;
			&#125;
		&#125;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) num[a[i]] &#x3D; 0;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="What-a-Colorful-Wall"><a href="#What-a-Colorful-Wall" class="headerlink" title="What a Colorful Wall"></a>What a Colorful Wall</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/group/MKpYqfAQQQ/contest/393177/problem/F">Problem - F - Codeforces</a></p>
<p><strong>题目大意:</strong> 给定$n$个矩形，每个矩形有一定的颜色，矩形之间可以相互覆盖，问在$n$个矩形覆盖之后整个坐标系中最多存在着多少种颜色</p>
<p><strong>解题思路:</strong> 首先先思考这样子的一件事情，因为矩形具有覆盖性，因此我们可以从后往前去放置矩形，因为后面的矩形总是不会被前面的矩形所覆盖，首先对于相同的$x$坐标的一个区域来说，如果一个矩形的高度小于另外一个的高度并且它的，那么它在这个$x$轴影响的$y$上面是被覆盖的，那么对于其他的$x$呢？我们可以利用一个类似于扫描线的做法，遍历相对应的$x$轴遍历过去即可，然后用并查集维护相对应的$y$是否已经是在同一条线上面</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 4e3 + 10;
int fa[maxn * 2],n,ans[maxn];
vector&lt;int&gt; posx,posy;
vector&lt;array&lt;int,5&gt;&gt; pos;
void init()
&#123;
	for(int i &#x3D; 0;i &lt;&#x3D; 8010;++i) fa[i] &#x3D; i;
&#125;
int getf(int x)
&#123;
	if(x &#x3D;&#x3D; fa[x]) return x;
	fa[x] &#x3D; getf(fa[x]);
	return fa[x];
&#125;
void merge(int x,int y)
&#123;
	x &#x3D; getf(x);
	y &#x3D; getf(y);
	fa[x] &#x3D; y;
&#125;
int getx(int x)
&#123;
	int px &#x3D; lower_bound(posx.begin(),posx.end(),x) - posx.begin();
	return px;
&#125;
int gety(int y)
&#123;
	int py &#x3D; lower_bound(posy.begin(),posy.end(),y) - posy.begin();
	return py;
&#125;
int main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; n;
	for(int i &#x3D; 1,x1,y1,x2,y2,col;i &lt;&#x3D; n;++i)
	&#123;
		cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; col;
		posx.push_back(x1),posx.push_back(x2);
		posy.push_back(y1),posy.push_back(y2);
		pos.push_back(&#123;x1,y1,x2,y2,col&#125;);
	&#125;
	sort(posx.begin(),posx.end());
	sort(posy.begin(),posy.end());
	posx.erase(unique(posx.begin(),posx.end()),posx.end());
	posy.erase(unique(posy.begin(),posy.end()),posy.end());
	for(auto &amp;now:pos)
	&#123;
		now[0] &#x3D; getx(now[0]),now[2] &#x3D; getx(now[2]);
		now[1] &#x3D; gety(now[1]),now[3] &#x3D; gety(now[3]); 
		&#x2F;&#x2F; cout &lt;&lt; now[0] &lt;&lt; &quot; &quot;
	&#125;
	int tot &#x3D; posx.size();
	for(int i &#x3D; 0;i &lt;&#x3D; tot;++i)
	&#123;
		init();
		for(int j &#x3D; n - 1;j &gt;&#x3D; 0;--j)
		&#123;
			auto now &#x3D; pos[j];
			if(now[0] &lt;&#x3D; i &amp;&amp; now[2] &gt; i)
			&#123;
				int ny &#x3D; getf(now[1]);
				while(ny &gt; now[3])
				&#123;
					merge(ny,ny - 1);
					ans[now[4]] &#x3D; 1;
					ny &#x3D; getf(ny);
				&#125;
			&#125;
		&#125;
	&#125;
	int res &#x3D; 0;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i) res +&#x3D; ans[i];
	cout &lt;&lt; res &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Chemical-table"><a href="#Chemical-table" class="headerlink" title="Chemical table"></a>Chemical table</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1013/problem/D">Problem - D - Codeforces</a></p>
<p><strong>题意:</strong> 给定一个$n * m$的棋盘，给定$q$个元素，这些元素在棋盘的上面，如果对于一个$2 * 2$的矩形来说，这个矩形中的三个值都存在但是还有一个值不存在，那么这个值也会自动生成，问最多要加多少个值才能使得这个棋盘最后是满的</p>
<p><strong>解题思路:</strong> 首先我们先分析最后的棋盘的状态，最后棋盘的状态是一个满的形式，对于棋盘来说我们可以把它看成一个二分图的形式，左边是列右边是行，然后我们去分析最终态，最终态是行和列的点都在一个连通块中；然后我们分析题目给定的条件，每次对于一个行和列连边，然后对于生成那个新点来说，实际上并不会影响当前连通块的情况，那么我们只需要连接所有的边，然后找出连通块的数量是多少，最后再加上相对应的边即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 4e5 + 10;
int f[maxn],n,m,q;
int getf(int x)
&#123;
	return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);
&#125;
void merge(int x,int y)
&#123;
	x &#x3D; getf(x);
	y &#x3D; getf(y);
	f[x] &#x3D; y;
&#125;

int main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
	for(int i &#x3D; 1;i &lt;&#x3D; n + m;++i)
	&#123;
		f[i] &#x3D; i;
	&#125;
	for(int i &#x3D; 1,x,y;i &lt;&#x3D; q;++i)
	&#123;
		cin &gt;&gt; x &gt;&gt; y;
		merge(x,y + n);
	&#125;
	int ans &#x3D; 0;
	for(int i &#x3D; 1;i &lt;&#x3D; n + m;++i)
	&#123;
		if(getf(i) &#x3D;&#x3D; i)
		&#123;
			ans++;
		&#125;
	&#125;
	cout &lt;&lt; ans - 1 &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Cross-Swapping"><a href="#Cross-Swapping" class="headerlink" title="Cross Swapping"></a>Cross Swapping</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1713/problem/E">Problem - E - Codeforces</a></p>
<p><strong>题意:</strong> 给定一个$n * n$的矩阵，可以选定一个$k$，交换所有的$mp[i][k]$和$mp[k][i]$，可以进行这样子的操作若干次，问在进行操作<br>之后这个矩阵字典序最小是什么样子的<br><strong>解题思路:</strong> 模拟每一次交换的过程，我们发现实际上$mp[i][j]$只会和$mp[j][i]$交换，既然这样那么实际上我们就很好去操作了<br>如果我们要交换$mp[i][j]$和$mp[j][i]$，我们只需要选定$k &#x3D; i$ $or$ $k &#x3D; j$,如果不交换我们可以两个都不选或者两个都选偶数次<br>然后的话我们可以用并查集来维护相对应的关系，用类似于敌人朋友的并查集来维护这个东西。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 2e3 + 10;
int mp[maxn][maxn],n;
int f[maxn];
int getf(int x)
&#123;
	return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; getf(f[x]);
&#125;
void merge(int x,int y)
&#123;
	x &#x3D; getf(x);
	y &#x3D; getf(y);
	f[x] &#x3D; y;
&#125;
int main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			for(int j &#x3D; 1;j &lt;&#x3D; n;++j)
			&#123;
				cin &gt;&gt; mp[i][j];
			&#125;
		&#125;
		for(int i &#x3D; 1;i &lt;&#x3D; 2 * n;++i) f[i] &#x3D; i;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			for(int j &#x3D; i;j &lt;&#x3D; n;++j)
			&#123;
				if(mp[i][j] &lt; mp[j][i])
				&#123;
					&#x2F;&#x2F;not change
					if(getf(i) &#x3D;&#x3D; getf(j + n)) continue;
					merge(i,j),merge(i + n,j + n);
				&#125;
				else if(mp[i][j] &gt; mp[j][i])
				&#123;
					&#x2F;&#x2F;change
					if(getf(i) &#x3D;&#x3D; getf(j)) continue;
					merge(i,j + n),merge(i + n,j);
				&#125;
			&#125;
		&#125;
		for(int k &#x3D; 1;k &lt;&#x3D; n;++k)
		&#123;
			if(getf(k) &gt; n) continue;
			for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
			&#123;
				swap(mp[i][k],mp[k][i]);
			&#125;
		&#125;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			for(int j &#x3D; 1;j &lt;&#x3D; n;++j)
			&#123;
				cout &lt;&lt; mp[i][j] &lt;&lt; &quot; \n&quot;[j &#x3D;&#x3D; n];
			&#125;
		&#125;
	&#125;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Mikasa"><a href="#Mikasa" class="headerlink" title="Mikasa"></a>Mikasa</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1554/problem/C">Problem - C - Codeforces</a></p>
<p><strong>题意:</strong> 给定$T$组数据，每组数据有一个$n$和$m$,给定一个序列从$n \bigoplus 0,n \bigoplus 1,…,n \bigoplus m$问这个序列中没有出现过的最小数字是多少</p>
<p><strong>解题思路:</strong> 考虑再这个序列中出现过的数字$k$,那么存在$x$使得式子$n \bigoplus x &#x3D; k,x ∈ [0,m]$成立,那么对于上面的式子其实可以等价于$n \bigoplus k &#x3D; x, 0 \leq n \bigoplus k \leq m$，那么我们要求的答案也就是去找一个最小的$k$使得$n \bigoplus k \geq m + 1$，那么这样子的话我们就可以进行按位考虑，假设$p &#x3D; m + 1$,我们从高位开始考虑，如果这个位置上面$n_i &#x3D; 1,p_i &#x3D; 0$,那么直接break掉，如果$n_i &#x3D; 0,p_i &#x3D; 1$,则需要加上这一位的贡献</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define int long long
int n,m;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n &gt;&gt; m;
		int p &#x3D; m + 1;
		int ans &#x3D; 0;
		for(int i &#x3D; 30;i &gt;&#x3D; 0;--i)
		&#123;
			int ni &#x3D; (n &gt;&gt; i &amp; 1);
			int pi &#x3D; (p &gt;&gt; i &amp; 1);
			if(ni &#x3D;&#x3D; 1 &amp;&amp; pi &#x3D;&#x3D; 0) break;
			if(ni &#x3D;&#x3D; 0 &amp;&amp; pi &#x3D;&#x3D; 1) ans +&#x3D; (1 &lt;&lt; i);
		&#125;
		cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Count-Triangles"><a href="#Count-Triangles" class="headerlink" title="Count Triangles"></a>Count Triangles</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1355/C">Problem - 1355C - Codeforces</a></p>
<p><strong>题意:</strong> 给定四个数字$A,B,C,D$使得三角形的三个边$a,b,c$分别满足$A \leq a \leq B, B\leq b \leq C,C \leq c \leq D$,问这样子的三元组$a,b,c$有多少</p>
<p><strong>解题思路:</strong> 其实拿到题目的时候我们可以直接考虑枚举，但是直接分别枚举$a,b$是否在区间里面时间肯定是有点问题的，但是既然是三角形我们其实如果知道$a + b$是多少我们就能找到对应的第三条边是多少，既然这样的话那么我们只需要枚举$a + b$中有多少个就可以了，然后通过差分数组去维护相对应的数量，那么对应的$a + b$在数据范围中对应的第三条边可能是啥呢？其实是在一个范围中，我们在$a + b - C$和$D + C - 1$中取小的就可以了，当然需要特判一下$a + b - C$小于$0$的情况</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define int long long
typedef long long ll;
vector&lt;int&gt; pa,pb,pc;
int A,B,C,D;
const int maxn &#x3D; 2e6 + 10;
int sum[maxn];
signed  main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;
	for(int i &#x3D; A;i &lt;&#x3D; B;++i) sum[i + B]++,sum[i + C + 1]--;
	for(int i &#x3D; 1;i &lt;&#x3D; 3 * D;++i) sum[i] +&#x3D; sum[i - 1];
	int ans &#x3D; 0;
	for(int i &#x3D; 1;i &lt;&#x3D; 3 * D;++i)
	&#123;
		ans +&#x3D; sum[i] * max(0ll,min(i - C,D - C + 1));
	&#125;
	cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Integers-Have-Friends"><a href="#Integers-Have-Friends" class="headerlink" title="Integers Have Friends"></a>Integers Have Friends</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1548/B">Problem - 1548B - Codeforces</a></p>
<p><strong>题意:</strong> 给定一个长度为$n$的序列，序列中每个元素的数值各不相同，找一个最长的子序列使得这个子序列中$mod $ $m$都是相同的数字</p>
<p><strong>解题思路:</strong> 因为题目中需要找到$a[i]$  $mod$ $m$ $&#x3D;$ $a[j]$ $mod$ $m$,那么对于这样子的式子我们可以先进行一个化简，那么就是$(a[i] - a[j])  $ $ mod $</p>
<p> $m &#x3D; 0$,然后我们可以对这个序列进行一个处理，处理之后二分找最长的即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define int long long
typedef long long ll;
const int maxn &#x3D; 2e5 + 10;
int a[maxn],n;
int b[maxn],tree[maxn &lt;&lt; 2];
inline void build(int k,int l,int r)
&#123;
	if(l &#x3D;&#x3D; r)
	&#123;
		tree[k] &#x3D; b[l];
		return;
	&#125;
	int mid &#x3D; (l + r) &gt;&gt; 1;
	build(k &lt;&lt; 1,l,mid);
	build(k &lt;&lt; 1 | 1,mid + 1,r);
	tree[k] &#x3D; __gcd(tree[k &lt;&lt; 1],tree[k &lt;&lt; 1 | 1]);
	return;
&#125;
inline int query(int k,int l,int r,int lx,int rx)
&#123;
	if(l &#x3D;&#x3D; lx &amp;&amp; r &#x3D;&#x3D; rx)
	&#123;
		return tree[k];
	&#125;
	int mid &#x3D; (l + r) &gt;&gt; 1;
	int ans &#x3D; 0;
	if(rx &lt;&#x3D; mid) ans &#x3D; __gcd(ans,query(k &lt;&lt; 1,l,mid,lx,rx));
	else
	&#123;
		if(lx &gt; mid) ans &#x3D; __gcd(ans,query(k &lt;&lt; 1 | 1,mid + 1,r,lx,rx));
		else ans &#x3D;__gcd(ans,__gcd(query(k &lt;&lt; 1,l,mid,lx,mid),query(k &lt;&lt; 1 | 1,mid + 1,r,mid + 1,rx)));
	&#125;
	return ans;
&#125;
int check(int x)
&#123;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		if(i + x - 1 &gt; n) break;
		if(abs(query(1,1,n,i + 1,i + x - 1)) !&#x3D; 1)
		&#123;
			return 1;
		&#125;
	&#125;
	return 0;
&#125;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			cin &gt;&gt; a[i];
		&#125;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			b[i] &#x3D; a[i] - a[i - 1];
		&#125;
		build(1,1,n);
		int ans &#x3D; 1;
		int L &#x3D; 2;
		int R &#x3D; n;
		while(L &lt;&#x3D; R)
		&#123;
			int mid &#x3D; (L + R) &gt;&gt; 1;
			if(check(mid))
			&#123;
				L &#x3D; mid + 1;
				ans &#x3D; max(ans,mid);
			&#125;
			else
			&#123;
				R &#x3D; mid - 1;
			&#125;
		&#125;
		cout &lt;&lt; ans&lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Distance-in-Tree"><a href="#Distance-in-Tree" class="headerlink" title="Distance in Tree"></a>Distance in Tree</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/161/problem/D">Problem - D - Codeforces</a></p>
<p><strong>题意:</strong> 给定一棵$n$个结点的树，需要找出这个树上面距离严格为$k$的点对有多少个<br><strong>解题思路:</strong> 拿到题目之后看$k$的范围实际上不大，有$500$左右，那么其实$nk$时间复杂度的算法是可以过的<br>那么接下来去思考如何用$nk$的时间复杂度去求<br>那么我们可以考虑这样子的一件事情，假设我们已经知道当前这里的一个点距离它距离为$x$的点都已知道<br>那么对于答案的贡献实际上可以是$ans +&#x3D; dp[now][i] * dp[to][k - i - 1]$<br>然后我们再更新相对应的数量即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define int long long
const int maxn &#x3D; 5e4 + 10;
int dp[maxn][520];
int n,ans,k;
vector&lt;int&gt; edge[maxn];
void dfs(int s,int fa)
&#123;
	dp[s][0] &#x3D; 1;
	for(auto to:edge[s])
	&#123;
		if(to &#x3D;&#x3D; fa) continue;
		dfs(to,s);
		for(int i &#x3D; 0;i &lt; k;++i) ans +&#x3D; dp[s][i] * dp[to][k - i - 1];
		for(int i &#x3D; 0;i &lt; k;++i) dp[s][i + 1] +&#x3D; dp[to][i];
	&#125;
&#125;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; n &gt;&gt; k;
	for(int i &#x3D; 1,u,v;i &lt;&#x3D; n - 1;++i)
	&#123;
		cin &gt;&gt; u &gt;&gt; v;
		edge[u].emplace_back(v);
		edge[v].emplace_back(u);
	&#125;
	dfs(1,0);
	cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="The-Sports-Festival"><a href="#The-Sports-Festival" class="headerlink" title="The Sports Festival"></a>The Sports Festival</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1509/C">Problem - 1509C - Codeforces</a></p>
<h2 id="Three-Bags"><a href="#Three-Bags" class="headerlink" title="Three Bags"></a>Three Bags</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1467/C">Problem - 1467C - Codeforces</a></p>
<p><strong>题目大意:</strong> 给定$3$个集合，可以选定任意两个集合中的元素$a,b$,移走$b$并且让$a$变成$a - b$</p>
<p>问最后剩下的元素最大值是多少</p>
<p><strong>解题思路:</strong> 首先考虑如果在没有集合限制的情况下，其实我们进行这样子的操作就会使得一个数字没有取到，那么其实对应到集合来说，就是两个不同集合的数字的最小值没有取到是最优的；还有一种取法，就是另外两个集合全部取完，还有一个集合全部不取</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
#define int long long
const int maxn &#x3D; 1e6 + 10;
int n,m,k;
int sum;
int a[maxn],b[maxn],c[maxn],sa,sb,sc;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
	int ma,mb,mc;
	ma &#x3D; mb &#x3D; mc &#x3D; 1e9 + 7;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		cin &gt;&gt; a[i];
		sum +&#x3D; a[i];
		sa +&#x3D; a[i];
		ma &#x3D; min(ma,a[i]);
	&#125;
	for(int i &#x3D; 1;i &lt;&#x3D; m;++i)
	&#123;
		cin &gt;&gt; b[i];
		sum +&#x3D; b[i];
		sb +&#x3D; b[i];
		mb &#x3D; min(mb,b[i]);
	&#125;
	for(int i &#x3D; 1;i &lt;&#x3D; k;++i)
	&#123;
		cin &gt;&gt; c[i];
		sum +&#x3D; c[i];
		sc +&#x3D; c[i];
		mc &#x3D; min(mc,c[i]);
	&#125;
	int ans &#x3D; max(&#123;sum - 2 * (ma + mb),sum - 2 * (mb + mc),sum - 2 * (mc + ma),sum - 2 * sa,sum - 2 * sb,sum - 2 * sc&#125;);
	cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Dr-Evil-Underscores"><a href="#Dr-Evil-Underscores" class="headerlink" title="Dr. Evil Underscores"></a>Dr. Evil Underscores</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1285/problem/D">Problem - D - Codeforces</a></p>
<p><strong>题意:</strong> 给定$n$个数字，需要找到一个数字$x$使得这些数字$\bigoplus x$的最大值最小</p>
<p><strong>解题思路:</strong> 拿到题目之后我们可以想到拆位去思考，首先我们考虑这样子的一件事情，对于高位来说肯定是能消掉尽可能消掉，不能消掉再看接下来这个高位所带来的影响，然后对于一位来说，如果这一位在所有数字上面都是相同的，那么其实它就可以最后消掉；如果有存在不相同的，对于最终答案来说这一位肯定是取$1$的，但是对于后面的位数还是不确定什么是更优的，因此还是需要找下去</p>
<p>所以我们可以建立一棵$tire$树，在$tire$树上面跑$dfs$即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 2e6 + 10;
int tire[maxn][2],cnt,n;
void insert(int x)
&#123;
	int root &#x3D; 0;
	for(int i &#x3D; 30;i &gt;&#x3D; 0;--i)
	&#123;
		int id &#x3D; (x &gt;&gt; i &amp; 1);
		if(!tire[root][id]) tire[root][id] &#x3D; ++cnt;
		root &#x3D; tire[root][id];
	&#125;
&#125;
int dfs(int pos,int now)
&#123;
	if(now &lt; 0) return 0;
	int ans &#x3D; 0;
	if(tire[pos][0] &amp;&amp; tire[pos][1])
	&#123;
		ans +&#x3D; (1 &lt;&lt; now);
		ans +&#x3D; min(dfs(tire[pos][0],now - 1),dfs(tire[pos][1],now - 1)); 
	&#125;
	else if(tire[pos][0])
	&#123;
		ans +&#x3D; dfs(tire[pos][0],now - 1);
	&#125;
	else if(tire[pos][1])
	&#123;
		ans +&#x3D; dfs(tire[pos][1],now - 1);
	&#125;
	return ans;
&#125;
int main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; n;
	for(int i &#x3D; 1,x;i &lt;&#x3D; n;++i)
	&#123;
		cin &gt;&gt; x;
		insert(x);
	&#125;
	cout &lt;&lt; dfs(0,30) &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="New-Year’s-Problem"><a href="#New-Year’s-Problem" class="headerlink" title="New Year’s Problem"></a>New Year’s Problem</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1619/problem/D">Problem - D - Codeforces</a></p>
<p><strong>题目大意:</strong> 给定$m$个商店，有$n$个人，最多可以在$n - 1$个商店中买东西，第$i$个人收到第$j$个物品的数值是$A{i,j}$</p>
<p>问如何选择能够让所有人的最小开心值最高</p>
<p><strong>解题思路:</strong> 其实题目有两个$trick$点，一个是最小的开心值最大，对于这一个点我们可以使用二分来解决，还有一个就是$n - 1$个商店，那么对于$n - 1$来说我们可以思考的一个点也就是鸽巢原理。那么我们在写二分$check$的时候可以这样子，因为我们是选定$n - 1$个，如果对于当前选定的$x$来说，存在对应的人的最大值没有，那么就直接返回$0$，然后对于第二个部分的话我们可以考虑这样子的一个东西，至少要有一个商店带来两个人的贡献，否则就无法使用$n - 1$个</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
const int maxn &#x3D; 1e5 + 10;
int n,m;
int main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n &gt;&gt; m;
		vector&lt;vector&lt;int&gt;&gt; mp(n + 1,vector&lt;int&gt;(m + 1));
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
		&#123;
			for(int j &#x3D; 1;j &lt;&#x3D; m;++j)
			&#123;
				cin &gt;&gt; mp[i][j];
			&#125;
		&#125;

		auto check &#x3D; [](int x,vector&lt;vector&lt;int&gt;&gt; &amp;mp)
		&#123;
			for(int i &#x3D; 1;i &lt;&#x3D; m;++i)
			&#123;
				int f &#x3D; 0;
				for(int j &#x3D; 1;j &lt;&#x3D; n;++j)
				&#123;
					if(mp[j][i] &gt;&#x3D; x) f &#x3D; 1;
				&#125;
				if(!f) return 0;
			&#125;
			for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
			&#123;
				int ct &#x3D; 0;
				for(int j &#x3D; 1;j &lt;&#x3D; m;++j)
				&#123;
					ct +&#x3D; (mp[i][j] &gt;&#x3D; x);
				&#125;
				if(ct &gt;&#x3D; 2) return 1;
			&#125;
			return 0;
		&#125;;
		int L &#x3D; 0;
		int R &#x3D; 1000000000;
		int ans &#x3D; 0;
		while(L &lt;&#x3D; R)
		&#123;
			int mid &#x3D; (L + R) &gt;&gt; 1;
			if(check(mid,mp))
			&#123;
				L &#x3D; mid + 1;
				ans &#x3D; max(ans,mid);
			&#125;
			else R &#x3D; mid - 1;
		&#125;
		cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Left-Right-Operation"><a href="#Left-Right-Operation" class="headerlink" title="Left Right Operation"></a><strong>Left Right Operation</strong></h2><p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc263/tasks/abc263_d">D - Left Right Operation (atcoder.jp)</a></p>
<h2 id="Zuma"><a href="#Zuma" class="headerlink" title="Zuma"></a>Zuma</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/607/problem/B">Problem - B - Codeforces</a></p>
<p><strong>题目大意:</strong> 给定$n$个东西，每个东西有一个颜色，每次可以消除颜色是回文串的一个字串，消除一个字串之后会自动拼接回去，问最少需要几次可以消除完</p>
<p><strong>解题思路:</strong> 数据很小只有$500$，考虑区间$dp$</p>
<p>然后接下来我们来思考转移过程，因为每次消去的都是一个回文串，那么对于我们枚举的$l$和$r$来说可以放到上一个回文串中一起删除掉，如果$l &#x3D;&#x3D; r$</p>
<p>那么$dp[l][r] &#x3D; dp[l - 1][r + 1]$</p>
<p>否则我们需要考虑一个断点，在这个断点的两边进行$dp$</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;
template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;
#define int long long
const int maxn &#x3D; 5e2 + 10;
int dp[maxn][maxn];
int a[maxn],n;
int check(int l,int r)
&#123;
	string s &#x3D; &quot;&quot;;
	for(int i &#x3D; l;i &lt;&#x3D; r;++i)
	&#123;
		char id &#x3D; &#39;0&#39; + a[i];
		s.push_back(id);
	&#125;
	string ss &#x3D; s;
	reverse(ss.begin(),ss.end());
	return ss &#x3D;&#x3D; s;
&#125;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin &gt;&gt; n;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		cin &gt;&gt; a[i];
		dp[i][i] &#x3D; 1;
	&#125;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		int r &#x3D; i + 2 - 1;
		if(r &gt; n) break;
		if(a[i] !&#x3D; a[r])
		&#123;
			dp[i][r] &#x3D; 2;
		&#125;
		else dp[i][r] &#x3D; 1;
	&#125;
	for(int len &#x3D; 3;len &lt;&#x3D; n;++len)
	&#123;
		for(int l &#x3D; 1;l &lt;&#x3D; n;++l)
		&#123;
			int r &#x3D; l + len - 1;
			if(r &gt; n) break;
			if(a[l] &#x3D;&#x3D; a[r]) dp[l][r] &#x3D; dp[l + 1][r - 1];
			else dp[l][r] &#x3D; min(dp[l + 1][r],dp[l][r - 1]) + 1;
			for(int mid &#x3D; l;mid &lt;&#x3D; r;++mid)
			&#123;
				chkmin(dp[l][r],dp[l][mid] + dp[mid + 1][r]);
			&#125;
		&#125;
	&#125;
	cout &lt;&lt; dp[1][n] &lt;&lt; &quot;\n&quot;;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Book-of-Evil"><a href="#Book-of-Evil" class="headerlink" title="Book of Evil"></a>Book of Evil</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/337/D">Problem - 337D - Codeforces</a></p>
<h2 id="Empty-Graph"><a href="#Empty-Graph" class="headerlink" title="Empty Graph"></a>Empty Graph</h2><p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1712/D">https://codeforces.com/problemset/problem/1712/D</a></p>
<p><strong>题目大意:</strong> 给定一个长度为$n(1\leq n \leq 2e5)$的序列,对于任意的$(l,r),1 \leq l &lt; r \leq n$存在一条边连接$l$以及$r$，边权是$min(a_l,a_{l + 1},…,a_r)$</p>
<p>我们有$k$次操作机会可以将一个位置上的数字变成任意数字$x(1\leq x \leq 1e9)$,问这张图的直径是多少</p>
<p>一张图的直径定义如下所示: $max_{1 \leq u &lt; v \leq n}d(u,v)$,$d(u,v)$是从$u$到$v$的最短路</p>
<p><strong>解题思路:</strong>  首先我们先分析一下$d(u,v)$在这种情况下可能由什么组成，要么我是走两条最小的从$u$到$v$，如果是两个相邻的情况，那么我实际上$u$到$v$是只需要取$min(a_u,a_v)$</p>
<p>然后考虑这$k$次操作我们怎么使用，因为次数肯定是使用越多我最后的答案趋向于越大，具有一定的单调性，因此我们可以使用二分来写</p>
<p>我们去遍历整个序列，对于我们当前$check$的$x$来说，如果当前的数字小于$\frac{x}{2}$，那么我们需要一次机会将其变大</p>
<p>如果当前所需要的次数大于$k$的话，那么是不行的，我们就不要这一种情况</p>
<p>如果相同的话，我们看一下整个序列最大的$d$是多少，看看是否大于等于$x$即可</p>
<p>如果小于$k$次的话，找序列中最大的数字即可</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
template&lt;typename T&gt; inline bool chkmin(T &amp;a, const T &amp;b) &#123; return a &gt; b ? a &#x3D; b, 1 : 0; &#125;
template&lt;typename T&gt; inline bool chkmax(T &amp;a, const T &amp;b) &#123; return a &lt; b ? a &#x3D; b, 1 : 0; &#125;
#define int long long
const int maxn &#x3D; 2e5 + 10;
int a[maxn],n,k,use[maxn];
int cal()
&#123;
	int now1 &#x3D; min(use[1],use[2]);
	for(int i &#x3D; 1;i &lt;&#x3D; n - 1;++i)
	&#123;
		now1 &#x3D; max(now1,min(use[i],use[i + 1]));
	&#125;
	int mi &#x3D; use[1];
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		chkmin(mi,use[i]);
	&#125;
	return min(2 * mi,now1);
&#125;
int check(int x)
&#123;
	int cs &#x3D; 0;
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i) use[i] &#x3D; a[i];
	for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
	&#123;
		if(use[i] * 2 &lt; x)
		&#123;
			cs++;
			use[i] &#x3D; 1e9;
		&#125;
	&#125;
	if(cs &gt; k) return 0;
	else if(cs &#x3D;&#x3D; k)
	&#123;
		int now &#x3D; cal();
		&#x2F;&#x2F; cout &lt;&lt; &quot;??? &quot; &lt;&lt; now &lt;&lt; &quot;\n&quot;;
		if(now &gt;&#x3D; x) return 1;
		return 0;
	&#125;
	else
	&#123;
		&#x2F;&#x2F; cout &lt;&lt; 33 &lt;&lt; &quot;\n&quot;;
		if(k &#x3D;&#x3D; 1)
		&#123;
			int now &#x3D; use[1];
			for(int i &#x3D; 1;i &lt;&#x3D; n;++i)
			&#123;
				chkmax(now,use[i]);
			&#125;
			&#x2F;&#x2F; cout &lt;&lt; &quot;now -&gt; &quot; &lt;&lt; now &lt;&lt; &quot; x -&gt; &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;
			if(now &gt;&#x3D; x) return 1;
			return 0;
		&#125;
		return 1;
	&#125;
&#125;
signed main()
&#123;
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int T;
	cin &gt;&gt; T;
	while(T--)
	&#123;
		cin &gt;&gt; n &gt;&gt; k;
		for(int i &#x3D; 1;i &lt;&#x3D; n;++i) cin &gt;&gt; a[i];
		int L &#x3D; 1,R &#x3D; 1e9;
		int ans &#x3D; 0;
		&#x2F;&#x2F; cout &lt;&lt; &quot;?? &quot; &lt;&lt; check(4) &lt;&lt; &quot;\n&quot;;
		while(L &lt;&#x3D; R)
		&#123;
			int mid &#x3D; (L + R) &gt;&gt; 1;
			if(check(mid))
			&#123;
				L &#x3D; mid + 1;
				ans &#x3D; mid;
			&#125;
			else R &#x3D; mid - 1;
		&#125;
		cout &lt;&lt; ans &lt;&lt; &quot;\n&quot;;
	&#125;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在异或运算中，若$x \bigoplus y &#x3D; z$则有$x \bigoplus z &#x3D; y$</li>
<li>在两个数字取余需要相等的时候，可以转移一下位置变成一个等式</li>
<li>注意模拟样例的时候样例给定的特殊性质</li>
<li>对于$n - 1$这个数字我们要特殊考虑一下$trick$点</li>
<li>边着色考虑特殊情况比如有一些情况只需要两种颜色即可$(CF1217D)$</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/09/DailyTraing/" data-id="clcisuazt00085vwlgdooa36l" data-title="DailyTraing" class="article-share-link">分享</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/10/11/cf825/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          Codeforces Round 825 A-C1 D
        
      </div>
    </a>
  
  
    <a href="/2022/10/09/Dytechlab-Cup-2022/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Dytechlab Cup 2022</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/abc/" rel="tag">abc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blog/" rel="tag">blog</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cf/" rel="tag">cf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/codeforces/" rel="tag">codeforces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dsu/" rel="tag">dsu</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mst/" rel="tag">mst</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%BA%E5%9B%BE/" rel="tag">建图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%9D%E7%BB%B4/" rel="tag">思维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" rel="tag">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" rel="tag">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" rel="tag">计算几何</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/abc/" style="font-size: 15px;">abc</a> <a href="/tags/blog/" style="font-size: 10px;">blog</a> <a href="/tags/cf/" style="font-size: 15px;">cf</a> <a href="/tags/codeforces/" style="font-size: 10px;">codeforces</a> <a href="/tags/dsu/" style="font-size: 10px;">dsu</a> <a href="/tags/mst/" style="font-size: 10px;">mst</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 15px;">图论</a> <a href="/tags/%E5%BB%BA%E5%9B%BE/" style="font-size: 10px;">建图</a> <a href="/tags/%E6%80%9D%E7%BB%B4/" style="font-size: 20px;">思维</a> <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/" style="font-size: 10px;">最短路</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/" style="font-size: 10px;">网络流</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/" style="font-size: 10px;">计算几何</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/05/%E5%B9%B6%E6%9F%A5%E9%9B%86-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%E5%8F%8A%E4%BB%A3%E7%A0%81/">并查集&amp;最小生成树部分题解及代码</a>
          </li>
        
          <li>
            <a href="/2023/01/03/pythonbasic/">pythonbasic</a>
          </li>
        
          <li>
            <a href="/2023/01/03/goodbye2022/">goodbye2022</a>
          </li>
        
          <li>
            <a href="/2022/11/11/ICPC-2021-EC-J/">ICPC-2021-EC-J</a>
          </li>
        
          <li>
            <a href="/2022/11/01/Codeforces-Round-831-A-E/">Codeforces Round 831 A - E</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Treasure<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>